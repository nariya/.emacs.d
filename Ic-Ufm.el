;;; Ic-Ufm.el --- 超強力ファイルマネージャ (Ver.3)
;;
;; Copyright (C) 1997-2001 臼田 拓史 (Usuda Hiroshi)

;; Author      : Usuda Hiroshi <usuda-hiroshi@fujielectric.co.jp>
;; Keywords    : file Ic
;; Version     : 3.9.17
;; Last-Modify : Sat Jul  1 02:01:30 2000
;; Test        : GNU Emacs 20.7.6 (i686-pc-linux-gnu, X toolkit)
;; TAB         : 4
;; WEB         : http://www.d4.dion.ne.jp/~usuda/emacs/Ufm.tgz

;;; Commentary:

;;  ■ 著作権
;;
;;  This program is free software; you can redistribute it and/or modify
;;  it under the terms of the GNU General Public License as published by
;;  the Free Software Foundation; either version 2 of the License, or
;;  (at your option) any later version.
;;
;;  This program is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU General Public License for more details.
;;
;;  You should have received a copy of the GNU General Public License
;;  along with this program; if not, write to the Free Software
;;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
;;
;;  著作権は保持しますが、複製・配布・変更は大歓迎。変更してもその事を
;;  書いてくれれば連絡はいりません。配布の際は、無保証、無請求でおねが
;;  いします。詳しくは 「GNU General Public License version 2」を見て
;;  ください。
;;
;;  ■ はじめに
;;
;;      Emacs上で使用できる強力なファイルマネージャです。
;;      いっしょうけんめいつくったのでぜひ使って下さいね。
;;
;;  ■ 免責
;;
;;      このファイルマネージャを使ってどのような損害を受けた・・(たと
;;      えば、ディレクトリごと貴方の一年間の努力の結晶が一瞬のうちに消
;;      えてしまったとか)としても、私は全く責任を負いません。個人の責
;;      任において使用し、呪いのメールとかは送らないでください。ちなみ
;;      に、私は作成から４年程使っていますが、いまだにバグによる被害は
;;      ありません。もっとも、この情報は作者本人の経験であるために、信
;;      頼性ははなはだ小さいものと思われます。
;;
;;  ■ 作動環境
;;
;;      Emacs Mule Meadow XEmacs などで動きます。Windowsの場合はcygwin
;;      を入れましょう。入れないとコピーさえ働かないかも。
;;
;;  ■ 主な機能 (だんだん長くなってきたので、適当に飛ばして読んで下さい)
;;
;;      ファイル基本操作
;;
;;          ファイルのコピー、移動、名前変更、編集などの基本的な機能。
;;
;;      マクロメニュー
;;
;;          ＵＮＩＸコマンドにファイル名やオプションを動的につけて呼び
;;          出す機能です。例えばカーソルでファイルを幾つかマークした後、
;;          そのファイル群に対して chown をかけることなどができます。
;;
;;      ディレクトリショートカット
;;
;;          ディレクトリに d: などの別名を付けて操作できます。フロッピー
;;          ドライブも、a: と云うディレクトリでシミュレートできてる。
;;          ファイルのコピー先に、a: と指定するだけでよい。
;;
;;      正規表現ファイル選択
;;
;;          正規表現を用いてタグを付け、一括操作できます。たとえば、
;;          A か B で始まって、数字で終わるファイルを一括コピーなんて
;;          ことが出来るのです。すごいでしょ。誰が使うんだろうね。
;;
;;      日本語によるファイル名が自由自在
;;
;;          使い熟れた入力メソッドで、日本語ファイル名を入力出来る。
;;          windows の SJIS に対応は止めました。VFAT の日本語化カーネ
;;          ルパッチを使いましょう。
;;
;;      フロッピーが簡単に扱える
;;
;;          いまだに、記憶媒体の最後の手段として存続しているフロッピー
;;          が、mtools を通して更に使いやすくなるよ。俺も MO が欲しい
;;          けど、学生の間は無理だね。(学生じゃなくなったので買った)
;;
;;      find と grep と ps と netscape をリンクしてる
;;
;;          find したファイルを選択して編集したり、grep してからマッチ
;;          した部分を閲覧したりできる。更に、マッチしたファイルにスー
;;          パータグを付けて、すべてのファイルに対して、キーボードマク
;;          ロを実行する何て事もできる。更に、awk perl 等のスクリプト
;;          をメニューに組み込むことが可能です。また、ps で、プロセス
;;          を表示して、シグナルを送ることができます。やれやれ。
;;
;;      ファイル名の一括変換
;;
;;          例えば、選択したファイルの拡張子 .back を取り除いて最初の
;;          文字を最後に移動し、更に A を B に置き換えて、拡張子 .new 
;;          をつける・・・・といった操作が簡単にできる。貴方は、ひとつ
;;          のファイルに対してのみ編集作業を行えば良い。後は Ufm がタ
;;          グファイルについて繰り返し同じ動作をしてファイル名を編集し
;;          てくれる。(キーボードマクロ使用)
;;
;;      自在なキーバインド
;;
;;          Emacs の変態的なカスタマイズ性を受け継いでいます。特定キー
;;          にシェルコマンドを割り当てたり、なんなら独自のモードをつくっ
;;          てしまってもかまいません。大変だろうけど。へへ
;;
;;      メニューによる各種カスタマイズ
;;
;;          Ufm の設定はほとんどメニューの中で行うことができます。
;;
;;      超危険 ファイル再帰検索 SED置換機能
;;
;;          プログラミングとかしてて突然変数名の一貫性の無さに気付いた
;;          とき、この機能でディレクトリの中のソースファイルの変数名を
;;          一括変換したり出来ます。正規表現だから複雑なのもオーケー。
;;          不用意に実行するとファイルがめちゃくちゃになるけど。
;;          
;;      コマンドライン引数メニュー搭載
;;          
;;          貴方はもう、GNU 式のながぁーい引数(--directory-prefix 等)
;;          を覚えなくていいのです。コマンドラインをメニューで選べます。
;;          でも、メニューの定義はしてね。
;;
;;      ネットワーク上のファイルも編集できる
;;
;;          emacs 標準の ange-ftp 機能により、ネットワーク上のファイルも
;;          あたかもローカルファイルのように操作する事が出来ます。
;;			っていっても、copy delete edit のみだけど・・・
;;
;;  ■ インストール方法
;;
;;  （１）  以下のファイルをライブラリのディレクトリにコピーしてください。
;;          C-h v load-path RET と打って表示されるディレクトリのどれかです。
;;
;;          Ic-Ufm.el               ファイルセレクタ本体(必須)
;;          Ic.el                   メニューライブラリ(必須)
;;          misc-Uz.el              わが輩のヘボヘボライブラリ(必須)
;;
;;  （２）  私の個人的マクロ集を試したいときには次のファイルを
;;          ~/.Ufm-f2.macro に名前を変えてコピーしてください。
;;          カスタマイズによっては任意の場所におくことが可能です。
;;
;;          Ufm-f2.macro
;;
;;          ( XEmacsでは日本語のfaceの表示形式が異なるので残念ながら
;;            使用できません。XEmacs が悔い改めるのを待ちましょう。 )
;;
;;  （３）  .emacs に次の行を追加して、ｆ５キーを押せば起動します。
;;
;;          (load-library "Ic-Ufm")
;;          (global-set-key [f5] 'Ufm)
;;
;;  ※色の定義について
;;
;;      Ic ライブラリの、ディフォルトの色を変更するには、Ic.el の最初
;;      の方を参考に変更して下さい。
;;
;;  ※CYGWIN を使っている場合はこんなん ~/.emacs に追加してね
;;     (リストの頭に追加するようにしないと困るよ)
;;
;;		(setq exec-path (append (list
;;			"c:/Program Files/cygwin/cygwin-b20/H-i586-cygwin32/bin/"
;;			)exec-path))
;;
;;		更に環境変数PATHにも登録してください。(find の -exec が探せるように)
;;
;;  ※トピック
;;
;;      ちなみに、こんなことやると面白いかも知れません。ミニバッファの
;;      ファイル名補完機能 TAB で Ufm が立ち上がります。SPC キーを使っ
;;      てディレクトリを移動します。
;;
;;      (define-key minibuffer-local-completion-map [tab] 'complate-filenamae)
;;
;;  ※カスタマイズについて
;;
;;      各種変数を設定することによって、幾つかのカスタマイズをすること
;;      が可能です。起動後に f2 f3 f4 f5 f12 キーで設定し C-x C-s で 
;;      ~/.Ufm-env に保存することが可能ですが、このファイルの先頭にあ
;;      る変数定義の説明を編集してしまうのも一つの手です。
;;
;;      キーバインドは、 Ufm-map に define-key です。ファンクションキー
;;      で起動される幾つかのメニューでは他のマップを使っています。カー
;;      ソル移動等の基本的な機能はライブラリ Ic のものですから、 
;;      Ic-mode-map にバインドしてください。後はソースを見るべし。
;;
;;  ※その他質問
;;
;;      質問はメールでどうぞ。って云っても出さないだろうけれど。メールっ
;;      て書くのめんどくさいんだよな。ま、来たメールには返事を書きます。
;;
;;  ■ キーバインド
;;
;;    もちろん俺の設定したキーバインドをそのまま使わなくてもいい。
;;    Ufm-map に define-key してくれれば、ＯＫ。あ、でも、ライブラリを
;;    読み込んだ後にキーバインドは変更しないと困るので Ufm-hook の中で
;;    定義しましょう。関数の名前は、ソースファイル中にコメント付きで書
;;    いてあるから参考にしてね。
;;
;;    以下、チョコっと（っていうかかなり）長いマニュアルだけれど我慢し
;;    てください。大抵の場合、? キーでヘルプが出るので、全部覚える必要
;;    は有りません。
;;
;;  ★基本ファイル操作
;;
;;      c   コピー      （複製先ディレクトリを指定）
;;      m   移動        （移動先ディレクトリを指定）
;;      M   移動        （移動先ディレクトリを指定・実体を移動した後にシンボリックリンクを残す）
;;      D   削除        （ディレクトリであろうが何であろうが、消し去ってしまう）
;;
;;          以上のコマンドは、タグファイル（スペースキーでマークを
;;          付けたファイル）に対して、一括して操作が可能です、移動・
;;          コピー先を存在しないディレクトリにすると、作成するかど
;;          うか聞いてきます。C-g で中止になります。
;;
;;          移動先のディレクトリの指定には幾つかのテクニックがあり
;;          ます。フロッピーにコピーしたいときには、ミニバッファを
;;          消去したりせずに単に a: と打鍵してください。任意のディ
;;          レクトリを簡単に入力するための機能をディレクトリショー
;;          トカットと読んでいますが、これも同様に直接 e: などと入
;;          力してくれれば大丈夫です。この登録方法は、順次説明しま
;;          す。ESC キーでディレクトリメニューから入力することもで
;;          きます。更に、TAB キーを２回押せば Ufm を再帰起動させ
;;          て入力させることもできます。
;;
;;          ディレクトリの削除に限り、UNIX では /tmp/Ufm-detele-at-云々/ 
;;          への移動にしました。このファイルは次のログインの時に削除され
;;          ます。誤って削除しちまったときに助かりますね。
;;
;;      C-x Cut     ういんどうず みたいな かんじ
;;      C-c Copy
;;      C-v Paste
;;      C-b Paste as Link   貼付けだけどリンクで貼付けます。
;;
;;          カット＆ペーストは意外にかなり便利です。
;;          普通の c m なんかよりは使う頻度は高いでしょう。
;;
;;     e   編集    ファイルを編集します。C-x C-f の履歴にも登録されます。
;;
;;          拡張子によって動作を変更することが可能です。
;;          例えば、画像ファイルは gimp とかね。
;;          F12メニューの編集コマンドにマクロ(後述)を書くことで可能。
;;
;;      v   ファイル内容の閲覧  ( テキストファイルとして閲覧します )
;;      RET ファイル内容の閲覧  ( 登録コマンドによって閲覧 )
;;
;;      f   ファイルの検索  F   前回の検索結果
;;      g   文字列の検索    G   前回の検索結果
;;
;;      a   アトリビュート変更(上下キーで選んでね)
;;      r n 名前変更(FD 派も FILMTN 派も満足なキーバインド？)
;;
;;          ファイル名変更においては、タグファイルが指定されていた
;;          場合、ひとつのファイルになされた操作と同じものが全ての
;;          ファイルに対して行われます。良く考えて実行しましょう。
;;          この動作が気に入らない人は R か N を使いましょう。
;;
;;      .   ファイル情報の更新(最新の情報に更新ですね)
;;      s   ソート方法変更
;;
;;      H   ハードリンク作成
;;      S   シンボリックリンク作成
;;
;;          リンク先のファイル名を指定してください。ただしタグファ
;;          イルを一括してリンクする場合にはリンク先のディレクトリ
;;          名を入力してください。この場合そのディレクトリの中に同
;;          じ名前でリンクされます。
;;
;;      p   圧縮    (.tar.gz  形式で圧縮する。拡張子はつけないで指定)
;;      M-p 圧縮    (.tar.bz2 形式で圧縮する。拡張子はつけないで指定)
;;      u   解凍    (lzh tgz taz Z tar.gz gz zip bz 形式のファイルの解凍)
;;
;;
;;      ]   ファイル情報の表示
;;      C-] ディスク容量の表示
;;
;;  ★挿入系コマンド
;;
;;      i       ファイルを元のバッファに挿入する
;;
;;      M-i     (タグ)絶対パス名をもとのバッファに挿入する
;;      I       (タグ)ファイル名をもとのバッファに挿入する
;;
;;      z       タグ絶対パス名の列記したものをセレクションに入れる
;;      Z       タグファイル名の列記したものをセレクションに入れる
;;      C-z     "cd ディレクトリ名" と云う文字列をセレクションに入れる
;;
;;              ところで、セレクションてのは何かというと、Ｘウインドウでマ
;;              ウスの２ボタンを押すと挿入されるものだよね。だから、C-z 押
;;              した後に kterm で２ボタンを押せば、ディレクトリが変わるっ
;;              てわけなのだ。
;;
;;  ★ヘンテコな機能
;;
;;      L       Ｌｉｓｐファイルとして読み込む。気にしないで。
;;
;;      w       html ファイルとして、netscape に表示します。
;;
;;      y       コマンドの出力結果を見る
;;      Y       出力窓をファイルにセーブする
;;
;;  ★色表示
;;
;;      日付が赤い          今日編集したって事
;;      最後が青い          実行可能
;;      ファイル名が緑      読み込み専用
;;      ファイル名が水色    ディレクトリ
;;      ファイル名が黄色    編集可能
;;
;;  ★ヘルプ
;;
;;      ?       キーバインドの一覧と、操作方法が表示されます。
;;      C-h     俺の作るプログラムに関しては、h か C-h を押せば
;;                  だいたい使い方が判るようには出来ているよ。
;;
;;  ★カーソル移動
;;
;;      left right up  down      基本カーソル移動
;;      M-d  M-f   M-e M-c
;;
;;      j                       以降の連続する文字入力を正規表現として、
;;                              マッチするファイル名に逐次ジャンプする。
;;
;;      \                       ポイントファイルがシンボリックリンクの
;;                              時に、一つ遡って移動する。
;;
;;      BS M-h                  ディレクトリを一つ上がる
;;
;;      C-right                 ファイル名表示域を広げる(- + キーを併用してください)
;;      C-left                  ファイル名表示域を狭める
;;
;;  ★ファイル閲覧
;;
;;      RET             ファイルを見たければリターンキーを押せば良い。
;;      M-j             圧縮ファイルや画像ファイルの場合には、相応の
;;                      ビュアーが起動される。この起動するものは、カ
;;                      スタマイズ可能です。特別設定をしていない場は、
;;                      ファイル内容を閲覧します。
;;                      そのなかでのキーバインドは以下の通り。
;;
;;                      C-s C-r                     文字列検索
;;                      up down left right space    スクロール
;;                      e                           そのまま編集
;;                      q                           終了
;;
;;  △拡張子対応ビュアーの設定▽
;;
;;      特定拡張子で起動するプログラムは、 Ufm-exp に以下のように
;;      設定します。
;;
;;      (setq Ufm-exp '(
;;          ("\\.gif$"         (Ufm-macro "xv %FILE"))
;;          ("\\.jpe?g$"       (Ufm-macro "xv %FILE"))
;;          ("\\.midi?$"       (Ufm-macro  ;トリッキーな設定だ
;;              (let ((TABLE '(
;;                  ("内部音源で聴く" "playmidi %FILE")
;;                  ("外部ＭＩＤＩで聴く" "playmidi -e %FILE")
;;              ))OPTION)(Ic 'TABLE 'OPTION))))
;;          ))
;;
;;      ２行目に値注目してください。.gif で終わるファイルに対する挙動が
;;      判ると思います。マクロを Ufm-macro で呼び出しています。
;;
;;      注目すべきは３行目で、これは挙動を更にメニューで選ぶように
;;      しているんです。
;;
;;      拡張子は小文字で記述してください。何故ならどれにもマッチし
;;      なかった場合には大文字に変換してもう一度サーチするからです。
;;      どれにも当てはまらなければ、閲覧になります。
;;
;;     ＜パワーユーザ向けに＞
;;
;;      独自の関数 my-func1 を用意して以下のように Ufm-macro を経由
;;      して呼び出すことが可能です。また、変数 PATH がファイル名に
;;      束縛されているので、これを引数にして単純に関数 my-func2 を
;;      呼び出すことも可能です。
;;
;;      (setq Ufm-exp '(
;;          ("\\.my1"  (Ufm-macro "%TAGS" 'my-func1 (read-from-minibuffer "なーに？ : ")))
;;          ("\\.ar$"  (my-func2 PATH))
;;          ))
;;
;;      (defun my-func1 (FILE-LIST &rest ARGS)
;;          (mapcar (function (lambda (FILE)(call-process (car ARGS) nil nil t FILE))))
;;          )
;;
;;  ★ディレクトリ指定
;;
;;      :   ディレクトリの移動  (ディレクトリショートカットも可)
;;
;;          ≪ディレクトリショートカットとは何か？≫
;;
;;          良く使用するディレクトリを特別に簡単な名前で登録しておいて
;;          入力することができる。
;;
;;          この機能は、ファイルのコピーの時など、ディレクトリを指定す
;;          る必要がある時に、ミニバッファに : を入力すると直前の、/ と
;;          : の間の文字から、登録したディレクトリを探し出して決定する機能
;;
;;          ためしに Ufm を起動した状態で、:r: と入力すると、/root に
;;          移動するはずだ。もちろんこれ等は全て簡単に変更可能。
;;          ~/.emacs 等で以下のように設定するとよい。f12 環境メニュー
;;          でも設定＆保存は可能。
;;
;;          (setq Ufm-device '(
;;              (""         .(expand-file-name "~/"))
;;              ("p"        .(expand-file-name "~/public_html/"))
;;              ("ul"       ."/usr/local/")
;;              ("ub"       ."/usr/bin/")
;;              ("etc"      ."/etc/")
;;              ))
;;
;;          ※ ただし a: はフロッピードライブに固定。
;;
;;      [   カレントディレクトリにディレクトリショートカットの別名をつける。
;;
;;      /   直前にいたディレクトリに戻る。
;;
;;      ,   ディレクトリを記憶します
;;
;;      f5  記憶したディレクトリの一覧を表示します
;;          これは、ディレクトリメニューと呼ばれ、コピーするときにミニバッファで
;;          ESC キーを押すことで起動させることもできます。
;;
;;      ※ネットワーク上のファイルの取扱
;;
;;          ftp.host.ne.jp の /pub/data/ ディレクトリを見たい場合には、
;;          「：」 を押して、次のように入力してみてください。
;;          /user-name@ftp.host.ne.jp:/pub/data/
;;          パスワードを聞いてきますので入力しましょう。
;;          ファイルのコピーや削除、編集などが出来ます。
;;
;;          但し、マクロ等でネットワーク上のファイルを使ったりは出来ません。
;;          GNU/Hurd の完成を待ちましょう。
;;
;;  ★フロッピードライブモード
;;
;;      :a:と打鍵すればフロッピードライブモードに移行できます。
;;
;;      q           おしまい
;;      .           再検索
;;      /           ファイル名の表示
;;      return      閲覧
;;      c           コピー(マークファイル対応)
;;      D           消去(マークファイル対応)
;;      r           名前変更
;;      m           移動
;;      k           ディレクトリ作成
;;      a           アトリビュート変更
;;      l           ボリュームラベル変更
;;      F           mformat による簡易フォーマット
;;      $           superformat による物理フォーマット
;;      SPACE       マーク
;;      [f12]       ファイルコピーに関するもの
;;
;;      フロッピーへのコピーは、バックグラウンドで行われるので、終
;;      了表示が出るまで、コピー中のファイルを消してはいけません。
;;
;;      デフォルトでは、同じファイル名が有った場合に自動的にファイ
;;      ル名を変えるモードで mtools を使うけれど、以下のようにオプ
;;      ションを変更することもできます。
;;
;;          (setq Ufm-a-over-mode "-o")
;;
;;  ★圧縮ファイルモード
;;
;;      リターンキーで、tar taz tgz tar.gz の拡張子を持つものは、TAR 
;;      モードに。lzh の拡張子を持つものは、LHA モードにそれぞれ移行し
;;      ます。今後のバージョンアップではもっとサポートされているかも知
;;      れない。Ufm-tar なんかをみて誰か作ってくれても良いな。
;;
;;      だいたいのキーバインドは以下のようになっていると思うけれど、
;;      詳しくは各モードに移行して ? キーのヘルプを見てください。
;;
;;      テキスト閲覧[return]、解凍[u]、削除[d]
;;
;;  ★実行モード
;;
;;     x    コマンドラインを指定してください。実行モードに移行します
;;          コマンドラインには、マクロと同じ特殊文字展開がされます。
;;          要するに、echo %TAGS と指定すれば、タグファイル名を表示する。
;;
;;          実行モードではミニバッファへの入力がそのままプロセスの標準
;;          入力に送られます。プロセスが終了していたら、そのままメニュー
;;          を出ます。そのほかに、以下のキーバインドがなされています。
;;
;;          C-c C-d     EOF         を標準入力に送る
;;          C-c C-c     SIGINT      プロセスにユーザ割り込み Ctrl-c
;;          C-c C-k     SIGKILL     プロセスを殺す
;;          C-c C-b     SIGQUIT     プロセスを終了 Ctrl-\
;;          C-c C-z     SIGSTP      プロセスを一時停止
;;          C-c C-x     SIGCONT     プロセスの再開
;;          C-c C-h     SIGHUP      プロセスの制御 ttyが閉じた
;;          C-c C-q     任意のシグナルを発生させる
;;          C-c C-p     プロセスはほっといて、メニューに戻る
;;
;;          gdb tclsh なんかのコマンドライン編集機能のないシェルに、履
;;          歴とか、編集の機能が使えるようにもなります。
;;
;;          この機能はマクロにおいて、%EXE を指定した場合と同じ動作です。
;;          良く使うならば、マクロに登録すると良いでしょう。
;;
;;          特別なキーバインドで、たとえば C-d で文字列、"delete" を送る
;;          ような事をすることもできます。やり方は・・・ちょっと面倒く
;;          さいな。
;;
;;  ★タグについて
;;
;;      SPC     タグをトグル
;;
;;          タグをつけると、ファイルコピーなどの操作の対象が複数になり
;;          ます。いっぺんに削除したいときなんかにいいでしょう。タグし
;;          たファイルは、色が変わって分かります。タグを消したいときは、
;;          もう一度スペースキーを押してください。以下、タグしたファイ
;;          ルをタグファイルと呼びます。一方、カーソル位置のファイルは、
;;          ポイントファイルと呼びます。
;;
;;      C-SPC   全てのファイルにタグをトグルする。
;;      M-SPC   全てのファイルのタグをつける。
;;      S-SPC   正規表現にマッチするファイルにタグをつける
;;              (XEmacs はこのキーバインドが使えないので、M-r)
;;      C-M-SPC パーミッションタグ
;;
;;          たとえば、d.wx と入力すれば、書き込み権のあるディレクトリ
;;          全てにタグを付けることができます。
;;
;;      TAB         スーパータグトグル
;;      C-TAB       スーパータグ全部消去
;;      M-TAB f4    スーパータグメニュー
;;
;;          通常のタグは、同一ディレクトリでなくてはつけられず、ファイ
;;          ルの再検索をすると消えてしまうけれどスーパータグは異なるディ
;;          レクトリ間でもつけられるし、再検索をしても消えない。ファイ
;;          ルセレクタを終了した後でもまだ有効です。次の Emacs 立ち上
;;          げの時に復帰することもできます。
;;
;;  ★スーパータグメニュー
;;
;;      find grep 結果や編集したいファイルを登録しておき、一括編集や 
;;      文字列検索(grep)や、一括キーボードマクロ実行等が出来ます。さら
;;      に、スーパータグ自体を保存箱[f5]にいくつも保存しておく事が出来
;;      ます。なんて素晴らしいんでしょう！！こんなややこしい使い方を誰
;;      が実際にやるのでしょう！！
;;
;;          f4 TAB  登録
;;          d BS    消去
;;          C-TAB   全て消去
;;          f5      保存箱を開く
;;
;;          e       編集
;;          E       一括編集
;;          g       一括grep
;;          C-f1    最後に実行したキーボードマクロを全てのファイルに対して実行(★便利)
;;          return  閲覧
;;
;;  ★grep find モード
;;
;;      g       タグファイルについて、文字列を検索します。
;;
;;      G       前回の文字列検索結果を再表示します。
;;
;;      f       ディレクトリについて、ファイルを検索します。
;;
;;      F       前回のファイル検索結果を再表示します。
;;
;;          外部コマンド grep find の結果をメニュー形式で表示し、編集
;;          などを可能にします。grep find モードで使えるコマンドは以下
;;          の通り。
;;          
;;          TAB         そのファイルにスーパータグを付けます。
;;          M-TAB       全ての検索結果ファイルにスーパータグを付けます。
;;          C-TAB       項目を全て消去
;;          RET         そのファイルを閲覧します。(ディレクトリの場合はそこへ移動)
;;          e           そのファイルを編集します。
;;          \           その場所へ移動
;;
;;          検索自体はバックグラウンドで行われます。結果が出来次第表示しますが、Ufm が
;;          起動していなかった場合は、再帰島後 G キーを押してください。
;;
;;      C-f     なまず全文検索を実行する。
;;
;;          netscape を立ち上げといて下さい。ディレクトリには 
;;          mknmz /dir で作成したインデックスが必要です。全文検索
;;          の結果を netscape に表示させます。wget したファイルの
;;          検索に便利です。
;;
;;  ★表示されないファイル名について
;;
;;      @       ドットファイル      の表示トグル
;;      C-@     みえないファイル    の表示トグル
;;
;;      "見えないファイル"とは、Ufm 独自に正規表現で指定した、表示しない
;;      ファイルのことです。たとえば、"\\.o$"と書けば、Ｃ言語のオブジェ
;;      クトファイルが表示されなくなり、色々と便利でしょ。
;;
;;  ★みえるモードについて
;;
;;      V   みえるモードのトグル
;;
;;          カーソルの内容を逐次、別ウインドウに、表示してみせることができます。
;;          prior next          表示をスクロールできます。
;;          C-s C-r             検索です。
;;          Shift + 移動キー    表示を更新しないでカーソルを、すばやく移動できます。
;;
;;          DOS にも MIEL なんてあったよなぁうんうん
;;
;;          さらに、ファイルの情報をかえすモードなどがあります。
;;
;;          ・かるーいみえーるモードは head -40 コマンドで最初の 40 行を高速表示します
;;          ・ファイル情報の表示
;;          ・ディレクトリの使用サイズか、ファイルの行数の表示
;;          ・バイナリ表示
;;
;;
;;  ★環境設定
;;
;;      [f12]   環境設定システムメニュー起動
;;
;;          環境とは以下の設定のことです。保持する変数を付記します。
;;
;;          ディレクトリリスト                  Ufm-dir-list
;;          ディレクトリショートカット          Ufm-device
;;          拡張子で起動するもの                Ufm-exp
;;          編集で起動するもの                  Ufm-exp
;;          解凍で起動するもの                  Ufm-exp
;;          表示しないファイル名のパターン      Ufm-notview
;;          隠しファイルを表示するかどうか      Ufm-hide
;;          スーパータグ                        Ufm-super-mark
;;          スーパータグ保存箱                  Ufm-stag-table
;;          ファイル名表示長さ                  Ufm-filength
;;
;;          これ等の設定は、.emacs に書き込むことで設定できますが、
;;          Ufm は簡単に環境を編集できるように環境ファイルというも
;;          のを作って起動したときに読み込みます。
;;
;;          セーブするファイル名を Ufm-env-file に ~/.emacs に設定
;;          してください。以下の値はディフォルトです。
;;
;;          (setq Ufm-env-file "~/.Ufm-env")
;;
;;          環境は環境設定システムメニュー f12 で変更可能です。こ
;;          のメニュー上で C-x C-s を入力することでセーブできます。
;;
;;          注意してほしいのは、ショートカットや拡張子実行の
;;          設定を、.emacs 等で以下のように設定していたとしても、
;;
;;          (setq Ufm-device 云々)
;;          (setq Ufm-exp 云々)
;;
;;          環境設定ファイルがあると、そちらを優先してしまうことで
;;          す。~/.emacs などできちんと定義しておきたいというひと
;;          は、以下のように Ufm-env-no-read を設定すると、環境ファ
;;          イルがあっても .emacs での設定を優先するようにします。
;;          また、Ufm-env-part-read を設定すると、Ufm-device
;;          Ufm-exp の設定以外を環境ファイルから読み込むようにしま
;;          す。
;;
;;          (setq Ufm-env-no-read t)
;;          (setq Ufm-device 云々)
;;          (setq Ufm-exp 云々)
;;
;;  ★[f3] 関数実行メニュー
;;
;;      いちいち、機能を覚えてるのはめんどくさいので、ここに登録しておきます。
;;
;;      非常に危険なファイル操作関数も入ってます。
;;
;;          SED 文字列置換 （s/regexp/replace/g）
;;          SED コマンド実行
;;          KCC 文字コード変換
;;
;;      これらは、十分動作確認した後で使ってください。バグがある可能性はかなりあります。
;;
;;
;;  ■ マクロ機能について(チョット長いけど我慢してね)
;;
;;  ★  F2  マクロメニュー起動
;;
;;      マクロとは、ポイントファイルや、タグファイルに対してある種
;;      の操作をすることです。マクロは自分で登録したりできます。あ
;;      る種のコマンドって何だよって？たとえば、カーソル位置のファ
;;      イルを引数にして chmod filename などのコマンドを生成するこ
;;      とができるわけです。
;;
;;      とりあえず　F2 で起動したら、F1 F2 F3 キーを覚えましょう。
;;
;;      F1      項目追加
;;      C-F1    項目削除
;;      F2      表題登録
;;      F3      マクロ登録(簡単に説明が出るから参考にしてね)
;;      F4      解説文字列の指定
;;      F6      下位ノート登録  (Ctrl + 左右 キーでノードの降下)
;;      insert  位置入れ替え用スタックに PUSH
;;      delete  位置入れ替え用スタックから POP
;;      C-h     ヘルプ
;;
;;  ★  この機能は、FM-Towns 時代にお世話になった FILMTN にヒント
;;      を得ました。はじめて使う方は、とりあえず以下のように順番に
;;      打ち込んでみてください。だいたいの動作が判るでしょう。
;;
;;      まず Ufm を起動しましょう
;;      F2      マクロメニューが起動
;;      F1      新しく生成した項目に移動しよう
;;      F3      ためしに file %TAGS %nと入れてみよう  <項目完成>
;;      F2      何でもいいから題名の文字を入れる    <表題完成>
;;      q       いったんマクロメニューを終了
;;      SPC     空白キーを沢山押して赤いファイルをいっぱい指定して
;;      再度Ｕｆｍを起動します
;;      F2      マクロメニューがまたまた登場
;;      RET     新しくつくった項目に対して、リターンキーを押そう
;;
;;      結果 :  ファイルの内容情報が表示されたんじゃないかな。
;;
;;      a2ps %INPUTS{option ? } %FILE > %INPUT{filename ? }
;;
;;      なんて書けば、ミニバッファでオプションと出力先ファイル名を
;;      聞いてテキストをＰＳファイルにコンバートするなんて事ができ
;;      ます。
;;
;;  ★  マクロの書き方。
;;
;;      マクロには２つの形式があります。
;;
;;      F3 キーで入力できるのが、これから説明する文字列マクロで、
;;      簡易かつ直感的にコマンドラインを定義できます。
;;
;;      F5 キーで入力できるものは、入力が煩雑ですが、引数を選択す
;;      るメニューを定義できるより高度なリストマクロです。
;;
;;      では、早速文字列マクロについて説明します。例をあげましょう。
;;
;;      echo %TAGS > %IFILE{File name : }
;;
;;      これは言わずと知れた、echo コマンドですね。リダイレクトの 
;;      > も見えます。文字列マクロには、特殊記述子という % で始ま
;;      る文字列を含める事ができます。
;;
;;      %TAGS は実行の時にスペースキーでマークを付けられたファイル
;;      （タグファイルと呼ぶ）に置き換わります。
;;
;;      %IFILE{File name : }は、ファイル名の入力を求める特殊記述子
;;      です。特殊記述子の直後にある{} は、引数を表しています。こ
;;      の場合には、入力を促す時にミニバッファに表示する文字列を指
;;      定しています。
;;  
;;  
;;      記述子は２つ以上連結させる事が出来ます。%f%i{拡張子 : } と
;;      すれば、ファイル名に拡張子を入力して連結出来ます。
;;  
;;      さて、この調子で次のような記述子を書くことが出来ます。
;;      後はサンプルマクロを参考にして下さい。２通り書けます。
;;
;;  ▼ファイル記述子
;;
;;      %f      %FILE       カーソル位置のファイル名
;;      %pf     %PFILE      カーソル位置の絶対パス名
;;      %t      %TAG        タグファイル名           一つずつ代入(コマンドを繰り返す)
;;      %pt     %PTAG       タグ絶対パス名           一つずつ代入(コマンドを繰り返す)
;;      %st     %STAG       スーパータグ絶対パス名   一つずつ代入(コマンドを繰り返す)
;;      %ts     %TAGS       タグファイル名           空白で区切って一括代入
;;      %pts    %PTAGS      タグ絶対パス名           空白で区切って一括代入
;;      %sts    %STAGS      スーパータグ絶対パス名   空白で区切って一括代入
;;      %d      %DIR        現在のディレクトリ名
;;              %SEL        セレクションを代入します(これはファイルじゃないけど)
;;
;;      これらの記述子には引数を1つ付ける事ができます。
;;
;;      例：%FILE{2}        ==> 拡張子を２つ消去する
;;
;;  ▼入力記述子
;;
;;      %if     %IFILE      ファイル名の入力
;;      %if+    %IFILE+     ファイル名の入力(存在するファイル名)
;;      %if-    %IFILE-     ファイル名の入力(存在しないファイル名)
;;      %id     %IDIR       ファイル名の入力(存在するディレクトリ名)
;;          
;;      %i      %INPUT      汎用入力
;;      %is     %INPUTS     汎用入力２   空白は引数の区切りと見なして引数自体に含めない
;;      %ti     %TINPUT     汎用入力     (繰り返しごとに新しい入力を促す)
;;      %tis    %TINPUTS    汎用入力２   (繰り返しごとに新しい入力を促す)
;;          
;;          これらの記述子には引数を3つ付ける事ができます。
;;
;;          例 : %IFILE{プロンプト}{初期値}{履歴変数名}     ==> {引数} は省略可能
;;          
;;          入力された文字列は、通常クォートされた状態でコマンドラ
;;          インに展開されますが、次のようにすることによって、クォー
;;          トさせないように出来ます。
;;          
;;          例 : %INPUTR ==> 最後に R をつけると 入力 $SHELL は /bin/sh などに変換される。
;;          
;;  ▼制御記述子
;;
;;      これらは、プロセスの実行方法について制御します。制御記
;;      述子はコマンドラインのどこに現れてもかまいません。
;;
;;      %c      %COM        シェルを使わない(リダイレクトや環境変数の記号は意味を無くす)
;;      %e      %EXE        標準入力を与えるモードに移行する
;;      %v      %VIEW       実行後、出力内容をみる
;;      %n      %NO         実行後、マクロメニューを出ない（出力内容を見るにはこれを指定する）
;;          
;;      %SAVE{filename}     filename で表わされるファイルに結果を保存する
;;      %TSAVE{exp}         タグファイルのそれぞれの結果をタグファイル名に
;;                                  拡張子 exp を追加した形で保存する。
;;          
;;  ▼その他
;;
;;      %ARG                スクリプト引数 (スクリプトの設定は f5 で行う。後述)
;;      %ARGT               %ARG と違いスクリプトが /tmp にコピーされそのファイル名が埋め込まれる
;;      %LIST{(exec)}       リストを実行して結果を埋め込む  例 : %LIST{(directory-files \"/\")}
;;                          引数が数値の場合は、メニューを組み込む。後述。
;;      %{云々}             記述子自体を埋め込む（%COM 自体を引数に取りたい場合に）
;;
;;  ★  Perl のスクリプトをマクロに埋め込む方法
;;
;;      F1 で項目を作ったら F5 を押してください。
;;      while(<>){print;} などをためしに入力した後 C-x C-s で終了
;;      後は適当なファイルをタグファイルにして実行すればＯＫ
;;
;;      F3 でマクロの中身を覗いてみれば分かるでしょう。%ARG がスク
;;      リプト文字列を保持しています。スクリプト自体はマクロの内部
;;      に格納されています。これを編集するには F5 を押してください。
;;
;;      perl -e %ARG %TAG が自動的に登録されているが、これを編集し
;;      て sed awk tcl ruby 等のスクリプトを登録することもできます。
;;
;;      例：
;;      gawk -W source=%ARG %TAG
;;      gawk -f %ARGT %TAG
;;      sed -e %ARG %TAG
;;      sed -f %ARGT %TAG
;;
;;  ★  リストマクロ
;;
;;      文字列のみによるマクロはそれはそれで直感的でいいのですが、
;;      リストマクロではメニューの定義が出来ます。
;;
;;      F3 で入力する文字列マクロの所には %LIST{0} と書いてくださ
;;      い。そして、F5 キーでリストマクロを入力します。
;;
;;      具体的には、拙作サンプルマクロの wget の項をF5 F3 でのぞい
;;      てみて下さい。メニューを使うぶんには、全く難しい事はありま
;;      せん。作るのがすこし面倒なだけです。それでも、独自インター
;;      フェイスを作るよりは圧倒的に簡単なはずです。
;;
;;  ▼リストマクロの書き方
;;
;;     全体を()で囲み、中には次の「文字列」「記述子」「メニュー項目」を
;;     含める事が出来ます。
;;     コメントは；以降行末までです。
;;
;;     例）以下の文章をF5で入力し、F3 では%LIST{0}と入力して下さい。
;;
;;      (
;;      "echo"
;;      view
;;      (tags "pre." ".sfx" 2)      ; 文字列マクロ pre.%TAGS{2}.sfx とおんなじ
;;      ("選択してね" ("説明文章") ("その１" (input "Prompt : "))("その２" (file)))
;;      )
;;
;;  ▼文字列
;;
;;      "echo"                                  
;;      これはそのままコマンドラインに挿入されます。
;;      メニューには現れません。
;;
;;  ▼記述子
;;
;;      view
;;
;;      これはコマンドの実行環境を制御します。
;;      メニューには現れません。
;;
;;      (file "pre." ".sfx" 2)
;;
;;      選択ファイルをその位置に挿入します。
;;      メニューには現れません。
;;      記述子には入力記述子とファイル記述子と制御記述子が存在し、
;;      その機能は文字列マクロと同じです。
;;
;;  ▼メニュー項目
;;
;;      ("選択してね" ("説明文章") ("その１" (input "Prompt : " "init"))("その２" (file)))
;;
;;      メニューに、「選択してね その１ その２」と表示され、選択した記
;;      述子がコマンドラインに挿入されます。この例では、「その１」を選
;;      択した場合入力した文字列が、「その２」を選択した場合ポイントファ
;;      イル名が挿入されます。
;;
;;  ▼ファイル記述子
;;
;;      ファイル記述子は、カーソル位置のファイルや選択したファイルをコ
;;      マンドラインのその位置に挿入させる事が出来ます。
;;
;;      file    カーソル位置のファイル名
;;      pfile   カーソル位置の絶対パス名
;;      tag     タグファイル名
;;      ptag    タグ絶対パス名
;;      stag    スーパータグ絶対パス名
;;      tags    タグファイル名
;;      ptags   タグ絶対パス名
;;      stags   スーパータグ絶対パス名
;;      dir     現在のディレクトリ名
;;
;;      複雑な事をしようと思えば、次のように書くことも出来ます。
;;
;;      (file "prefix." ".suffix" 3)
;;
;;      これは、拡張子を３つ削除して、ファイル名の頭に prefix 
;;      を追加し、お尻に 拡張子".suffix" を追加します。file 以
;;      外のシンボルでも使えます。
;;
;;  ▼入力記述子
;;
;;      (input "Prompt : " "init" "prefix" "suffix" history-var)
;;
;;      だいたい見て解ると思うけれど、ユーザーの入力を促してコマンドラ
;;      インに挿入します。
;;
;;      最初の input には次のようなものを指定できます。
;;
;;      if 又は ifile      ファイル名の入力
;;      if+     ifile+     存在するファイル名の入力
;;      if-     ifile-     存在しないファイル名の入力
;;      id      idir       存在するディレクトリ名の入力
;;
;;      i       input      汎用入力
;;      is      inputs     汎用入力２   空白は引数の区切りと見なして引数自体に含めない
;;      ti      tinput     汎用入力     (繰り返しごとに新しい入力を促す)
;;      tis     tinputs    汎用入力２   (繰り返しごとに新しい入力を促す)
;;
;;      続くオプションは省略可能ですけど一応説明すると、
;;
;;      Prompt : は、ユーザーの入力するミニバッファに表示する文字列
;;      init     は、初期値
;;      prefix   は、入力した文字列の頭に追加される文字列( --file= など)
;;      suffix   は、入力した文字列の尻に追加される文字列( 拡張子など  )
;;      history-var は、ユーザー入力の履歴を記録する任意の変数名
;;
;;
;;  ▼制御記述子
;;
;;      s      shell      シェルを使用する  （ディフォルト）
;;      c      com        シェルを使わない
;;
;;          マクロによって生成されたコマンドラインは、通常シェルを
;;          使って実行されます。よって、リダイレクトの > でも、キ
;;          チンと動作します。もし、この動作が気に入らない場合には、
;;          com シンボルを指定します。この場合 > は単に文字列の > 
;;          を表すようになります。
;;
;;      e      exe        標準入力を与えるモードに移行する
;;
;;          通常、マクロはコマンドラインに展開された後、Ufm はバッ
;;          クグラウンドで実行します。しかし、標準入力を与えたい場
;;          合には、exe シンボルを指定してください。
;;
;;      v      view     実行後、出力内容をみる
;;      n      no       実行後、マクロメニューを出ない
;;      ds     disp     終了表示を通常バッファに出すようにする
;;
;;      bg              Ufm を終了しても実行を続ける(盲点かも)
;;                      name バッファに出力が送られる(name が 空白一つならば出力は捨てられる)
;;      (save "filename")   filename で表わされるファイルに結果を保存する
;;      (tsave ".exp")      タグファイルの連続実行の際にそれぞれの結果をタグファイル名に
;;                          拡張子 exp を追加した形で保存する。                         
;;
;;      debug               実行ごとに呼び出し引数を表示してしまうぞ
;;
;;  ▼その他の記述子
;;
;;      (arg  1 "pre" "suf") スクリプト引数 (スクリプトの設定は f5 で行う)
;;      (argt 1 "pre" "suf") %ARG と違いスクリプトが /tmp にコピーされそのファイル名が埋め込まれる
;;      (list (exec))        リストを実行して結果を埋め込む (例 : %LIST%(directory-files \"/\")%)
;;                           引数が数値の場合は、メニューを組み込む
;;
;;  ★  実は、マクロメニューは幾つも作ることができます。以下の例を参
;;      考にしてください。
;;
;;          (define-key Ufm-map [f9] (lambda ()
;;              (Ufm-macro-menu
;;                  "~/.Ufm-f9.macro" 'Ufm-f9-table)))
;;
;;      ディフォルトメニューは、変数 Ufm-f2-file に示されるファイ
;;      ル名にセーブされるます。私のサンプルメニューを試したければ、 
;;      Ufm-f2.macro を持ってきて、以下のように設定してください。
;;
;;      (setq Ufm-f2-file "~/Ufm-f2.macro")
;;
;;  ★独り言
;;
;;      Ic を再帰して使うときには、Ic-IDX が変わるので、その前に 
;;      Ufm-IDX に待避しないと(Ufm-name)等が正常な値を返さない。気をつ
;;      けよう。
;;
;;      打倒 fd_clone を目指していたのに、貴奴は FDclone2 なんてのを作
;;      ろうと目指しており、独自シェルだとかなんだか凄く強力そうなので、
;;      困るなぁ。
;;
;;      <空いているキーバインド>
;;
;;      ^
;;      0-9
;;      b
;;      d
;;      ;
;;
;;      <課題>
;;
;;      3 ) lpq モード
;;      5 ) dpkg/rpm モード
;;      6 ) 引数メニューの階層化
;;      7 ) 引数メニューに排他項目作成
;;      8 ) 引数メニューの前回結果の保存(文字列マクロは文字列で登録してっから難しいかもねぇ)
;;      9 ) っていうか、動作テスト・・・
;;      10 ) hide 関連の整合性
;;
;;

;;; Code:
(require 'Ic)
(require 'misc-Uz)

;;--------------------------------------------------------------------------------
;;●カスタマイズ用変数
;;
;;	※	ここに書かれている内容は、defvar を setq に変えて、 ~/.emacs に記述することで、
;;		自由にディフォルトを変更することが可能です。
;;
;;
(defvar Ufm-env-file "~/.Ufm-env")                              ; 環境保存ファイル
(defvar Ufm-f2-file "~/.Ufm-f2.macro")                          ; 標準マクロファイル

(defvar Ufm-notview-def '("\\.o$" "\\.elc$"))					; 表示しないファイル名デフォルト
(defvar Ufm-notview Ufm-notview-def)                            ; 表示しないファイル名の正規表尾現
(defvar Ufm-filength 20)                                        ; ファイル名の表示長さ
(defvar Ufm-hook nil)											; 環境ファイルを読み込んだ後に実行するフック
(defvar Ufm-namazu-dir nil)										; なまず全文検索のインデックスが入っているディレクトリを指定する(デフォルトはカレントディレクトリ)
(defvar Ufm-quit-key "q")										; サブメニューの終了キー

;●ディレクトリショートカット
(defvar Ufm-device '(
    (""         .(expand-file-name "~/"))
    ("p"        .(expand-file-name "~/public_html/"))
    ("d"        ."/msdos")
    ("q"        ."/cdrom/")
    ("u"        ."/usr/")
    ("r"        ."/root/")
    ("ul"       ."/usr/local/")
    ("ub"       ."/usr/bin/")
    ("etc"      ."/etc/")
    ))

;●拡張子実行コマンド(関数実行時にシンボルPATHがファイル名であることはを保証されている)
;
(defvar Ufm-exp '(	;(正規表現 閲覧コマンド[ret] 編集コマンド[e] 解凍コマンド[u])
    ("\\.[0-9]$"       (Ufm-manpage PATH))
    ("\\.png$"         (Ufm-macro "display %FILE")(Ufm-macro "gimp %FILE"))		; xv なんて使わない
    ("\\.gif$"         (Ufm-macro "display %FILE")(Ufm-macro "gimp %FILE"))		; gif なんて使っちゃだめ
    ("\\.jpe?g$"       (Ufm-macro "display %FILE")(Ufm-macro "gimp %FILE"))
    ("\\.tiff?$"       (Ufm-macro "display %FILE")(Ufm-macro "gimp %FILE"))
    ("\\.tga$"         (Ufm-macro "display %FILE")(Ufm-macro "gimp %FILE"))
    ("\\.bmp$"         (Ufm-macro "display %FILE")(Ufm-macro "gimp %FILE"))
    ("\\.ps$"          (Ufm-macro "gs %FILE %EXE"))
    ("\\.pdf$"         (Ufm-macro "gs %FILE %EXE"))

    ("\\.nes$"         (Ufm-macro "ines -sound %FILE"))				; ファミリーコンピュータでノスタルジーに浸る
    ("\\.smc"          (Ufm-macro "snes9x -y %FILE"))				; スーファミで無駄に人生を消費する
    ("\\.sfc"          (Ufm-macro "snes9x -y %FILE"))				;
    ("\\.v64"          (Ufm-macro "TrueReality %FILE"))				; ん？
    ("\\.z64"          (Ufm-macro "TrueReality %FILE"))				;
	("\\.exe$"         (Ufm-macro "wine %pf"))						; へっ
    ("\\.class$"       (Ufm-macro "java %FILE"))					; じゃわ実行

    ("\\.au$"          (Ufm-macro "cat %f > /dev/audio"))			; by KDDI
	("\\.avi$"         (Ufm-macro "xanim -Ae %FILE"))				; 「うごくざんす」を知っている人はいるかな？？
	("\\.mod$"         (Ufm-macro "xgmod %FILE"))
    ("\\.midi?$"       (Ufm-macro "timidity %FILE"))
    ("\\.mp3$"         (Ufm-macro "mp3blaster %f"))					; いつのまにか非アングラ

	;圧縮ファイル群
    ("\\.tar\\.Z$"     (Ufm-tar-mode PATH)nil	(Ufm-macro "tar xvfz %FILE -C %IDIR{解凍先ディレクトリ名 : }"))
    ("\\.tar\\.gz$"    (Ufm-tar-mode PATH)nil	(Ufm-macro "tar xvfz %FILE -C %IDIR{解凍先ディレクトリ名 : }"))
    ("\\.tgz$"         (Ufm-tar-mode PATH)nil	(Ufm-macro "tar xvfz %FILE -C %IDIR{解凍先ディレクトリ名 : }"))
    ("\\.taz$"         (Ufm-tar-mode PATH)nil	(Ufm-macro "tar xvfz %FILE -C %IDIR{解凍先ディレクトリ名 : }"))
    ("\\.tar\\.bz2$"    (Ufm-tar-mode PATH)nil	(Ufm-macro "tar xvfI %FILE -C %IDIR{解凍先ディレクトリ名 : }"))
    ("\\.tar$"         (Ufm-tar-mode PATH)nil	(Ufm-macro "tar xvf  %FILE -C %IDIR{解凍先ディレクトリ名 : }"))
    ("\\.lzh$"         (Ufm-lha-mode PATH)nil	(Ufm-macro "lha xw=%IDIR{解凍先ディレクトリ名 : } %FILE"))
    ("\\.gz$"          (Ufm-do-gz PATH)nil		(Ufm-macro "gzip -d %FILE"))
    ("\\.Z$"           (Ufm-do-gz PATH)nil		(Ufm-macro "gzip -d %FILE"))
    ("\\.zip$"         (Ufm-zip-mode PATH) nil					(Ufm-macro "unzip %FILE -d  %IDIR{解凍先ディレクトリ名 : }"))
    ("\\.bz2$"         nil nil					(Ufm-macro "bzip2 -d %FILE"))
    ("\\.a$"           nil nil					(Ufm-macro "ar x %FILE"))
    ("\\.deb$"         nil nil					(Ufm-macro "ar x %FILE"))
    ))

;-------------------------------------------------------------------------------------------------
;;●キーバインド
(defvar Ufm-map (make-keymap))

(defun U-no-menubar-keymap()
	(let ((a (make-keymap)))
	(define-key a [menu-bar files]		'undefined)		;global-map の定義を上書きする
	(define-key a [menu-bar tools]		'undefined)
	(define-key a [menu-bar edit]		'undefined)
	(define-key a [menu-bar search]		'undefined)
	(define-key a [menu-bar help-menu]	'undefined)
	(define-key a [menu-bar options]	'undefined)
	(define-key a [menu-bar buffer]		'undefined)
	(define-key a [menu-bar mule]		'undefined)
	a))

;for XEmacs
(if (string-match "XEmacs" (version))(progn
	(define-key Ufm-map "\M-r"										'Ufm-mark-regexp                )   ; 正規表現タグ
    )
	(define-key Ufm-map [(shift ?\ )]								'Ufm-mark-regexp                )   ; 正規表現タグ
    )

;一般
(define-key Ufm-map Ic-return-key                                   'Ufm-return                     )   ; 閲覧
(define-key Ufm-map [13]											'Ufm-return                     )   ; 閲覧
;(define-key Ufm-map [RET]											'Ufm-return                     )   ; 閲覧 ;comment out for xemacs
(define-key Ufm-map [return]										'Ufm-return                     )   ; 閲覧
(define-key Ufm-map [menu-bar file ret]								'Ufm-return                     )   ; 閲覧
(define-key Ufm-map [(control left)]                                'Ufm-dec-filength               )   ; ファイル名表示部分を小さくする
(define-key Ufm-map [(control right)]                               'Ufm-inc-filength               )   ; ファイル名表示部分を大きくする
(define-key Ufm-map [f10]                                           'Ufm-env-save                   )   ; 環境セーブ
(define-key Ufm-map [(meta m)]                                      'Ufm-return                     )   ; 閲覧
(define-key Ufm-map [f1]                                            'Ufm-help                       )   ; ヘルプ
(define-key Ufm-map "?"                                             'Ufm-help                       )   ; ヘルプ
(define-key Ufm-map "\C-h"                                          'Ufm-help                       )   ; ヘルプ
(define-key Ufm-map [menu-bar help]                                 'Ufm-help                       )   ; ヘルプ
(define-key Ufm-map [backspace]                                     'Ufm-up                         )   ; ディレクトリを上がる
(define-key Ufm-map [127]											'Ufm-up							)   ; ディレクトリを上がる
(define-key Ufm-map [(meta u)]                                      'Ufm-up                         )   ; ディレクトリを上がる
(define-key Ufm-map [menu-bar up]                                   'Ufm-up                         )   ; ディレクトリを上がる
(define-key Ufm-map [f2]											'Ufm-f2-menu					)   ; マクロメニュー
(define-key Ufm-map [menu-bar f2]									'Ufm-f2-menu					)   ; マクロメニュー
(define-key Ufm-map [f3]                                            'Ufm-H-select                   )   ; 関数実行
(define-key Ufm-map [menu-bar env f3]                               'Ufm-H-select                   )   ; 関数実行
(define-key Ufm-map [f12]                                           'Ufm-env                        )   ; 環境設定システムメニュー
(define-key Ufm-map [menu-bar env env]								'Ufm-env                        )   ; 環境設定システムメニュー
(define-key Ufm-map "V"												'Ufm-toggle-view                )   ; びゅーモード
(define-key Ufm-map "v"												'Ufm-view                       )   ; 内容を見る(拡張子に関わらずみちゃう)
(define-key Ufm-map "h" (lambda()(Ufm-macro "cat %FILE"))                                           )
(define-key Ufm-map "."												'Ufm-re-refresh                 )   ; 検索し直し
(define-key Ufm-map [menu-bar env refresh]							'Ufm-re-refresh                 )
(define-key Ufm-map "e"												'Ufm-edit                       )   ; 編集
(define-key Ufm-map [menu-bar file edit]							'Ufm-edit                       )   ; 編集
(define-key Ufm-map "B"												'Ufm-bin-edit                   )   ; バイナリ編集
(define-key Ufm-map [menu-bar file bedit]							'Ufm-bin-edit                   )   ; バイナリ編集
(define-key Ufm-map "\C-]"											'Ufm-info3                      )   ; カーソル位置情報表示
(define-key Ufm-map [menu-bar info info3]							'Ufm-info3                      )   ; カーソル位置情報表示
(define-key Ufm-map "]"												'Ufm-info                       )   ; カーソル位置情報表示
(define-key Ufm-map [menu-bar info info1]							'Ufm-info                       )   ; カーソル位置情報表示
(define-key Ufm-map "D"												'Ufm-delete                     )   ; ファイル消去
(define-key Ufm-map [menu-bar file del]								'Ufm-delete                     )
(define-key Ufm-map "q"                                             'Ufm-quit                       )   ; 終了
(define-key Ufm-map Ufm-quit-key                                    'Ufm-quit                       )   ; 終了
(define-key Ufm-map [menu-bar quit]                                 'Ufm-quit                       )   ; 終了
(define-key Ufm-map "j"                                             'Ufm-jump                       )   ; ファイル名ジャンプ
(define-key Ufm-map ":"												'Ufm-chgdir                     )   ; ディレクトリ変更
(define-key Ufm-map "l"												'Ufm-chgdir                     )   ; ディレクトリ変更
(define-key Ufm-map [menu-bar file dir]								'Ufm-chgdir                     )   ; ディレクトリ変更
(define-key Ufm-map "c"												'Ufm-copy                       )   ; ファイルコピー
(define-key Ufm-map [menu-bar file copy]							'Ufm-copy                       )
(define-key Ufm-map "M"												'Ufm-leave                      )   ; ファイル後残し移動
(define-key Ufm-map [menu-bar file leave]							'Ufm-leave                      )
(define-key Ufm-map "m"												'Ufm-move                       )   ; ファイル移動
(define-key Ufm-map [menu-bar file mv]								'Ufm-move                       )
(define-key Ufm-map "k"												'Ufm-mkdir                      )   ; ディレクトリの作成
(define-key Ufm-map [menu-bar file mkdir]							'Ufm-mkdir                      )
(define-key Ufm-map "r"												'Ufm-rename                     )   ; ファイル名前
(define-key Ufm-map "R"												'Ufm-rename2                    )   ; ファイル名前
(define-key Ufm-map "n"												'Ufm-rename                     )
(define-key Ufm-map "N"												'Ufm-rename2                    )
(define-key Ufm-map [menu-bar file ren]								'Ufm-rename                     )
(define-key Ufm-map "s"												'Ufm-sort                       )   ; ソート
(define-key Ufm-map [menu-bar env sort]								'Ufm-sort                       )   ; ソート
(define-key Ufm-map "S"												'Ufm-slink                      )   ; シンボリックリンク
(define-key Ufm-map [menu-bar file slink]							'Ufm-slink                      )   ; シンボリックリンク
(define-key Ufm-map "H"												'Ufm-hlink                      )   ; ハードリンク
(define-key Ufm-map [menu-bar file hlink]							'Ufm-hlink                      )   ; ハードリンク
(define-key Ufm-map "a"												'Ufm-attribute                  )   ; ファイル属性
(define-key Ufm-map [menu-bar file att]								'Ufm-attribute                  )
;表示窓
(define-key Ufm-map "Y"						                        'Ufm-save-win                   )   ; セーブする
(define-key Ufm-map [menu-bar env cmdsave]							'Ufm-save-win                   )   ; セーブする
(define-key Ufm-map "y"			                                    'Ufm-disp-win                   )   ; コマンド結果を表示
(define-key Ufm-map [menu-bar env cmd]								'Ufm-disp-win                   )   ; コマンド結果を表示
;圧縮
(define-key Ufm-map "p"                                             'Ufm-pack                       )   ; 圧縮 taz
(define-key Ufm-map [menu-bar pack tar]                             'Ufm-pack                       )   ; 圧縮 taz
(define-key Ufm-map "P"                                             'Ufm-pack-gz                    )   ; 圧縮
(define-key Ufm-map [menu-bar pack gz]								'Ufm-pack-gz                    )   ; 圧縮 taz
(define-key Ufm-map "\M-p"                                          'Ufm-pack-tar-bz                )   ; 圧縮 tar.bz
(define-key Ufm-map [menu-bar pack tarbz]                           'Ufm-pack-tar-bz                )   ; 圧縮 tar.bz
(define-key Ufm-map "u"                                             'Ufm-unpack                     )   ; 解凍
(define-key Ufm-map [menu-bar pack unpack]                          'Ufm-unpack                     )   ; 解凍
;拡張モード
(define-key Ufm-map "x"                                             'Ufm-exec                       )   ; 実行
(define-key Ufm-map [menu-bar misc exec]                            'Ufm-exec                       )   ; 実行
(define-key Ufm-map "\\"                                            'Ufm-go-link                    )   ; リンクをたどる
(define-key Ufm-map [menu-bar info follow]                          'Ufm-go-link                    )   ; リンクをたどる
(define-key Ufm-map "/"                                             'Ufm-go-before                  )   ; 直前のディレクトリに戻る
(define-key Ufm-map "f"                                             'Ufm-find-mode                  )   ; ファイルの検索
(define-key Ufm-map [menu-bar misc find]                            'Ufm-find-mode                  )   ; ファイルの検索
(define-key Ufm-map "\C-f"											'Ufm-namazu                     )   ; なます全文検索
(define-key Ufm-map "F"												'Ufm-refind-mode                )   ; ファイルの検索(前回の結果を見る)
(define-key Ufm-map [menu-bar misc rfind]							'Ufm-refind-mode                )   ; ファイルの検索(前回の結果を見る)
(define-key Ufm-map "g"												'Ufm-grep-mode                  )   ; 文字列の検索
(define-key Ufm-map [menu-bar misc grep]							'Ufm-grep-mode                  )   ; 文字列の検索
(define-key Ufm-map "G"												'Ufm-regrep-mode                )   ; 文字列の検索(前回の結果を見る)
(define-key Ufm-map [menu-bar misc rgrep]							'Ufm-regrep-mode                )   ; 文字列の検索(前回の結果を見る)
(define-key Ufm-map "t"												'Ufm-ps-mode                    )   ; タスク
(define-key Ufm-map [menu-bar misc ps]								'Ufm-ps-mode                    )   ; タスク
;タグ
(define-key Ufm-map [(control space)]								'Ufm-mark-toggle                )   ; 全てタグトグル
(define-key Ufm-map [(meta space)]                                  'Ufm-mark-all                   )   ; 全てにタグ
(define-key Ufm-map [(shift space)]                                 'Ufm-mark-regexp                )   ; 正規表現タグ
(define-key Ufm-map [(control meta space)]                          'Ufm-mark-regexp2               )   ; パーミッション正規表現タグ
(define-key Ufm-map " "                                             'Ufm-mark                       )   ; タグ
(define-key Ufm-map [menu-bar tag mark]								'Ufm-mark                       )
(define-key Ufm-map [(control ?\ )]									'Ufm-mark-toggle                )   ; 全てタグトグル
(define-key Ufm-map [menu-bar tag toggle]							'Ufm-mark-toggle                )
(define-key Ufm-map [(meta ?\ )]									'Ufm-mark-all                   )   ; 全てにタグ
(define-key Ufm-map [menu-bar tag all]								'Ufm-mark-all                   )
(define-key Ufm-map [menu-bar tag reg1]								'Ufm-mark-regexp                )	; ファイル名正規表現タグ
(define-key Ufm-map [(control meta ?\ )]							'Ufm-mark-regexp2               )   ; パーミッション正規表現タグ
(define-key Ufm-map [menu-bar tag reg2]								'Ufm-mark-regexp2               )
;スーパータグ
(define-key Ufm-map [tab]                                           'Ufm-super-mark                 )   ; スーパータグ
(define-key Ufm-map [menu-bar tag stag]                             'Ufm-super-mark                 )   ; スーパータグ
(define-key Ufm-map [(control tab)]                                 'Ufm-super-cls                  )   ; スーパータグぜーんぶ消去
(define-key Ufm-map [menu-bar tag sdel]                             'Ufm-super-cls                  )   ; スーパータグぜーんぶ消去
(define-key Ufm-map [(meta tab)]                                    'Ufm-super-menu                 )   ; スーパータグ操作
(define-key Ufm-map [menu-bar tag f4]                               'Ufm-super-menu                 )   ; スーパータグ操作
(define-key Ufm-map [f4]                                            'Ufm-super-menu                 )   ; スーパータグ操作
;隠し
(define-key Ufm-map "@"                                             'Ufm-H-dot                      )   ; ドットファイル表示トグル
(define-key Ufm-map [menu-bar hide dot]								'Ufm-H-dot                      )
(define-key Ufm-map "\C-@"											'Ufm-H-tog                      )   ; 隠しファイル表示トグル
(define-key Ufm-map [menu-bar hide tog]								'Ufm-H-tog                      )
(define-key Ufm-map [(meta @)]										'Ufm-H-regexp                   )   ; 隠しファイル正規表現の追加
(define-key Ufm-map [menu-bar hide regexp]							'Ufm-H-regexp                   )
;メニューからやったのがいいね
;(define-key Ufm-map "`"											'Ufm-H-init                     )   ; 隠しファイル正規表現の初期化
;(define-key Ufm-map [menu-bar Ufm-file hide init]					'Ufm-H-init                     )
;(define-key Ufm-map [(meta \`)]									'Ufm-H-edit                     )   ; 隠しファイル正規表現の編集
;(define-key Ufm-map [menu-bar Ufm-file hide toggle]				'Ufm-H-edit                     )
;(define-key Ufm-map [(control meta @)]								'Ufm-H-del                      )   ; 隠しファイル正規表現の最後の一つの削除
;(define-key Ufm-map [menu-bar Ufm-file hide del]					'Ufm-H-del                      )
;その他
(define-key Ufm-map "o"												'Ufm-od                         )   ; バイナリ表示
(define-key Ufm-map [menu-bar info od]								'Ufm-od                         )   ; バイナリ表示
(define-key Ufm-map "L"												'Ufm-load                       )   ; Ｅｌｉｓｐロード
(define-key Ufm-map [menu-bar misc lisp]							'Ufm-load                       )   ; Ｅｌｉｓｐロード
(define-key Ufm-map "["												'Ufm-short                      )   ; ディレクトリショートカット登録
(define-key Ufm-map [menu-bar tag short]							'Ufm-short                      )   ; ディレクトリショートカット登録
(define-key Ufm-map [(shift up)]									'Ufm-S-up                       )   ; 表示更新しないカーソル移動
(define-key Ufm-map [(shift down)]									'Ufm-S-down                     )
;ファイル名記録関連
(define-key Ufm-map "z"												'Ufm-pathname-selection         )   ; パス名        セレクション
(define-key Ufm-map "Z"												'Ufm-filename-selection         )   ; ファイル名    セレクション
(define-key Ufm-map "\C-z"                                          'Ufm-chdir-selection            )   ; cd /dir/      セレクション

(define-key Ufm-map "i"		                                        'Ufm-insert-file	            )   ; ファイル内容  挿入
(define-key Ufm-map [menu-bar misc ins]	                            'Ufm-insert-file	            )   ; ファイル内容  挿入
(define-key Ufm-map "\M-i"                                          'Ufm-insert-pathname            )   ; パス名        挿入
(define-key Ufm-map [menu-bar misc inspath]							'Ufm-insert-pathname            )   ; パス名        挿入
(define-key Ufm-map "I"                                             'Ufm-insert-filename            )   ; ファイル名    挿入
(define-key Ufm-map [menu-bar misc insfile]							'Ufm-insert-filename            )   ; ファイル名    挿入
;ディレクトリリスト
(define-key Ufm-map ","                                             'Ufm-dir-add                    )   ; ディレクトリリストに追加
(define-key Ufm-map [menu-bar tag dir]                              'Ufm-dir-add                    )   ; ディレクトリリストに追加
(define-key Ufm-map [f5]                                            'Ufm-dir-menu                   )   ; ディレクトリリストメニュー
(define-key Ufm-map [menu-bar tag f5]                               'Ufm-dir-menu                   )   ; ディレクトリリストメニュー
;ういんどうずらいくな作業
(define-key Ufm-map "\C-x"                                          'Ufm-w95-cut                    )   ; cut
(define-key Ufm-map "\C-c"                                          'Ufm-w95-copy                   )   ; copy
(define-key Ufm-map "\C-v"                                          'Ufm-w95-paste                  )   ; paste
(define-key Ufm-map "\C-b"                                          'Ufm-w95-link                  )   ; paste
;WWW 閲覧
(define-key Ufm-map "w"												'Ufm-www)
(define-key Ufm-map [menu-bar file www]								'Ufm-www)
(define-key Ufm-map "!"												'Ufm-author)
(define-key Ufm-map [menu-bar title]								'Ufm-author)
;マウス
(define-key Ufm-map [down-mouse-1]									'Ufm-mouse-1)
(define-key Ufm-map [double-mouse-1]								'Ufm-mouse-1)
(define-key Ufm-map [down-mouse-2]									'Ufm-mouse-2)
(define-key Ufm-map [double-mouse-2]								(lambda()))
(define-key Ufm-map [mouse-2]										(lambda()))
(define-key Ufm-map [mouse-3]										'Ufm-mouse-3)
;メニューバー
(defvar Ufm-menu-map (U-no-menubar-keymap))

(define-key Ufm-menu-map [menu-bar quit				]   '("Quit"			. Ufm-quit))
(define-key Ufm-menu-map [menu-bar help				]   '("Help"			. Ufm-help))
(define-key Ufm-menu-map [menu-bar f2				]   '("Macro"			. Ufm-f2-menu))

(define-key Ufm-menu-map [menu-bar env				]	(cons "Env" (make-sparse-keymap "env")))
(define-key Ufm-menu-map [menu-bar env refresh		]   '("Refresh"			. refresh))
(define-key Ufm-menu-map [menu-bar env cmdsave		]   '("Save Command result"		. cmdsave))
(define-key Ufm-menu-map [menu-bar env cmd			]   '("Show Command result"		. cmd))
(define-key Ufm-menu-map [menu-bar env f3			]   '("Function"			. f3))
(define-key Ufm-menu-map [menu-bar env sort			]   '("Sort"			. sort))
(define-key Ufm-menu-map [menu-bar env env			]	'("Env Edit"		. env))

(define-key Ufm-menu-map [menu-bar info				]	(cons "Info" (make-sparse-keymap "info")))
(define-key Ufm-menu-map [menu-bar info info3		]	'("Disk Space"		. info3))
(define-key Ufm-menu-map [menu-bar info follow		]	'("follow Link"		. follow))
(define-key Ufm-menu-map [menu-bar info od			]	'("Hex"		. od))
(define-key Ufm-menu-map [menu-bar info info1		]	'("Info"		. info1))

(define-key Ufm-menu-map [menu-bar pack				]	(cons "Pack" (make-sparse-keymap "pack")))
(define-key Ufm-menu-map [menu-bar pack gz			]	'("Pack[gz]"		. gz))
(define-key Ufm-menu-map [menu-bar pack tarbz		]	'("Pack[tar.bz2]"		. tarbz))
(define-key Ufm-menu-map [menu-bar pack taz			]	'("Pack[tar.gz]"		. taz))
(define-key Ufm-menu-map [menu-bar pack unpack		]	'("UnPack"				. unpack))

(define-key Ufm-menu-map [menu-bar hide				]	(cons "Hide" (make-sparse-keymap "hide")))
(define-key Ufm-menu-map [menu-bar hide regexp		]	'("ADD Regexp"		. regexp))
(define-key Ufm-menu-map [menu-bar hide tog			]	'("Regexp"		. tog))
(define-key Ufm-menu-map [menu-bar hide dot			]	'("Dot File"		. dot))

(define-key Ufm-menu-map [menu-bar tag				]   (cons "TAG" (make-sparse-keymap "tag")))
(define-key Ufm-menu-map [menu-bar tag short		]	'("Dir ShortCut"		. short))
(define-key Ufm-menu-map [menu-bar tag f5			]	'("Dir TAG Menu"		. f5))
(define-key Ufm-menu-map [menu-bar tag dir			]	'("Dir TAG"		. dir))
(define-key Ufm-menu-map [menu-bar tag f4			]	'("Super TAG Menu"		. f4))
(define-key Ufm-menu-map [menu-bar tag sdel			]	'("Super TAG Clear"		. sdel))
(define-key Ufm-menu-map [menu-bar tag stag			]	'("Super TAG"		. stag))
(define-key Ufm-menu-map [menu-bar tag reg2			]	'("dwrx Regexp"		. reg2))
(define-key Ufm-menu-map [menu-bar tag reg1			]	'("Name regexp"		. reg1))
(define-key Ufm-menu-map [menu-bar tag toggle		]	'("Toggle all"		. toggle))
(define-key Ufm-menu-map [menu-bar tag all			]	'("Mark All"		. all))
(define-key Ufm-menu-map [menu-bar tag mark			]	'("Mark"			. mark))

(define-key Ufm-menu-map [menu-bar misc				]   (cons "Misc" (make-sparse-keymap "misc")))
(define-key Ufm-menu-map [menu-bar misc lisp		]   '("load as emacs lisp"			. lisp))
(define-key Ufm-menu-map [menu-bar misc insfile		]   '("Insert File Name"			. insfile))
(define-key Ufm-menu-map [menu-bar misc inspath		]   '("Insert File Path"			. inspath))
(define-key Ufm-menu-map [menu-bar misc ins			]   '("Insert File"			. ins))
(define-key Ufm-menu-map [menu-bar misc ps			]   '("Process"			. ps))
(define-key Ufm-menu-map [menu-bar misc exec		]   '("Execute"			. exec))
(define-key Ufm-menu-map [menu-bar misc rfind		]   '("ReFind"			. rfind))
(define-key Ufm-menu-map [menu-bar misc rgrep		]   '("ReGREP"			. rgrep))
(define-key Ufm-menu-map [menu-bar misc grep		]   '("GREP"			. grep))
(define-key Ufm-menu-map [menu-bar misc find		]   '("Find"			. find))

(define-key Ufm-menu-map [menu-bar file				]   (cons "File" (make-sparse-keymap "file")))
(define-key Ufm-menu-map [menu-bar file dir			]   '("Change Dir"			. dir))
(define-key Ufm-menu-map [menu-bar file www			]   '("View in Mozilla"			. www))
(define-key Ufm-menu-map [menu-bar file view		]   '("View"			. view))
(define-key Ufm-menu-map [menu-bar file bedit		]   '("Binary Edit"		. bedit))
(define-key Ufm-menu-map [menu-bar file slink		]   '("Symbolic Link"			. slink))
(define-key Ufm-menu-map [menu-bar file hlink		]   '("Hard Link"			. hlink))
(define-key Ufm-menu-map [menu-bar file leave		]   '("Leave"			. leave))
(define-key Ufm-menu-map [menu-bar file att			]   '("Attribute"		. att))
(define-key Ufm-menu-map [menu-bar file mkdir		]   '("Make Dir"		. mkdir))
(define-key Ufm-menu-map [menu-bar file ren			]   '("ReName"			. ren))
(define-key Ufm-menu-map [menu-bar file edit		]   '("Edit"			. edit))
(define-key Ufm-menu-map [menu-bar file del			]   '("Delete"			. del))
(define-key Ufm-menu-map [menu-bar file mv			]   '("Move"			. mv))
(define-key Ufm-menu-map [menu-bar file copy		]   '("Copy"			. copy))

(define-key Ufm-menu-map [menu-bar up				]   '("UP"			. up))
(define-key Ufm-menu-map [menu-bar title			]   '("<Ufm System>"			. help))

;(define-key Ufm-menu-map [tool-bar ]   '(menu-item "Ufm-tool-bar" ignore :filter (lambda(a)Ufm-menu-map)))

;-------------------------------------------------------------------------------------------------
;●内部変数
(defvar Ufm-env-flag    nil)    ; 環境ファイルを読んだかどうか
(defvar Ufm-option '(
    (notcls-win)
    (refresh (progn
		(use-local-map Ufm-menu-map)
        ))
    (wine-mode-line ("[" Ufm-dir "]"))
    (after-exec (force-mode-line-update))
    (wink-less 34)
    (milk-cut t)
    (keymap Ufm-map)
    ))
(defvar Ufm-startup "おっは〜☆ Ufm (C) 1998 Usuda Hiroshi. Report bugs to usuda-hiroshi@fujielectric.co.jp Get new version from http://www.d4.dion.ne.jp/~usuda/emacs/Ufm.tgz")
;-------------------------------------------------------------------------------------------------
;;●Ufm 関数

(defun Ufm (&optional dir return prompt option disp)
"高性能ファイルセレクタ

C-h help

Uage:(Ufm &optional dir return prompt option disp)

dir     開始ディレクトリ名

return  返す値

    t               :タグファイル名リスト   %PTAGS
    dir             :ディレクトリ名         %DIR
    nil             :ファイル名             %FILE

    FORM            :マクロ文字列
    (COMMAND FORM)  :コマンド起動

prompt  起動時の表示文字列

option  独自のキーバインドなどを与える Ufm-completion-map 等

disp    表示ファイル名
"
    (interactive)
    (progn
	;環境ファイルの読み込み Xemacs の為にエラーはキャッチするようにした
    (condition-case nil (if (boundp 'Ufm-env-no-read)()
        (if (and (not Ufm-env-flag) (file-exists-p Ufm-env-file))
            (if (boundp 'Ufm-env-part-read)
                (let (Ufm-exp Ufm-device)(load-file Ufm-env-file)(setq Ufm-env-flag t))
                (load-file Ufm-env-file)(setq Ufm-env-flag t)))
		)(error))
    ;はじめて起動するとき
    (if (boundp 'Ufm-1st) nil
		;ユーザの設定したフックの実行
		(run-hooks 'Ufm-hook)
		; ヘルプ この処理はXEmacs の為
		(if (lookup-key Ufm-map [escape])nil(define-key Ufm-map [escape] 'Ufm-helpkey))
		(if (lookup-key Ufm-macro-map [escape])nil(define-key Ufm-macro-map [escape] 'Ufm-macro-tyoku))
		(setq Ufm-1st t)
        )
	;はじまりはじまり
    (let* (
        (Ufm-table      nil)                                                    ; テーブル
        (Ufm-save-cur   nil)                                                    ; リフレッシュ時にカーソルを置くファイル名・インデックス
        (Ufm-hide       t)                                                      ; 隠しファイル名の表示
        (Ufm-quit       return)                                                 ; 返す値( 'tag : タグファイル名 'dir : ディレクトリ名 )
        (Ufm-dir        (expand-file-name (if dir dir default-directory)))      ; カレントディレクトリ
        (Ufm-miel       nil)                                                    ; 自動見えるモード
        (Ufm-mark-list   nil)                                                   ; タグインデックス(多重呼び出しのために必要)
        (Ufm-first-dir  Ufm-dir)                                                ; Ufm-go-before と比較するために保存
        (Ufm-undisp     (if (stringp disp)(list disp)disp))                     ; 表示するファイル
		;もともと Ufm-macro-menu にあったものたち
        (Ufm-macro-file     nil)	; ファイル名
        (Ufm-macro-table    nil)	; トップテーブルシンボル
        (Ufm-IDX			nil)	; 保存(重要だ)
        (global-map			global-map)	; 保存(重要だ)
        )
    (message (if prompt prompt Ufm-startup))
    (let ((RESULT(if (window-minibuffer-p (selected-window))
        ;ミニバッファ実行
        (save-window-excursion
        (while (window-minibuffer-p (selected-window))(other-window 1))
        (delete-other-windows)
        (Ufm-refresh)
        (Ic 'Ufm-table (if option option 'Ufm-option))
        );通常実行
        (Ufm-refresh)
        (Ic 'Ufm-table (if option option 'Ufm-option))
        )))(if (symbolp (car-safe RESULT))(eval RESULT)RESULT)
    ))))

;(Ufm nil '(diff "%PTAG %PFILE"))
;(Ufm nil nil)
;(Ufm nil t)
;(Ufm nil 'dir)
;(Ufm nil "---%FILE")

;-------------------------------------------------------------------------------------------------
;● t を返せば成功を表す

(defun Ufm-C-cp(SRC DST)
	(if (eq t (car (file-attributes SRC)))
		; ange-ftp 対策（ディレクトリの時にはディレクトリごとコピーする為に外部コマンドcpを使う。）
		(eq 0 (call-process "cp" nil nil t "-R" SRC DST))
		; 
		(not (copy-file SRC (if (eq t (car (file-attributes DST)))(concat DST (cdr (file-namae SRC)))DST) t t))
		)
	)
(defun Ufm-C-mv(SRC DST)
	(eq 0 (call-process "mv" nil nil t SRC DST))
	)

(defun Ufm-C-deldir(PATH)
	(eq 0 (if (eq 'w32 window-system)
		(call-process "rm" nil nil t "-r" "-f" PATH)
		(let (tmp)
			(make-directory (setq tmp (concat "/tmp/Ufm-detele-at-" (current-time-string) "/")))
			(call-process "mv" nil nil t PATH tmp)
			)
		))
	)

;-------------------------------------------------------------------------------------------------
;;●ディレクトリ検索
;
;   カーソル位置の変更をしない時には            (setq Ufm-save-cur  Ic-IDX)
;   特定ファイル名にカーソル位置を置く時には    (setq Ufm-save-cur (Ufm-name))
;
(defvar Ufm-date (substring (current-time-string) 4 10))            ; 今日の日付

(defun Ufm-inc-filength()
    "ファイル名の表示領域を大きくする"
    (setq Ufm-filength (1+ Ufm-filength))
    (Ufm-refresh)
    )
(defun Ufm-dec-filength()
    "ファイル名の表示領域を小さくする"
    (if (> Ufm-filength 7)(setq Ufm-filength (1- Ufm-filength)))
    (Ufm-refresh)
    )

;-------------------------------------------------------------------------------
;●Ufmテーブルの構築

(defun Ufm-refresh ()
    (setq Ufm-table nil)
    (setq Ufm-mark-list nil)
    (while (not (file-exists-p Ufm-dir))
        (message (concat Ufm-dir "は、アクセス不能だよ。"))
        (setq Ufm-dir (if (equal "" Ufm-dir) "/" (car (file-namae (substring Ufm-dir 0 -1)))))
        )
    (if (eq ?\/ (elt Ufm-dir (1-(length Ufm-dir))))()(setq Ufm-dir (concat Ufm-dir "/")))       ;最後に / が無いと加える
    (setq default-directory Ufm-dir)
    (let* (
        (N 0)   ;(default-directory)のIDX
        (IDX 0) ;カーソル位置
        (LIST (directory-files Ufm-dir))
        (LEN (length LIST))
        )
    ;▼テーブルセット
    (while (< N LEN)(catch 'NEXT (let* (
            (FILE (nth N LIST))
            (DISP FILE)
            )

		;ルートは表示しない
		(if (equal "." FILE)(progn (setq N (1+ N))(throw 'NEXT t)))

        ;表示しないファイル名
        (if Ufm-hide (mapcar (lambda (a)
            (if (and
					(not (equal FILE ".."))
					;(not (equal FILE "."))
					(string-match a FILE))
                    (progn (setq N (1+ N))(throw 'NEXT t)))
            )Ufm-notview))

        ; 項目設定
        (let* (
            (ATTR (file-attributes (concat Ufm-dir DISP)))
            (-DUMMY (if ATTR ()
                (message "コード変換に失敗して表示してないファイルがあるぞ。")(ding)
                (setq N (1+ N))
                (throw 'NEXT t)))
            (SIZE (nth 7 ATTR))
            )
            ;表示するファイル名
            (mapcar (lambda (a)(if (and 
				(not (equal FILE ".."))
				;(not (equal FILE "."))
				(not (string-match a FILE))
				(not (eq (nth 0 ATTR) t))
				)
                (progn (setq N (1+ N))(throw 'NEXT t))))Ufm-undisp)

;        (if (equal FILE Ufm-save-cur)(setq Ic-IDX IDX))         ; カーソル位置設定(ソートすると位置が変わってしまうので文字列による指定は有効でない)
        (setq IDX (1+ IDX))
        (setq Ufm-table (append Ufm-table (list (append (list
            (concat                                                 ; ファイル名
            (U-expand-string DISP Ufm-filength)
            (U-expand-string (number-to-string SIZE) 7 t)           ; サイズ
            " "(substring (current-time-string  (nth 5 ATTR)) 4 10) ; 日付
            " " (substring (nth 8 ATTR) 0 4)                        ; 許可
            )
            ATTR (if Ufm-miel (list nil Ufm-miel)) nil nil FILE)
            (Ufm-color ATTR)
            ))))))
        (setq N (1+ N))))

    ;▼ソートする
	(if Ufm-sort (setq Ufm-table (sort Ufm-table Ufm-sort)))

    ;▼カーソル位置設定
	(catch 'BB (let ((N 0)(len (length Ufm-table)))(while (< N len) 
		(if (equal (nth 5 (nth N Ufm-table)) Ufm-save-cur)(progn (setq Ic-IDX N)(throw 'BB t)))
	(setq N (1+ N)))))
    (if (numberp Ufm-save-cur)(setq Ic-IDX  Ufm-save-cur))
    ))

;-------------------------------------------------------------------------------------------------
;;●色決め関数

(defun Ufm-color(ATTR)
    (let* (
    (ATT (substring (nth 8 ATTR) 0 4))
    (TYPE       (cond((eq ?d (elt ATT 0))?d)((eq (elt ATT 2) ?-)?w)(t(elt ATT 0))))
    (DAY        (equal Ufm-date (substring (current-time-string (nth 5 ATTR)) 4 10)))
    (EXE        (and (eq (elt ATT 0) ?-)(or (eq (elt ATT 3) ?s)(eq (elt ATT 3) ?x))))
    (COL1(cond
        ((eq TYPE ?d)   '(R-Blue    . C-Blue    ))  ;ディレクトリ
        ((eq TYPE ?l)   '(R-Purple  . C-Purple  ))  ;シンボリックリンク
        ((eq TYPE ?w)   '(R-Green   . C-Green   ))  ;書き込み禁止
        (t              '(R-Yellow  . C-Yellow  ))  ;通常ファイル
        ))                              ; ファイルのタイプ
    (COL2 (if DAY '(C-Blue . C-Red)))   ; 今日編集したファイル？
    (COL3 (if EXE '(C-Blue . C-Blue)))  ; 実行可能ファイル？
    )
    (list   
        (list   ;無色
        (list 0 0 Ufm-filength (car COL1))                                  ;カーソル
        (list 0 (+ 8 Ufm-filength) (+ 14 Ufm-filength)(car COL2))           ;日付
        (list 0 (+ 18 Ufm-filength)(+ 19 Ufm-filength)(car COL3)))          ;実行可能
        (list   ;カーソル
        (list 0 0 Ufm-filength (cdr COL1))
        (list 0 (+ 8 Ufm-filength) (+ 14 Ufm-filength)(cdr COL2))
        (list 0 (+ 18 Ufm-filength)(+ 19 Ufm-filength)(cdr COL3)))
        )
    ))

;あらかじめ色リストを用意しといた方が速い・・・かも
;
;(defvar Ufm-col-C1 (list   ;無色
;       (list 0 0 Ufm-filength 'C-Blue)                                  ;カーソル
;       (list 0 (+ 8 Ufm-filength) (+ 14 Ufm-filength) 'C-Blue)          ;日付
;       (list 0 (+ 18 Ufm-filength)(+ 19 Ufm-filength) 'C-Blue)          ;実行可能
;	))
;
;(defvar Ufm-col-R1 '(list  ;カーソル
;       (list 0 0 Ufm-filength 'R-Blue)
;       (list 0 (+ 8 Ufm-filength) (+ 14 Ufm-filength) 'C-Blue)
;       (list 0 (+ 18 Ufm-filength)(+ 19 Ufm-filength) 'C-Blue)
;	))
;

;-------------------------------------------------------------------------------------------------
;;●終了
;
;   返す値(over で強制変更出来る)
;
;   nil     : ポイントファイル名
;   t       : タグファイル名
;   'dir    : ディレクトリ名
;

(defun Ufm-quit (&optional over)
    "Ufm を終了する(選択ファイルを返す)"
    (if (equal Ufm-dir Ufm-first-dir)()(setq Ufm-go-before Ufm-dir))
    (if over (setq Ufm-quit over))
    (Ic-quit (cond
        ((stringp Ufm-quit) (Ufm-macro Ufm-quit t))
        ((consp Ufm-quit)   (cons (car Ufm-quit) (Ufm-macro (nth 1 Ufm-quit) t)))
        ((eq Ufm-quit 'dir) Ufm-dir)
        ((eq Ufm-quit t)    (if Ufm-super-mark Ufm-super-mark (mapcar (function (lambda (A) (Ufm-name 'dir A))) Ufm-mark-list)))
        ((eq Ufm-quit nil)  (Ufm-name 'dir))
        )
    ))
;-------------------------------------------------------------------------------------------------
;;●リターンキー

(defun Ufm-return (&optional DO)
    "ファイルの閲覧"
    (let* (
            (FILE   (Ufm-name))
            (PATH   (Ufm-name 'dir))
            (TYPE   (Ufm-fmode PATH)))
    (cond
;        ((equal "." FILE)nil)
        ((equal 'dir TYPE)
            (if (equal ".." FILE)
                (Ufm-up)
                (setq Ufm-save-cur 0)
                (setq Ufm-dir (concat PATH "/"))
                (Ufm-refresh)))
        ((not DO)       (Ufm-do-exp PATH))
    )))

(defun Ufm-do-exp (PATH)
    (catch 'BREAK
    (let ((I 0)(LEN (length Ufm-exp)))(while (< I LEN)(let ((TMP (nth I Ufm-exp)))
        (if (and (condition-case nil (string-match (car TMP) PATH)(error))(nth 1 TMP))(progn(eval (nth 1 TMP))(throw 'BREAK t)))
    (setq I (1+ I)))))
	;どれにも当てはまらなければ、大文字にしてもう一度
    (let ((I 0)(LEN (length Ufm-exp)))(while (< I LEN)(let ((TMP (nth I Ufm-exp)))
        (if (and (condition-case nil (string-match (upcase (car TMP)) PATH)(error))(nth 1 TMP))(progn(eval (nth 1 TMP))(throw 'BREAK t)))
    (setq I (1+ I)))))
	;最後は閲覧
	(Ufm-view PATH)
    ))

;-------------------------------------------------------------------------------------------------
;;●ディレクトリを上がる

(defun Ufm-up ()
    "ディレクトリを一つ上がる"
    (if (equal "/" Ufm-dir)()(if (string-match "\\(^.*/\\)\\(.*\\)/$" Ufm-dir)(progn
        (setq Ufm-save-cur      (match-string 2 Ufm-dir))
        (setq Ufm-dir           (match-string 1 Ufm-dir))
        (Ufm-refresh)
    ))))

;;●ディレクトリ変更
(defun Ufm-chgdir ()
    "ディレクトリの移動 (フロッピーは、a: と入力すればいい)"
    (let ((DIR (Ufm-dir "ディレクトリの移動 : " t t t)))
        (if (equal DIR "a:")
        ; フロッピードライブ
        (Ufm-a-mode)
        ; ディレクトリ名なら、セット
        (if DIR (progn (setq Ufm-go-before Ufm-dir)(setq Ufm-dir DIR)))
        (Ufm-refresh)
        )
    ))

;(put 'Ufm-chgdir 'enable-recursive-minibuffers t)

;;●直前のディレクトリに移動

(defvar Ufm-go-before(expand-file-name "~/"))
(defun Ufm-go-before ()
    "直前のディレクトリに戻る"
    (let ((TMP Ufm-go-before))
        (message "直前のディレクトリに移動します")
        (setq Ufm-go-before Ufm-dir)
        (setq Ufm-dir TMP)
        )
    (Ufm-refresh)
    )

;●ディレクトリ作成
(defun Ufm-mkdir ()
    "ディレクトリを作るぞ"
	(let ((DIR(read-from-minibuffer "ディレクトリ作成 ： ")))
    (make-directory-recursive DIR)
    (setq Ufm-save-cur DIR)
    (Ufm-refresh)
    ))

;-------------------------------------------------------------------------------------------------
;;●編集

(defun Ufm-edit()
    "ファイルの編集 (C-x C-f の履歴に自動登録されます)(新規ファイルは、. .. に対して実行する)"
    (if Ufm-mark-list  (let (NAME(I 0)(LEN (length Ufm-mark-list)))(while (< I LEN)
        (setq NAME (Ufm-name 'dir (nth I Ufm-mark-list)))
        (if (eq (nth 0 (file-attributes (file-truename NAME))) t)()(Ufm-edit-sub 0 0 NAME))
        (setq I (1+ I))))
    (Ufm-edit-sub 0 0)
    ))

(defun Ufm-bin-edit()
	"バイナリ編集"
	(hexl-find-file(Ufm-name 'dir))
	(setq Ic-keep-buffer (buffer-name (current-buffer)))
	(if (functionp 'Uz-Switch-enter)(Uz-Switch-enter Ic-keep-buffer))	;see simple-Ufunc
    (Ic-quit)
    )

(defun Ufm-edit-sub (start line &optional FILE)
    (let ((FILENAME (if FILE FILE(Ufm-name 'dir))))
        ;FILE がディレクトリならば
        (if (and (not FILE)(eq (nth 0 (file-attributes (file-truename FILENAME))) t))
            (setq FILENAME (read-file-name "新規編集ファイル : "
                (if ;(or (equal "." (file-name-nondirectory FILENAME))
					(equal ".." (file-name-nondirectory FILENAME))
					;)
                    (concat Ufm-dir)(concat FILENAME "/")))))
        ;そのファイルを編集する
	    (catch 'BREAK
			;検索
		    (let (DO(I 0)(LEN (length Ufm-exp)))(while (< I LEN)(let ((TMP (nth I Ufm-exp)))
		        (if (and (condition-case nil (string-match (car TMP) FILENAME)(error))(nth 2 TMP))(if (setq DO(nth 2 TMP))(progn
				(if (eq (car DO) 'Ufm-macro)(apply 'Ufm-macro (nth 1 DO)(nthcdr 2 DO))		;どうせ Ic-quit してしまうので。
				(eval DO))(throw 'BREAK t))))
		    (setq I (1+ I)))))
			;見つからなかったら編集
			(setq Ic-keep-buffer (find-file FILENAME))
			(setq file-name-history (append (list FILENAME) file-name-history))
			(goto-line line)
			(if start (set-window-start (selected-window) start)(recenter 0))
			)
        (Ic-quit)
    ))

;-------------------------------------------------------------------------------------------------
;;●ビュー

(defun Ufm-view (&optional filename mode)
    "ファイルの閲覧"
    (if filename ()(setq filename (Ufm-name 'dir)))
    (select-window Ic-win-wine);Because after mouse-drag Ic-refresh save wine window-start
    (delete-other-windows)
    (erase-buffer)
    (condition-case nil (insert-file filename)(error)(quit))
    (if mode (funcall mode)(Ufm-auto-mode filename))
    (condition-case nil (if enriched-mode nil (font-lock-fontify-buffer))(error (message "色を付けるのに失敗しました")))		;ううむうまくいかない。
    (Ufm-uView)
    )

(defun Ufm-auto-mode(FILE)
    (let ((LEN (length auto-mode-alist))(MODE)(I 0))(while (< I LEN)
        (setq MODE (nth I auto-mode-alist))
        (if (string-match (car MODE) FILE)
            (progn(condition-case nil (funcall (cdr MODE))(error))(setq I LEN)))
        (setq I (1+ I))
    )))
;(Ufm-auto-mode "file.el")

(defun Ufm-uView ()             ; 汎用ビューコマンドループ
    (let (Ufm-uView KEY FUNC (FLAG nil))  (while (not FLAG)
        (catch 'NEXT
        (setq KEY (vector (read-event)))
        (setq FUNC(lookup-key Ufm-uView-map KEY t))
        (condition-case nil
        (cond
            ((null FUNC)    (throw 'NEXT t))
            ((numberp FUNC) (throw 'NEXT t))
            (t              (funcall FUNC))
        ) (error ())))
    )FLAG))
(defvar Ufm-uView-map (make-sparse-keymap))
(define-key Ufm-uView-map   "e"             (lambda ()(setq FLAG 'e)(Ufm-edit-sub (window-start) (U-point-to-line (point)) filename)))
(define-key Ufm-uView-map   "E"             (lambda ()
    (setq FLAG t)
    (set-visited-file-name filename)
    (not-modified)
    (setq file-name-history (append (list filename) file-name-history))
    (setq Ic-keep-buffer (buffer-name(current-buffer)))
    (if (functionp 'Uz-Switch-enter)(Uz-Switch-enter))
    (Ic-quit)
    ))
(define-key Ufm-uView-map   "q"             (lambda ()(setq FLAG t)))
(define-key Ufm-uView-map   " "             (lambda ()(scroll-up   10))    )
(define-key Ufm-uView-map   "b"             (lambda ()(scroll-down 10))    )
(define-key Ufm-uView-map   "\C-s"          'isearch-forward                )
(define-key Ufm-uView-map   "\C-r"          'isearch-backward               )
(define-key Ufm-uView-map   [prior]         (lambda ()(scroll-down 15))    )
(define-key Ufm-uView-map   [next]          (lambda ()(scroll-up   15))    )
(define-key Ufm-uView-map   [up]            (lambda ()(scroll-down 5))     )
;(define-key Ufm-uView-map   "OA"            (lambda ()(scroll-down 5))     )
(define-key Ufm-uView-map   [down]          (lambda ()(scroll-up   5))     )
;(define-key Ufm-uView-map   "OB"          (lambda ()(scroll-up   5))     )
(define-key Ufm-uView-map   [(shift up)]    (lambda ()(Uz-Func-backward)))
(define-key Ufm-uView-map   [(shift down)]  (lambda ()(Uz-Func-forward)))
(define-key Ufm-uView-map   [left]          (lambda ()(goto-char (point-min))))
(define-key Ufm-uView-map   [right]         (lambda ()(goto-char (point-max))))
(define-key Ufm-uView-map   [home]          (lambda ()(goto-char (point-min))))
(define-key Ufm-uView-map   [end]           (lambda ()(goto-char (point-max))))
(define-key Ufm-uView-map   [down-mouse-1]  'Ic-mouse-1                 )
(define-key Ufm-uView-map   [down-mouse-2]		(lambda ()(setq FLAG t)))
(define-key Ufm-uView-map   [down-mouse-3]		(lambda ()(setq FLAG t)))

(define-key Ufm-uView-map   [triple-down-mouse-5]       (lambda ()(scroll-up   10))    );めんどくさ
(define-key Ufm-uView-map   [double-down-mouse-5]       (lambda ()(scroll-up   10))    )
(define-key Ufm-uView-map   [mouse-5]       (lambda ()(scroll-up   10))    )
(define-key Ufm-uView-map   [triple-down-mouse-4]       (lambda ()(scroll-down 10))    )
(define-key Ufm-uView-map   [double-down-mouse-4]       (lambda ()(scroll-down 10))    )
(define-key Ufm-uView-map   [mouse-4]       (lambda ()(scroll-down 10))    )
;(define-key Ufm-uView-map   [mouse-wheell]       (lambda ()(scroll-up 10))) ; for W32 できん

;-------------------------------------------------------------------------------------------------
;;●ファイル情報


(defvar Ufm-miel-IDX 0)
(defvar Ufm-miel-modes '(
    (Ufm-miel   . "みえーるもーど")
    (Ufm-karui  . "かるーいみえーるもーど")
    (Ufm-info   . "ファイル情報の表示")
    (Ufm-od     . "バイナリ表示するよ")
    ))

(defun Ufm-toggle-view ()
    "みえるモードのトグル"
    (setq Ufm-miel-IDX  (if (= (1+ Ufm-miel-IDX)(length Ufm-miel-modes)) -1 (1+ Ufm-miel-IDX)))
    (message (if (= -1 Ufm-miel-IDX)"なぁんにもしない"(cdr (nth Ufm-miel-IDX Ufm-miel-modes))))
    (setq Ufm-miel (if (= -1 Ufm-miel-IDX)nil(car (nth Ufm-miel-IDX Ufm-miel-modes))))
    (setq Ufm-save-cur Ic-IDX)
    (Ufm-refresh)
    )
(defun Ufm-miel ()
    ;"ファイルを emacs が表示します"
    (condition-case nil (progn 
        (erase-buffer)
        (insert-file (Ufm-name 'dir)))
    (error (insert (concat(Ufm-name 'dir) " is not regular file"))))
    )
(defun Ufm-karui ()
    ;"ファイルを head コマンドで表示します"
    (Ic-write-wine (erase-buffer))
    (let* ((FILE (Ufm-name 'dir))(ATT (nth 8 (file-attributes FILE))))
        (call-process "head" nil Ic-name-wine t "-40" FILE)
    ))

(defun Ufm-info3 ()
    "ディスク容量"
    (Ic-write-wine (erase-buffer)(insert "ディスク容量\n\n"))
    (call-process "df" nil Ic-name-wine t)
    )
(defun Ufm-od ()
    "バイナリ表示"
    (Ic-write-wine (erase-buffer))
    (call-process "od" nil Ic-name-wine "-x" (Ufm-name 'dir))
    )

(defun Ufm-info ()
    "ファイルの情報表示 (file wc du lddコマンドを実行)"
    (condition-case nil (save-excursion (let* ((FILE (Ufm-name 'dir))(ATT (file-attributes FILE))(D (concat
		"ファイルの種類  ："
			(let ((A (nth 0 ATT)))(cond 
				((eq t A) "ディレクトリ")
				((eq nil A)"普通のファイル")
				(t (concat "リンク先：" A (if (equal (concat "/" (file-relative-name A "/"))(file-truename FILE))
					 nil (concat "  最終リンク先：" (file-truename FILE)))))
			))
		"\nサイズ          ："	(concat (number-to-string (/(nth 7 ATT)1024)) "kB")
		"\nモード          ："	(nth 8 ATT)
		"\n最終アクセス時刻："	(format-time-string "%Y-%m/%d %H:%M %S" (nth 4 ATT))
		"\n最終修正時刻    ："	(format-time-string "%Y-%m/%d %H:%M %S" (nth 5 ATT))
		"\n最終状態変更時刻："	(format-time-string "%Y-%m/%d %H:%M %S" (nth 6 ATT))
		"\nユーザ  ＩＤ    ："	(number-to-string (nth 2 ATT))
		"\nグループＩＤ    ："	(number-to-string (nth 3 ATT))
		"\nハードリンクの数："	(number-to-string (nth 1 ATT))
;		"\n再生成時にGID変わる？："	(if (nth 9 ATT)"はい" "いいや")
;		"\nｉｎｏｄｅ番号  ："	(number-to-string (nth 10 ATT))
;		"\nファイルシステム番号  ："	(number-to-string (nth 11 ATT))
		"\nファイルの内容  ："
		)))

		(set-buffer Ic-name-wine)		;default-directory が変わってしまうので、ここで変更する
		(erase-buffer)(insert D)
        (call-process "file" nil Ic-name-wine t "-b" FILE)
        (if (string-match "^[^d].+[xs]" (nth 8 ATT))(progn (insert "\n必要ライブラリ：\n")(call-process "ldd" nil Ic-name-wine t FILE)))
        (if (eq t (nth 0 ATT))(let(P) (insert "ディレクトリのサイズ：\n")(setq P (start-process "Ufm-du" (get-buffer Ic-name-wine) "du" "-hs" FILE))
			(set-process-filter		P 'Ufm-du-filt)
			(set-process-sentinel	P 'Ufm-du-sent)
			))
		(if (string-match "text" (buffer-string))(progn
			(insert "ファイルの行数  ：")
			(setq P (start-process "Ufm-wc" (get-buffer Ic-name-wine) "wc" "-l" (Ufm-name 'dir)))
			(set-process-filter		P 'Ufm-wc-filt)
			(set-process-sentinel	P 'Ufm-du-sent)
			))
    ))(error)))

(defun Ufm-du-filt (PROG STR)
	(let ((OLD(current-buffer)))
	(unwind-protect (let (MARK)
		(set-buffer (process-buffer PROG))
		(setq MARK (= (point)(process-mark PROG)))
			(save-excursion
			(goto-char 0)
			;insert STR
			(condition-case nil (progn (search-forward "ディレクトリのサイズ：")(insert STR))(error))
			;END
			(set-marker (process-mark PROG)(point))
			);end of excursion
		(if MARK (goto-char (process-mark PROG))))
	(set-buffer OLD)))
	)
(defun Ufm-wc-filt (PROG STR)
	(let ((OLD(current-buffer)))
	(unwind-protect (let (MARK)
		(set-buffer (process-buffer PROG))
		(setq MARK (= (point)(process-mark PROG)))
			(save-excursion
			(goto-char 0)
			;insert STR
			(condition-case nil (progn (search-forward "ファイルの行数  ：")(string-match "\\([0-9]+\\)" STR)(insert (match-string 0 STR)))(error))
			;END
			(set-marker (process-mark PROG)(point))
			);end of excursion
		(if MARK (goto-char (process-mark PROG))))
	(set-buffer OLD)))
	)

(defun Ufm-du-sent (process str));何も表示させない

;-------------------------------------------------------------------------------------------------
;;●マニュアル閲覧
(defun Ufm-manpage (STR)
    "マニュアル閲覧"
    (require 'man)                  ;Thanks for Barry A. Warsaw
    (select-window Ic-win-wine)
    (delete-other-windows)
    (erase-buffer)
    (message "ちょっと待ってね")
    (let ((manual-program "man -l"))
        (set-process-sentinel (start-process
            "Ufm man process"
            (get-buffer Ic-name-wine)
            "sh" "-c" (format (Man-build-man-command) STR))
        'Ufm-manpage-sentinel))
    (Ufm-uView)
    )

(defun Ufm-manpage-sentinel (process str)
    (if(equal str "finished\n")(progn
        (if Man-fontify-manpage-flag(Man-fontify-manpage)(Man-cleanup-manpage)))
        (message str))
    (goto-char (point-min))
    )

;-------------------------------------------------------------------------------------------------
;;●変な機能

;ファイル内容を挿入
(defun Ufm-insert-file  ()
    "ファイル内容をもとのバッファに挿入する"
    (if (y-or-n-p "もとのバッファにファイル内容を挿入しますか？")
		(let (P(DELI (if Ufm-mark-list (read-from-minibuffer "ファイル間に挿入する文字列を入力してね : ")"")))
    (switch-to-buffer Ic-before-buffer)
    (if Ufm-mark-list nil (setq Ufm-mark-list (list Ic-IDX)))
	(mapcar (lambda (A) (insert-file (Ufm-name 'dir A))(exchange-point-and-mark)(insert DELI "\n"))Ufm-mark-list)
	)))

;ファイル名挿入
(defun Ufm-insert-filename  ()
    "ファイル名をもとのバッファに挿入する"
    (if (y-or-n-p "もとのバッファにファイル名を挿入しますか？")(progn
    (switch-to-buffer Ic-before-buffer)
    (if Ufm-mark-list
        (mapcar (function(lambda (A) (insert (concat (Ufm-name nil A) " "))))Ufm-mark-list)
        (insert (Ufm-name))))))

(defun Ufm-insert-pathname  ()
    "絶対パス名をもとのバッファに挿入する"
    (if (y-or-n-p "もとのバッファに絶対パス名を挿入しますか？")(progn
    (switch-to-buffer Ic-before-buffer)
    (if Ufm-mark-list
        (mapcar (function(lambda (A) (insert (concat (Ufm-name 'dir A) " "))))Ufm-mark-list)
        (insert (Ufm-name 'dir))))))


(defun Ufm-pathname-selection ()
    "マーク絶対パス名をセレクションに入れます。"
    (let ((STR
        (let ((Ufm-mark-list (if Ufm-mark-list Ufm-mark-list (list Ic-IDX))))
            (mapconcat (function (lambda (A)(Ufm-name 'dir A)))Ufm-mark-list " "))))
    (condition-case nil (message STR)(error))(x-set-selection nil STR)))			;message が %s を含むファイル名でエラーを起こすのでな。根本的な対策が必要か。


(defun Ufm-filename-selection ()
    "マークファイル名をセレクションに入れます。"
    (let ((STR
        (let ((Ufm-mark-list (if Ufm-mark-list Ufm-mark-list (list Ic-IDX))))
            (mapconcat (function (lambda (A)(Ufm-name nil A)))Ufm-mark-list " "))))
    (condition-case nil (message STR)(error))(x-set-selection nil STR)))

(defun Ufm-chdir-selection ()
    "cd /usr/bin/ 等とシェルに渡せるような文字列をセレクションに入れる"
    (let ((STR(concat "cd " Ufm-dir)))(condition-case nil (message STR)(error))(x-set-selection nil STR))
    )


;ファイル名ジャンプ
(defun Ufm-jump ()
    "ファイル名ジャンプ(正規表現にマッチするファイルにカーソルを逐次移動する)"
    (condition-case var (let (SPEC INPUT (REGEXP "^"))(catch 'END
    (while t
        (message REGEXP)
        (setq INPUT (read-event))
        (setq REGEXP (cond
            ((integerp INPUT)(concat REGEXP (char-to-string INPUT)))
            ((eq 'backspace INPUT)(if (eq 0 (length REGEXP))REGEXP(substring REGEXP 0 -1)))
            (t  (setq unread-command-events (append (list INPUT) unread-command-events))(throw 'END nil))
;           ((eq 'return INPUT)(setq unread-command-events  (append (list INPUT) unread-command-events))(throw 'END nil))
            ))
        (if (setq SPEC (catch 'BREAK (let ((I 0) STR)(while t
            (if (= I Ic-max)(progn(ding)(throw 'END nil)));無い
            (if (string-match REGEXP (Ufm-name nil I))(throw 'BREAK I));あった
            (setq I (1+ I))
            ))))    (Ic-idx-spec SPEC));もし移動できるなら移動
        )))
    (quit)(error)))

;LISPロード
(defun Ufm-load()
    "Ｌｉｓｐファイルとして読み込む"
    (Ufm-macro "%PTAG %c" (lambda (LIST) (mapcar (function load)LIST)))
    )
;-------------------------------------------------------------------------------------------------
;●リフレッシュ(カーソル位置を保存して)
(defun Ufm-re-refresh ()
    "更新 (ディレクトリを再検索)"
    (message (documentation 'Ufm-re-refresh))
    (setq Ufm-save-cur (Ufm-name))
    (Ufm-refresh)
    )

;●更新しないカーソル移動
(defun Ufm-S-up()
    "みえーる情報を更新しないカーソル移動"
    (Ic-before-cur)
    (setq Ic-IDX (if (= Ic-IDX 0)(1- Ic-max)(1- Ic-IDX)))
    (setq Ic-refresh nil)
    (setq Ic-no-wine t)
    (Ic-after-cur)
    (setq Ic-no-wine nil)
    )
(defun Ufm-S-down()
    "みえーる情報を更新しないカーソル移動"
    (Ic-before-cur)
    (setq Ic-IDX(if(= (1+ Ic-IDX) Ic-max)0(1+ Ic-IDX)))
    (setq Ic-refresh nil)
    (setq Ic-no-wine t)
    (Ic-after-cur)
    (setq Ic-no-wine nil)
    )

;-------------------------------------------------------------------------------------------------
;;●リンク

;ハードリンク
(defun Ufm-hlink ()
    "ハードリンクの作成"
    (add-name-to-file
        (Ufm-name 'dir)
        (read-file-name "ハードリンク ： " (Ufm-name 'dir))
        )
    (setq Ufm-save-cur Ic-IDX)
    (Ufm-refresh)
    )
;シンボリックリンク
(defun Ufm-slink ()
    "シンボリックリンクの作成"
    (if Ufm-mark-list(let* (
        ;一括コピー
        (LIST (mapcar (function (lambda (A) (Ufm-name 'dir A))) Ufm-mark-list))
        (DIR (Ufm-dir "リンク先ディレクトリ： " (Ufm-name 'dir)))
        (I 0)
        (LEN (length LIST))
        )
        (while (< I LEN)(let ((TMP (nth I LIST)))
            (condition-case nil (make-symbolic-link TMP (concat DIR (cdr (file-namae TMP))))
                (error (message (concat TMP "のシンボリックの作成は失敗だ"))))
        (setq I (1+ I)))))
        ;一つだけ明示
        (let ((DST))
            (setq DST (read-file-name "リンク先ファイル名 ： " (Ufm-name 'dir)))
            (if (or (not (file-exists-p DST))(and (y-or-n-p (concat DST " はあるよ。削除する？"))(Ufm-delf DST)))
                (make-symbolic-link (Ufm-name 'dir) DST)(message "シンボリックリンクは作らなかったよ"))
            )
        )
    (setq Ufm-save-cur Ic-IDX)
    (Ufm-refresh)
    )

;シンボリックリンクを一つたどる
(defun Ufm-go-link ()
    "シンボリックリンク先を一つたどる"
    (let ((FILE (file-symlink-p(Ufm-name))))(if FILE (progn
    (message (documentation 'Ufm-go-link))
    (setq FILE (file-namae (expand-file-name FILE)))
    (setq Ufm-save-cur      (cdr FILE))
    (setq Ufm-go-before     Ufm-dir)
    (setq Ufm-dir           (car FILE))
    (Ufm-refresh)
    )(message "それはシンボリックリンクではないな"))))

;-------------------------------------------------------------------------------------------------
;;●ファイル名変更
(defun Ufm-rename ()
    "ファイル名の変更"
    (if Ufm-mark-list 
    ;タグファイル一括操作
    (catch 'BREAK (let (last-kbd-macro STR)
        (if defining-kbd-macro (end-kbd-macro))
        (start-kbd-macro nil)
        (setq STR (read-from-minibuffer "新名前 ： " (cons (Ufm-name nil (nth 0 Ufm-mark-list)) 0)))
        (if defining-kbd-macro nil (ding)(message "ファイル名変更中止")(sit-for 2)(throw 'BREAK nil))
        (end-kbd-macro)

        (let* ((I 0)(LIST (mapcar (function (lambda (A) (Ufm-name nil A))) Ufm-mark-list))(LEN (length LIST)))
        (while (< I LEN)(let* ((FROM (nth I LIST))(TO FROM))
        (save-excursion
            (switch-to-buffer(get-buffer-create " *Ufm-name-change*"))
            (erase-buffer)
            (insert TO)
            (goto-char 1)
            ;(setq A (number-to-string I))
            (condition-case nil (execute-kbd-macro last-kbd-macro)(error))
            (setq TO (buffer-string))
            )
        (condition-case nil (rename-file FROM TO)
            (error (ding)(sit-for 2)(message (concat FROM " --> " TO " ファイル名変更は失敗だ"))))
        (setq I (1+ I)))))
    ))
    ;ファイル一つだけ
    (let ((NEW (read-from-minibuffer "新名前 ： " (cons (Ufm-name nil nil) 0))))
    (condition-case VAR (rename-file (Ufm-name) NEW)(error (message (concat (Ufm-name) " --> " NEW " ファイル名変更は失敗だ"))(ding)(sit-for 1)))
    (setq Ufm-save-cur NEW)
    ))(Ufm-refresh))

;キーボードマクロを使わないファイル名変更関数
(defun Ufm-rename2 ()
    "ファイル名の変更(タグファイルに対しては一つずつ指定)"
    (if Ufm-mark-list ()(setq Ufm-mark-list (list Ic-IDX)))
    (mapcar (lambda (I)
        (let ((NEW (read-from-minibuffer (concat (Ufm-name nil I)  " --> 新名前 ： ") (cons (Ufm-name nil I) 0))))
            (condition-case VAR 
                (rename-file (Ufm-name nil I) NEW)
                (error (message (concat (Ufm-name nil I) " --> " NEW " ファイル名変更は失敗だ"))(ding)(sit-for 1))
            )))
        Ufm-mark-list
        )
    (Ufm-refresh)
    )

;-------------------------------------------------------------------------------------------------
;;●ファイル属性変更

(defvar Ufm-att-hist ())
(defvar Ufm-att-map (make-keymap))
(define-key Ufm-att-map [up] 'Ufm-att-up)
(define-key Ufm-att-map [down] 'Ufm-att-up)
(define-key Ufm-att-map Ic-return-key 'exit-minibuffer)
(define-key Ufm-att-map [13] 'exit-minibuffer)
(define-key Ufm-att-map "\C-n" 'next-matching-history-element)
(define-key Ufm-att-map "\C-p" 'previous-matching-history-element)
(define-key Ufm-att-map "\M-n" 'next-history-element)
(define-key Ufm-att-map "\M-p" 'previous-history-element)
(define-key Ufm-att-map " "     (lambda ()(interactive)(erase-buffer)(insert "---------")))
(define-key Ufm-att-map "\M- "  (lambda ()(interactive)(erase-buffer)(insert "rwxrwxrwx")))
(define-key Ufm-att-map "\C-g"  (lambda ()(interactive)(erase-buffer)(exit-minibuffer)))

(defun Ufm-att-up ()
    (interactive)
    (let ((STR (buffer-string))(POS (point)))
        (condition-case nil (progn
        (insert(if (eq(elt STR (1- POS))45); - ならば
            (cond 
            ((or (eq POS 1)(eq POS 4)(eq POS 7))"r")
            ((or (eq POS 2)(eq POS 5)(eq POS 8))"w")
            ((or (eq POS 3)(eq POS 6)(eq POS 9))"x")
            )"-"))
        (delete-char 1)
        (backward-char 1)
    )(error))
    ))

(defun Ufm-attribute ()
    "ファイルの属性変更"
    (if Ufm-mark-list ()(setq Ufm-mark-list (list Ic-IDX)))
    (catch 'BREAK (let
        (
        (ATT (read-from-minibuffer "ファイル属性(上下キー) :: " 
            (cons (substring (nth 8 (file-attributes (concat Ufm-dir (Ic-idx 5))))1 nil ) 1)
            Ufm-att-map nil 'Ufm-att-hist))
        )
        (if (< (length ATT) 9)(throw 'BREAK t))
        (apply 'call-process "chmod" nil nil t (concat
                (number-to-string (+ (if (eq(elt ATT 0)45)0 4)(if (eq(elt ATT 1)45)0 2)(if (eq(elt ATT 2)45)0 1)))
                (number-to-string (+ (if (eq(elt ATT 3)45)0 4)(if (eq(elt ATT 4)45)0 2)(if (eq(elt ATT 5)45)0 1)))
                (number-to-string (+ (if (eq(elt ATT 6)45)0 4)(if (eq(elt ATT 7)45)0 2)(if (eq(elt ATT 8)45)0 1)))
                )
            (mapcar (function (lambda (A)(Ufm-name 'dir A)))Ufm-mark-list)))
    (Ufm-re-refresh)))

;-------------------------------------------------------------------------------------------------
;;●実行

(defvar Ufm-exec-hist nil)
(defvar Ufm-exec-map (copy-keymap minibuffer-local-map))
(define-key Ufm-exec-map "\C-c\C-d" (lambda () (interactive)(process-send-eof PROCESS)                         ));?
(define-key Ufm-exec-map "\C-c\C-c" (lambda () (interactive)(interrupt-process PROCESS)    (exit-minibuffer)   ))
(define-key Ufm-exec-map "\C-c\C-k" (lambda () (interactive)(kill-process PROCESS)         (exit-minibuffer)   ));?
(define-key Ufm-exec-map "\C-c\C-b" (lambda () (interactive)(quit-process PROCESS)         (exit-minibuffer)   ))
(define-key Ufm-exec-map "\C-c\C-z" (lambda () (interactive)(stop-process PROCESS)                             ))
(define-key Ufm-exec-map "\C-c\C-x" (lambda () (interactive)(continue-process PROCESS)                         ));?
(define-key Ufm-exec-map "\C-c\C-h" (lambda () (interactive)(delete-process PROCESS)       (exit-minibuffer)   ));?
(define-key Ufm-exec-map "\C-c\C-q" (lambda () (interactive)
        (let ((NUM (read-from-minibuffer "シグナル整数 : " nil nil t)))(if (numberp NUM)(signal-process PROCESS NUM)(ding)))))
(define-key Ufm-exec-map "\C-c\C-p" (lambda () (interactive)(throw 'BREAK t)))
(define-key Ufm-exec-map "\C-h" (lambda () (interactive)(Ufm-exec-help)))
(define-key Ufm-exec-map [f1] (lambda () (interactive)(Ufm-exec-help)))

(defun Ufm-exec (&optional ARGS MAP HIST BUFF SENTI PROMPT INIT COM NOMES)
    "プログラムの実行"
    (let* (DO MES)
        ;履歴
        (if HIST (if (boundp HIST)()(set HIST nil)))
        ;コマンドライン
        (setq DO (if ARGS ARGS
            (Ufm-macro (let ((STRS (read-from-minibuffer (concat "shell command (" (Ufm-name) "): "))))
                (if (equal "" STRS)(Ufm-name 'dir) STRS))
                t
                )
;           (split-string (let ((STRS (read-from-minibuffer (concat "shell command (default : " (Ufm-name 'dir) "): "))))
;               (if (equal "" STRS)(Ufm-name 'dir) STRS)))
            ))
        ;実行
        (condition-case nil (progn 
            (select-window (get-buffer-window Ic-name-wine))
            (if BUFF (switch-to-buffer BUFF))
            (delete-other-windows)(erase-buffer)

			;開始メッセージの表示
;            (if NOMES ()
;                (setq MES (concat "[" (nth 0 DO) "] process started !\n"))
;                (put-text-property 0 (length MES) 'face 'C-Green MES)
;                (insert MES)
;                )

			;非同期コマンドの生成(といいつつ、強制的に同期させるけど)
			(set-buffer (get-buffer-create (if BUFF BUFF Ic-name-wine)))(setq default-directory Ufm-dir)
            (let ((PROCESS (apply (if COM 'start-process 'start-process-shell-command) "Ufm-exec" (if BUFF BUFF Ic-name-wine) DO)))(catch 'BREAK 

           (set-process-sentinel PROCESS (if SENTI SENTI 'Ufm-sentinel3))
;            (if SENTI (set-process-sentinel PROCESS SENTI))

;           (set-process-filter PROCESS 'Ufm-exec-filter)
           (while t (let ((SEND (condition-case nil
                ;文字列の読み込み
                (read-from-minibuffer
                    (if PROMPT PROMPT "stdin : ")
                    INIT
                    (if MAP (eval MAP) Ufm-exec-map)
                    nil
                    (if HIST HIST 'Ufm-exec-hist)
                    )(error)(quit))))
                ;文字を送る
                (if (or (eq 'exit (process-status PROCESS))(eq 'signal (process-status PROCESS))(eq 'closed (process-status PROCESS)))
                    (throw 'BREAK nil)                                  ; 終了してたら終わる
                    (process-send-string PROCESS (concat SEND "\n")))   ; 終了してなかったら送る
                ;改行を追加する
                (let ((OLD(current-buffer)))
                    (unwind-protect (let (MARK)
                    (set-buffer (process-buffer PROCESS))
                    (setq MARK (= (point)(process-mark PROCESS)))
                    (save-excursion
                        (goto-char (process-mark PROCESS))
                        (insert "\n")
                        (set-marker (process-mark PROCESS)(point))
                        )
                    (if MARK (goto-char (process-mark PROCESS))))
                    (set-buffer OLD)))
                ))
            )
			;バッファ表示位置を最初にする
			(if (get-buffer-window (process-buffer PROCESS))(set-window-start (get-buffer-window (process-buffer PROCESS)) 1))
			)
        )(error (message "なんだかわからないけれど、とりあえずエラーです。"))(quit (message "中断しました")))
    ))

(defun Ufm-exec-help ()
    (select-window Ic-win-wine)
    (delete-other-windows)
    (insert
"
Ufm ファイルマネージャ (C) Usuda Hiroshi

C-c C-d     EOFを送る
C-c C-c     シグナル・割込      interrupt
C-c C-k     シグナル・即殺      kill
C-c C-b     シグナル・終了      quit
C-c C-z     シグナル・停止      stop
C-c C-x     シグナル・継続      continue
C-c C-h     シグナル・消去      delete
C-c C-q     任意のシグナルを送る
C-c C-p     プロセスを停止しないで終了
"   )(Ufm-uView)(other-window 1))

;-------------------------------------------------------------------------------------------------
;;●ういんどうずらいくな作業(結構便利だったりする)

(defvar Ufm-w95-file ())
(defvar Ufm-w95-or nil)
(defun Ufm-w95-cut ()
    (setq Ufm-w95-file (Ufm-macro "%PTAGS %c" t))
    (message (concat (prin1-to-string (Ufm-macro "%TAGS %c" t))" を切り取りばっふぁに入れたぞ！！"))
    (setq Ufm-w95-or t)
    )

(defun Ufm-w95-copy ()
    (setq Ufm-w95-file (Ufm-macro "%PTAGS %c" t))
    (message (concat (prin1-to-string (Ufm-macro "%TAGS %c" t))" をコピーばっふぁに入れたぞ！！"))
    (setq Ufm-w95-or nil)
    )

(defun Ufm-w95-link ()
    (let (SRC DST (I (length Ufm-w95-file)))
    (while (< 0 I)
	(setq DST Ufm-dir)
    (setq SRC (nth (1- I) Ufm-w95-file))
    (if (file-exists-p (concat DST (cdr (file-namae SRC))))(progn
		(setq DST (concat (car (file-namae SRC))(read-from-minibuffer (concat "コピー先ファイルが存在します 新ファイル名 : "(car (file-namae SRC))))))
		(while (file-exists-p DST)(setq DST(concat (car (file-namae SRC))(read-from-minibuffer (concat "存在しないファイル名を入力してね : "(car (file-namae SRC)))))))
		))
	(if (eq 'dir (Ufm-fmode DST))(setq DST (concat DST (cdr (file-namae SRC)))))
    (if Ufm-w95-or
		;移動
		(progn
			(if (Ufm-C-mv SRC DST)
			(condition-case nil (make-symbolic-link DST SRC)(error (message "リンク張るのに失敗した")(ding)(sit-for 1)))
			(progn (message (concat SRC " から " DST "への移動は失敗だ"))(ding)(sit-for 1))))
		;コピー
		(condition-case nil (make-symbolic-link SRC DST)(error (message (concat SRC " から " DST "へリンクは失敗だ"))(ding)(sit-for 1)))
        )
        (setq I (1- I))
        ))
    (Ufm-refresh)
    )

;ファイルの存在をテストする。
;FILEが存在しないなら、そのまま FILE を返す。
;FILEが存在したら、消去していいか聞いて、OKならば消去可能ならば消去する。消去可能でなければ
;
;(defun Ufm-test(FILE)
;    (if (file-exists-p FILE)(progn
;		(setq FILE (concat (car (file-namae FILE))(read-from-minibuffer (concat "コピー先ファイルが存在します 新ファイル名 : "(car (file-namae FILE))))))
;		(while (file-exists-p FILE)(setq FILE (concat (car (file-namae FILE))(read-from-minibuffer (concat "存在しないファイル名を入力してね : "(car (file-namae FILE)))))))
;		))
;	)

(defun Ufm-w95-paste ()
    (let (SRC (DST Ufm-dir)(I (length Ufm-w95-file)))
    (while (< 0 I)
    (setq SRC (nth (1- I) Ufm-w95-file))
    (if (file-exists-p (concat DST (cdr (file-namae SRC))))(progn
		(setq DST (concat (car (file-namae SRC))(read-from-minibuffer (concat "コピー先ファイルが存在します 新ファイル名 : "(car (file-namae SRC))))))
		(while (file-exists-p DST)(setq DST(concat (car (file-namae SRC))(read-from-minibuffer (concat "存在しないファイル名を入力してね : "(car (file-namae SRC)))))))
		))
    (if Ufm-w95-or
		;移動
		(if (Ufm-C-mv SRC DST) nil (message (concat SRC " から " DST "へ移動は失敗だ"))  (ding)(sit-for 1))
		;コピー
		(if (Ufm-C-cp SRC DST) nil (message (concat SRC " から " DST "へコピーは失敗だ"))(ding)(sit-for 1))
        )
        (setq I (1- I))
        ))
    (Ufm-refresh)
    )

;-------------------------------------------------------------------------------------------------
;;●ファイル消去
(defun Ufm-delete ()
    "ファイルの削除"
    (if (y-or-n-p "本当に削除していいの？")
        (progn (Ufm-macro "%PTAG %c" (lambda (LIST) (mapcar (function Ufm-delf)LIST)))(Ufm-refresh)))
    )

;ファイルを削除するときにはこの関数を呼びましょう
;   tは成功 nilは失敗
(defun Ufm-delf(FILE &optional UMU)
    (if (catch 'BREAK (let*(
        (PATH   (expand-file-name FILE))            ; 絶対パス名
        (TYPE   (nth 0(file-attributes PATH)))  ; dir:t nil:file
        (MODE   (file-writable-p PATH))             ; 書き込み可能かどうか
        )
    ;書き込み権がないとき
    (if MODE()(if (or UMU (y-or-n-p  (concat FILE " ->> 書き込み権がないよ。強制削除するの？")))()(throw 'BREAK nil)))
    (if (eq t TYPE)
    ;ディレクトリの時
        (condition-case VAR (progn (delete-directory PATH) t)
        (file-error (if(or UMU (y-or-n-p(concat  FILE  " ->> 中身があるよ！容赦無く全て消し去りますか？ ")))
            (if 
				(Ufm-C-deldir PATH)
				;(condition-case VAR (progn (set-file-modes PATH 511)(delete-directory PATH))(error))

				t(throw 'BREAK nil))(throw 'BREAK nil))))
    ;ファイルの時
        (if (condition-case VAR (progn ;(set-file-modes PATH 511)			;モード変えてからやんなくてもいいみたい
										(delete-file PATH)t)(error))
			;(defvar Ufm-C-del       '(eq 0 (call-process "rm" nil nil t "-f" PATH)))        ;Write プロテクトの掛かったファイル PATH を消去する
			;(eval Ufm-C-del)
			t(throw 'BREAK nil)))
        ))
    ;ファイル削除成功
    t
    ;ファイル削除失敗
    (message (concat FILE " ->> 削除しなかったよ"))
    (ding)
    ))
;-------------------------------------------------------------------------------------------------
;;●ファイル移動

(defun Ufm-leave ()
    "ファイルの移動(元の所にシンボリックリンクを残す)"
    (Ufm-move t)
    )
(defun Ufm-move (&optional LEAVE dstDIR &rest srcFILES)
    "ファイルの移動"
    ;マークファイルを処理する
    (if Ufm-mark-list ()(setq Ufm-mark-list (list Ic-IDX)))
    ;移動先ディレクトリ名を入力する
    (let (
		(DIR (if dstDIR dstDIR (Ufm-dir (if LEAVE "シンボリック残すけど、本体を移動する先：" "移動先ディレクトリ : ") nil t nil t)))
		(I (length (if srcFILES srcFILES Ufm-mark-list)))
		)(if DIR
        (while (> I 0)(let* (
            (FILE (if srcFILES (cdr (file-namae (nth (1- I) srcFILES))) (Ufm-name nil (nth (1- I) Ufm-mark-list))))	;移動するファイルのファイル名
            (SRC  (if srcFILES (nth (1- I) srcFILES)(concat Ufm-dir FILE)))											;移動するファイルの絶対パス名
            (DST (concat DIR FILE))                             ;移動先
            (OK t)
            (NEW)
            (PROCESS)                                           ;プロセスの戻り値
            )
        (cond
        ;フロッピーに移動
        ((equal DIR "a:")
            (message "フロッピーにコピー中です")
            (setq PROCESS (call-process "mcopy" nil nil nil Ufm-a-over-mode SRC "a:"))
            (if (eq 0 PROCESS)(setq PROCESS (Ufm-delf SRC t))(ding)(message (concat SRC " --> フロッピーへの移動が失敗しました")))
            (if PROCESS ()(message "ファイルの削除に失敗したよ")(ding))
            )
        ;同じディレクトリの場合は、単なる名前の変更
        ((equal Ufm-dir DIR)
            (setq NEW (concat Ufm-dir (read-from-minibuffer " 新ファイル名 : ")))
            (setq PROCESS (call-process "mv" nil nil t SRC NEW))
            (if (eq 0 PROCESS)()(ding)(message (concat SRC " --> " NEW " ファイル名の変更に失敗しました")))
            )
        ;ファイルの存在確認
        (t
            (if (file-exists-p DST)(progn
                (setq OK (y-or-n-p (concat DST " --> ファイルあるよ。消してもいいんだね？")))
                (if OK (if (Ufm-delf DST)()(setq OK nil)))
                ))
            (if OK (if (eq 0(call-process "mv" nil nil t SRC DST))
                ;移動成功
                (if LEAVE (call-process "ln" nil nil t "-s" DST))
                ;移動失敗
                (ding)(message (concat SRC " --> " DST " :ファイルの移動に失敗しました"))))
            ))
        (setq I (1- I))))
        ))
    (Ufm-refresh)
    )
;-------------------------------------------------------------------------------------------------
;;●ファイルコピー
;
;	dstDIR		は、"/dstdir/" ってかんじ
;	srcFILES	は、("/dir/file1" "/dir/file2" ...) ってかんじ
;

(defun Ufm-copy (&optional dstDIR &rest srcFILES)
    "ファイルのコピー"
    (if Ufm-mark-list ()(setq Ufm-mark-list (list Ic-IDX)))
    (let ((ALL)(DIR (if dstDIR dstDIR (Ufm-dir "コピー先ディレクトリ名 : " nil t nil t))) (I (length (if srcFILES srcFILES Ufm-mark-list))))(if DIR
        (while (> I 0)(let* (
            (FILE (if srcFILES (cdr (file-namae (nth (1- I)srcFILES)))(Ufm-name nil (nth (1- I) Ufm-mark-list))))	;ファイル名
            (SRC (if srcFILES (nth (1- I)srcFILES)(concat Ufm-dir FILE)))										;ファイル名絶対パス
            (DST (if dstDIR (concat dstDIR (cdr (file-namae PATH)))(concat DIR FILE)))			;コピー先絶対パス
            (OK)																				;コピーするかどうか
            )
        (cond
        ;フロッピー
        ((equal DIR "a:")
            (message (concat SRC " --> フロッピーにコピー中だぞ"))
            (if (eq (length (if srcFILES srcFILES Ufm-mark-list)) 1)
                (set-process-sentinel(start-process "floppy" nil "mcopy" Ufm-a-over-mode SRC "a:")'Ufm-a-sentinel)
                (call-process "mcopy" nil nil t Ufm-a-over-mode SRC "a:")))
        ;通常ファイル
        (t
            (if (file-exists-p DST)(progn(let ((OLD DST))

				;デフォルトは名前を変えて
				(if ALL nil (catch 'G (while 
					(file-exists-p DST)
					(setq DST (read-from-minibuffer "新ファイル名 : " (list DST)))
					(if (equal DST OLD)(throw 'G nil))
					(setq OLD DST)
					)))
				(if (equal OLD DST)(progn
                (if ALL ()(setq ALL (Ic 'Ufm-copy-table 'Ufm-copy-option)))
                (cond
                ;現在のファイルについて
                ((eq 'size  ALL)(setq ALL nil)  ;サイズの大きい方
                    (if (<= (nth 7 (file-attributes SRC)) (nth 7 (file-attributes DST)))
                        (Ufm-copy-no)(Ufm-copy-yes)(setq OK (Ufm-delf DST))))
                ((eq 'small ALL)(setq ALL nil)  ;サイズの小さい方
                    (if (>= (nth 7 (file-attributes SRC)) (nth 7 (file-attributes DST)))
                        (Ufm-copy-no)(Ufm-copy-yes)(setq OK (Ufm-delf DST))))
                ((eq 'over  ALL)(setq ALL nil)  ;上書き
                    (Ufm-copy-yes)(setq OK (Ufm-delf DST)))
                ((eq 'time  ALL)(setq ALL nil)  ;新しい方をコピー
                    (if (file-newer-than-file-p DST SRC)(Ufm-copy-no)(Ufm-copy-yes)(setq OK (Ufm-delf DST))))
                ((eq 'late  ALL)(setq ALL nil)  ;古いをコピー
                    (if (file-newer-than-file-p SRC DST)(Ufm-copy-no)(Ufm-copy-yes)(setq OK (Ufm-delf DST))))
                ((eq 'ren   ALL)(setq ALL nil)  ;名前を変えて
                    (while (file-exists-p DST)(setq DST (read-from-minibuffer "新ファイル名 : " (list DST))))(setq OK t))
                ((eq 'no    ALL)(setq ALL nil)  (Ufm-copy-no)(setq OK nil))
                ;すべてのファイルについて
                ((eq 'SIZE  ALL)
                    (if (<= (nth 7 (file-attributes SRC)) (nth 7 (file-attributes DST)))
                    (Ufm-copy-no)(Ufm-copy-yes)(setq OK (Ufm-delf DST))))
                ((eq 'SMALL ALL)
                    (if (>= (nth 7 (file-attributes SRC)) (nth 7 (file-attributes DST)))
                    (Ufm-copy-no)(Ufm-copy-yes)(setq OK (Ufm-delf DST))))
                ((eq 'OVER  ALL)
                    (setq OK (Ufm-delf DST)))
                ((eq 'TIME  ALL)
                    (if (file-newer-than-file-p DST SRC)(Ufm-copy-no)(Ufm-copy-yes)(setq OK (Ufm-delf DST))))
                ((eq 'LATE  ALL)
                    (if (file-newer-than-file-p SRC DST)(Ufm-copy-no)(Ufm-copy-yes)(setq OK (Ufm-delf DST))))
                ((eq 'REN   ALL)
                    (while (file-exists-p DST)(setq DST (read-from-minibuffer "新ファイル名 : " (cons DST nil))))(setq OK t))
                ((eq 'NO    ALL)                (setq OK nil))
                ))
				(setq OK t)
				)))
			(setq OK t)))
			)
		;コピー実行
		(if OK (if (Ufm-C-cp SRC DST)()(message (concat SRC " から " DST "へコピーは失敗だ"))(ding)(sit-for 1)))
		)
        (setq I (1- I)))
    ))(Ufm-refresh))

;(defun Ufm-copy-sub (SRC DST)
;   )

(defun Ufm-copy-yes ()(message (concat (file-name-nondirectory SRC) " は上書きします")))
(defun Ufm-copy-no  ()(message (concat (file-name-nondirectory SRC) " はコピーしません")))

(defun Ufm-a-sentinel (process str)
    (if (equal str "finished\n")(progn (ding)(sit-for 0.2)(ding)(message "フロッピーへの書き込みが終わったぞ")))
    )
;(string-to-char "R")

(defvar Ufm-copy-table '(
    ("問答無用に上書き"         over    nil nil nil nil nil nil 111 );o
    ("やっぱやめ"               no      nil nil nil nil nil nil 110 );n
    ("名前を変えて"             ren     nil nil nil nil nil nil 114 );r
    ("変更時間の新しい方"       time    nil nil nil nil nil nil 116 );t
    ("サイズの大きい方"         size    nil nil nil nil nil nil  98 );b
    ("サイズの小さい方"         small   nil nil nil nil nil nil 115 );s (string-to-char "L")
    ("変更時間の古いほう"       late    nil nil nil nil nil nil 108 );l
    ("─────────────")
    ("全部 上書き"    OVER    nil nil nil nil nil nil 79  )			;O
    ("全部 やめ"          NO      nil nil nil nil nil nil 78  )		;N
    ("全部 名前を変更"        REN     nil nil nil nil nil nil 82  )	;R
    ("全部 新しい方"  TIME    nil nil nil nil nil nil 84  )			;T
    ("全部 大きい方"    SIZE    nil nil nil nil nil nil 66  )		;B
    ("全部 小さい方"    SMALL   nil nil nil nil nil nil 83  )		;S
    ("全部 古い  方"  LATE    nil nil nil nil nil nil 76  )			;L
    ))


(defvar Ufm-copy-option '((title " -> ファイルがあるよ。消しちゃうよ？")(short-cut)(short-disp)))

;-------------------------------------------------------------------------------------------------
;;●圧縮 解凍

(defun Ufm-res(P)		;プロセス歩哨用バッファ再検索関数
	(if (boundp 'Ufm-table)(let ((s Ufm-mark-list))
		(setq Ufm-save-cur Ic-IDX)
		(Ufm-refresh)
		(setq Ufm-mark-list s)))
	(if (and (not (boundp 'Ufm-uView))(boundp 'Ic-Table)(eq Ic-Table 'Ufm-table))
		(progn
			(Ic-refresh)
			(select-window Ic-win-wine)
			(switch-to-buffer(buffer-name (process-buffer P)))
			(select-window Ic-win-milk)
		))
	)

(defun Ufm-pack-sentinel (process str)
    (if (equal str "finished\n")(progn
		(Ufm-res process)(ding)(sit-for 0.2)(ding)(message "圧縮が終わったぞ")))
    )

(defun Ufm-pack-gz ()
    "ファイルの圧縮 (gz 圧縮)"
    (set-process-sentinel (start-process "Ufm pack gz" nil "gzip" "-9" (Ufm-name 'dir)) 'Ufm-pack-sentinel)
    )

(defun Ufm-pack ()
    "ファイルの圧縮 (tar.gz 圧縮)"
    (if Ufm-mark-list ()(setq Ufm-mark-list (list Ic-IDX)))
    (let ((FILES nil)(I (length Ufm-mark-list)))
        (while (> I 0)(let ((FILE (Ufm-name nil (nth (1- I) Ufm-mark-list))))
            (setq FILES (append FILES (list FILE)))
            (setq I (1- I))))
        (let ((PACK
            (expand-file-name (concat (read-from-minibuffer "圧縮ファイル名 (?.tar.gz) : ") ".tar"))
            )(OK t))
        (if (file-exists-p (concat PACK ".gz"))
            (progn  (setq OK (y-or-n-p "上書きしますか？"))
                    (if OK (Ufm-delf (concat PACK ".gz")))))
        (if OK (progn
            (set-process-sentinel
            (eval (`(start-process-shell-command "Ufm pack" nil "tar" "cvf" PACK (,@ FILES) ";" "gzip" PACK)))
            'Ufm-pack-sentinel)
            (message "ファイル圧縮中です。使ってるファイルは消さないでね。")
            ))
        )
    )
    (Ufm-refresh)
    )

(defun Ufm-pack-tar-bz ()
    "ファイルの圧縮 (tar.bz2 圧縮)"
    (if Ufm-mark-list ()(setq Ufm-mark-list (list Ic-IDX)))
    (let ((FILES nil)(I (length Ufm-mark-list)))
        (while (> I 0)(let ((FILE (Ufm-name nil (nth (1- I) Ufm-mark-list))))
            (setq FILES (append FILES (list FILE)))
            (setq I (1- I))))
        (let ((PACK
            (expand-file-name (concat (read-from-minibuffer "圧縮ファイル名 (?.tar.bz2) : ") ".tar"))
            )(OK t))
        (if (file-exists-p (concat PACK ".bz2"))
            (progn  (setq OK (y-or-n-p "上書きしますか？"))
                    (if OK (Ufm-delf (concat PACK ".bz2")))))
        (if OK (progn
            (set-process-sentinel
            (eval (`(start-process-shell-command "Ufm pack" nil "tar" "cvf" PACK (,@ FILES) ";" "bzip2" "-z" PACK)))
            'Ufm-pack-sentinel)
            (message "ファイル圧縮中です。使ってるファイルは消さないでね。")
            ))
        )
    )
    (Ufm-refresh)
    )

(defun Ufm-unpack()
    "ファイルの解凍"
    (if Ufm-mark-list ()(setq Ufm-mark-list (list Ic-IDX)))
    (mapcar (function (lambda(A)(let ((FILENAME (Ufm-name 'dir A)))
	    (catch 'BREAK (let (DO(I 0)(LEN (length Ufm-exp)))
			(while (< I LEN)(let ((TMP (nth I Ufm-exp)))
		        (if (condition-case nil (string-match (car TMP) FILENAME)(error))		;強制的にバックグラウンドにする(綺麗じゃないなぁ)
;					(if (setq DO(nth 3 TMP))(progn (if (eq 'Ufm-macro (car-safe DO))(U-modq DO 1 (concat (nth 1 DO)" %BG")))(eval DO)(throw 'BREAK t)))))
					(if (setq DO(nth 3 TMP))(progn (eval DO)(throw 'BREAK t)))))
			    (setq I (1+ I)))
	)))))Ufm-mark-list)
	(Ufm-refresh)
	)

;-------------------------------------------------------------------------------------------------
;;●タグ
(defun Ufm-mark-sub (&optional IDX FORCE)       ; トグルか、ＯＮ ＯＦＦ
    (if IDX ()(setq IDX Ic-IDX))
	(let ((N(U-htn Ufm-mark-list IDX)))(if (or (eq 'off FORCE)(and (null FORCE) N))
    ;消す
    (progn  (if N (U-del Ufm-mark-list N))
        (let* (
            (FILE   (Ic-idx 5 IDX))
            (ATTR   (file-attributes (concat Ufm-dir FILE)))
            (ATT    (substring (nth 8 ATTR) 0 4))
            (LIST   (Ufm-color ATTR))
            )
		(setcdr (nthcdr 5 (nth IDX Ufm-table)) LIST)
        ))
    ;付ける
    (if (equal ".." (Ufm-name nil IDX))()        ; . .. にはタグつけない
        (if N ()(setq Ufm-mark-list (append Ufm-mark-list (list IDX))))             ; IDX を Ufm-mark-llist に登録
		(setcdr (nthcdr 5 (nth IDX Ufm-table))
			(list (list 
                '(0 0 2 'R-Red)
                (list 0 2 (- Ufm-filength 3) (let ((F (nth 3 (car(Ic-idx 7 IDX)))))(cond 
                    ((eq F 'C-Blue)'R-Blue)
                    ((eq F 'C-Green)'R-Green)
                    ((eq F 'C-Yellow)'R-Yellow)
                    ((eq F 'C-Purple)'R-Purple)
                    )))
                (list 0 (- Ufm-filength 3) Ufm-filength 'R-Red)
                )													; 6 カーソル位置
			(list (list 0 0 Ufm-filength 'R-Red)))	; 7 カーソルはずれ

        ))
    )))

(defun Ufm-mark ()                  ; タグ(SPC)
    "タグをつける(ファイルを一括して操作するためのマーク)"
    (Ufm-mark-sub)
    (Ic-down)
    )

(defun Ufm-mark-all ()              ; 全てタグ(M-SPC)
    "全てにタグを付けるか消すかする"
    (let(A(i 0)(l (length Ufm-table)))(if Ufm-mark-list(progn
        (while (< i l)(Ufm-mark-sub i 'off)(setq i (1+ i)))(message"全てのタグを消しちゃった"));何か登録されていたら、全て消去
        (while (< i l)(Ufm-mark-sub i 'on )(setq i (1+ i)))(message"全てにタグを付けたぞ");真っ白なら、全部タグする
    )))

(defun Ufm-mark-toggle ()           ; タグトグル(C-SPC)
    "全てのタグを反転"
    (message (documentation 'Ufm-mark-toggle))
    (let(A(len (length Ufm-table))(i 0))(while (< i len)(Ufm-mark-sub i)(setq i (1+ i)))))

(defun Ufm-mark-regexp ()           ; 正規表現タグ(C-M-SPC)
    "正規表現タグ(ファイル名の正規表現でタグをつける)"
    (let(A(i 0)(REGEXP (read-from-minibuffer "正規表現タグ : ")))
        (while (< i (length Ufm-table))
        (let ((FILE (Ufm-name nil i)))(if (and (string-match REGEXP FILE);(not (equal "." FILE))
				(not (equal ".." FILE)))
            (Ufm-mark-sub i 'on)
            ))
        (setq i (1+ i)))
        ))
(defvar Ufm-mark-reg-hist '("d" "-" "l" ".rwx"))
(defun Ufm-mark-regexp2 ()          ; パーミッション指定タグ
    "パーミッション正規表現タグ(ex dr..)"
    (let(A(i 0)(REGEXP (read-from-minibuffer "パーミッションタグ : " "d" nil nil 'Ufm-mark-reg-hist)))
        (while (< i (length Ufm-table))
        (let* ((FILE (Ufm-name nil i))(LINE (nth 8 (file-attributes (concat Ufm-dir FILE)))))
            (if (and (string-match (concat "^" REGEXP) LINE);(not (equal "." FILE))
				(not (equal ".." FILE)))
                (Ufm-mark-sub i 'on)
            ))
        (setq i (1+ i)))
        ))
;-------------------------------------------------------------------------------------------------
;;●スーパータグ

(defvar Ufm-super-mark nil)     ; スーパータグは終わっても有効
(defvar Ufm-super-mark-stack nil)
(defvar Ufm-super-option '(
    (title "スーパータグ (f4:登録 d: 消去 e:編集 ret:閲覧 \\:移動) TAB:登録 C-TAB:全消去 C-f1:キボードマクロ実行 E:全て編集 f5:保存箱")
    (keymap Ufm-super-map)
;    (refresh (use-local-map Ufm-super-menu-map))
    ))

(defun Ufm-super-refresh()
    (setq Ufm-super-table (mapcar (function (lambda (A) (list A))) Ufm-super-mark))
    )

(defvar Ufm-super-map (make-keymap))
;(define-key Ufm-super-map "q"				'Ufm-fmenu-quit			)
;(define-key Ufm-super-map Ufm-quit-key		'Ufm-fmenu-quit			)
;(define-key Ufm-super-map [menu-bar quit]	'Ufm-fmenu-quit			)
(define-key Ufm-super-map Ic-return-key		'Ufm-super-return		)
(define-key Ufm-super-map [13]				'Ufm-super-return		)
(define-key Ufm-super-map "\C-x\C-m"		'Ufm-super-mv			)
(define-key Ufm-super-map "\C-x\C-c"		'Ufm-super-cp			)
(define-key Ufm-super-map "\C-x\C-d"		'Ufm-super-delf			)
(define-key Ufm-super-map "d"				'Ufm-super-delete		)
(define-key Ufm-super-map "D"				'Ufm-super-delete		)
(define-key Ufm-super-map "e"				'Ufm-super-edit			)
(define-key Ufm-super-map [f5]				'Ufm-super-stock		)
(define-key Ufm-super-map [f1]				'Ufm-super-help			)
(define-key Ufm-super-map "E"				'Ufm-super-edit-all		)
(define-key Ufm-super-map "\\"				'Ufm-super-go			)
(define-key Ufm-super-map "g"				'Ufm-super-grep			)
(define-key Ufm-super-map "?"				'Ufm-super-help			)
(define-key Ufm-super-map "\C-x\C-s"		'Ufm-env-save			)
(define-key Ufm-super-map [f10]				'Ufm-env-save			)
(define-key Ufm-super-map [(control f1)]    'Ufm-super-kbdmacro		)
(define-key Ufm-super-map "\C-x\C-f"		'Ufm-super-load			)
(define-key Ufm-super-map [delete]			'Ufm-super-push			)
(define-key Ufm-super-map [(control tab)]	'Ufm-super-cls			)
(define-key Ufm-super-map [insert]			'Ufm-super-pop			)
(define-key Ufm-super-map [f4]				'Ufm-super-ing			)
(define-key Ufm-super-map [tab]				'Ufm-super-ing			)
;(defvar Ufm-super-menu-map (U-no-menubar-keymap))

(defun Ufm-super-load()
	(Ufm-env-load)
	(Ufm-super-refresh)
	)

(defun Ufm-super-delf()
	"全てのファイルを消去します"
	(if (and(y-or-n-p "本当にスーパータグを付けたファイルをみぃ〜んな消していいの？")
		(y-or-n-p "ほんとにほんとにいいの？"))(progn
	(mapcar (lambda (A)(Ufm-delf A)) Ufm-super-mark)
	(setq Ufm-super-mark nil)
	(Ufm-super-refresh)
	)))

(defun Ufm-super-cp()
	"全てのファイルをコピーします"
	(apply 'Ufm-copy nil Ufm-super-mark)
	)

(defun Ufm-super-mv()
	"全てのファイルを移動します"
	(if (y-or-n-p "スーパータグを付けたファイルをみぃ〜んな移動しちゃうよ？")(progn
	(apply 'Ufm-move nil nil Ufm-super-mark)
	(setq Ufm-super-mark nil)
	(Ufm-super-refresh)
	)))

(defun Ufm-super-grep()
	"全てのファイルに対して文字列検索をかける"
	(Ufm-grep-mode nil t)
	)

(defun Ufm-super-edit()
	"ファイルを編集"
	(Ic-quit (cons 'edit (Ic-idx 0)))
	)

(defun Ufm-super-pop()
	"スーパータグをPOP"
	(U-ins  Ufm-super-mark Ic-IDX (car Ufm-super-mark-stack))
	(U-del Ufm-super-mark-stack 0)
	(Ufm-super-refresh)
	)

(defun Ufm-super-push()
	"スーパータグをPUSH"
	(U-ins  Ufm-super-mark-stack 0 (nth Ic-IDX Ufm-super-mark))
	(U-del Ufm-super-mark Ic-IDX)
	(Ufm-super-refresh)
	)

(defun Ufm-super-ing()
	"タグを付ける"
	(Ufm-super-mark)(Ufm-super-refresh)(Ic-refresh)
	)

(defun Ufm-super-stock()
	"リストを保存します (f5 の保存箱に保存されます)"
	(Ic 'Ufm-stag-table 'Ufm-stag-option)
	(Ufm-super-refresh)(Ic-refresh)
	)

(defun Ufm-super-delete()
	"タグを消去"
	(U-del Ufm-super-mark Ic-IDX)(Ufm-super-refresh)
	)


(defun Ufm-super-menu()
    "タグ操作(メニューが出ます)"
    (Ufm-super-refresh)
    (let* ((Ufm-IDX Ic-IDX)(DIR (Ic 'Ufm-super-table 'Ufm-super-option)))
        (cond
            ((stringp DIR)(setq Ufm-dir (car (file-namae DIR)))(setq Ufm-save-cur (cdr (file-namae DIR)))(Ufm-refresh))
            ((eq 'edit (car DIR))(Ufm-edit-sub 0 0 (cdr DIR))(Ic-quit))
            )
    ))

(defun Ufm-super-mark(&optional f)
    "スーパータグ(ディレクトリ間で有効なタグ)"
    (setq Ic-refresh nil)
    (message "スーパータグをにつけました。")
	(if (or f (not Ufm-mark-list))
		(setq Ufm-super-mark (append Ufm-super-mark (list (if f f (Ufm-name 'dir)))))
		(let ((I 0)(LEN (length Ufm-mark-list)))(while (< I LEN)
	    (let* ((FILE(Ufm-name 'dir (nth I Ufm-mark-list)))(ATT (nth 0 (file-attributes (file-truename FILE)))))
	        (setq Ufm-super-mark (append Ufm-super-mark (list (concat FILE (if ATT"/")))))
	        (setq I (1+ I))
			)))
	)(setq Ufm-super-mark(U-list-itii Ufm-super-mark)))

(defun Ufm-super-cls()
    "スーパータグぜーんぶ消去したぜ"
    (message (documentation 'Ufm-super-cls))
    (setq Ufm-super-mark nil)
	(Ufm-super-refresh)
	(Ic-refresh)(setq Ic-refresh nil)
    )

(defun Ufm-super-return ()
	"ディレクトリはそこへ移動、ファイルなら閲覧"
    (let* ((PATH(Ic-idx 0))(ATT (file-attributes (file-truename PATH))))
        (if (nth 0 ATT)
            ;ディレクトリは移動
            (Ic-quit PATH)
            ;ファイルは閲覧
            (Ufm-view PATH))
    ))

(defun Ufm-super-go ()
	"ファイルの指し示す場所に移動"
	(Ic-quit (Ic-idx 0))
	)

(defun Ufm-super-kbdmacro ()
	"全てに対してキーボードマクロを実行"
	(message (documentation 'Ufm-super-kbdmacro))
	(setq Ufm-super-mark(U-list-itii Ufm-super-mark))
	(mapcar (lambda (F)(switch-to-buffer (find-file F))(condition-case nil (execute-kbd-macro last-kbd-macro 0)(error)))Ufm-super-mark)
	)

(defun Ufm-super-edit-all ()
	"全てを編集"
	(message (documentation 'Ufm-super-kbdmacro))
	(setq Ufm-super-mark(U-list-itii Ufm-super-mark))
	(mapcar (lambda (F)(switch-to-buffer (find-file F)))Ufm-super-mark)
	)

(defun Ufm-super-help ()
	"ヘルプ"
	(select-window Ic-win-wine)
	(delete-other-windows)
	(erase-buffer)
	(insert (concat
	"スーパータグ キーバインド表 Ufm (C) 1998 Usuda Hiroshi (終了:q)\n\n"
	(Ufm-keystr 'Ufm-super-ing			Ufm-super-map)
	(Ufm-keystr 'Ufm-super-delete		Ufm-super-map)
	(Ufm-keystr 'Ufm-super-return		Ufm-super-map)
	(Ufm-keystr 'Ufm-super-edit			Ufm-super-map)
	(Ufm-keystr 'Ufm-super-edit-all		Ufm-super-map)
	(Ufm-keystr 'Ufm-super-grep			Ufm-super-map)
	(Ufm-keystr 'Ufm-super-cp			Ufm-super-map)
	(Ufm-keystr 'Ufm-super-mv			Ufm-super-map)
	(Ufm-keystr 'Ufm-super-delf			Ufm-super-map)
	(Ufm-keystr 'Ufm-super-go			Ufm-super-map)
	(Ufm-keystr 'Ufm-super-kbdmacro		Ufm-super-map)
	(Ufm-keystr 'Ufm-super-stock		Ufm-super-map)
	(Ufm-keystr 'Ufm-super-help			Ufm-super-map)
	(Ufm-keystr 'Ufm-env-save			Ufm-super-map "スーパータグをファイルへ保存")
	(Ufm-keystr 'Ufm-super-pop			Ufm-super-map)
	(Ufm-keystr 'Ufm-super-push			Ufm-super-map)
	(Ufm-keystr 'Ic-quit				Ic-mode-map "スーパータグメニューを終了")
	"\n≪ノウハウ≫\n\n"
	"	●キーバインドを変更するには以下のように ~/.emacs の最後に書きます\n"
	"		(define-key Ufm-super-map [(meta h)]	'Ufm-super-go)"
	))(goto-char 1)(Ufm-uView)
	)

;-----
;●スーパータグの保存箱

;(defvar Ufm-stag-list	nil)
(defvar Ufm-stag-table	nil)
(defvar Ufm-stag-option '(
	(title "スーパータグのリスト D:削除 TAB:現在のスーパータグを登録 f2:タイトルを付ける")
	(refresh	(progn (Ic-refresh)))
	(after-exec	(progn (Ic-refresh)))
	(keymap Ufm-stag-option-map)
;	(refresh (use-local-map Ufm-stag-option-menu-map))
	))

(defvar Ufm-stag-option-map (make-keymap))
;(define-key Ufm-stag-option-map "q"					'Ufm-fmenu-quit)
;(define-key Ufm-stag-option-map Ufm-quit-key		'Ufm-fmenu-quit)
;(define-key Ufm-stag-option-map [menu-bar quit]		'Ufm-fmenu-quit)
(define-key Ufm-stag-option-map "D"					'Ic-menu-delete)
(define-key Ufm-stag-option-map "\C-x\C-s"			'Ufm-env-save)
(define-key Ufm-stag-option-map [f10]				'Ufm-env-save)
(define-key Ufm-stag-option-map "\C-x\C-f"			'Ufm-env-load)
(define-key Ufm-stag-option-map [tab]				'Ufm-stag-entry)
(define-key Ufm-stag-option-map [f5]				'Ufm-stag-entry)
(define-key Ufm-stag-option-map [(meta f1)]			'Ic-menu-delete)
(define-key Ufm-stag-option-map [(control f1)]		'Ic-menu-delete)
(define-key Ufm-stag-option-map [delete]			'Ic-menu-push)
(define-key Ufm-stag-option-map [insert]			'Ic-menu-pop)
(define-key Ufm-stag-option-map [f2]				'Ic-menu-title)
(define-key Ufm-stag-option-map [return]			'Ufm-stag-ret)
;(defvar Ufm-stag-option-menu-map (U-no-menubar-keymap))

(defun Ufm-stag-disp()
	(mapconcat (lambda (A)A) (Ic-idx 5) "\n")
	)

(defun Ufm-stag-entry()
	(Ic-idx nil 0 nil 'ins (list nil nil '(Ufm-stag-disp) nil nil Ufm-super-mark))
	)

(defun Ufm-stag-ret()
	(setq Ufm-super-mark (Ic-idx 5))
	(Ic-quit)
	)
;-------------------------------------------------------------------------------------------------
;;●マクロメニュー

(defun Ufm-macro-menu (file table)
	"Ufm マクロメニュー"
    (setq Ufm-macro-file     file)       ; ファイル名
    (setq Ufm-macro-table    table)      ; トップテーブルシンボル
    (setq Ufm-IDX			Ic-IDX)			; 保存(重要だ)
    (setq Ufm-macflg nil)
    (if (boundp Ufm-macro-table)()
		(if (file-exists-p Ufm-macro-file)
			(load-file Ufm-macro-file)
			(set Ufm-macro-table nil)))

	(Ic-specify-node Ufm-macro-table 'Ufm-macro-option)
    )


(defvar Ufm-macflg          nil)        ; 実行した後に戻るか

(defvar Ufm-macro-deflist '(list
    '(if (eq 'Ufm-macro (car-safe (Ic-idx 1)))(car (cdr (Ic-idx 1))))       ;[0]表題の文字列
    nil                                                                     ;[1]実行するもの
    '(let (                                                                 ;[2]表示するもの
        (PERL (condition-case nil (car (nth 1 (nth 2 (Ic-idx 1))))(error)))
        (STR (car-safe (cdr-safe (Ic-idx 1))))
        )
        (if (stringp PERL)PERL
            (if (stringp STR)STR)
           )
        )
    ))

;●マクロメニューヘルプ
(defun Ufm-macro-help ()
	"Ufm マクロヘルプ"
	(select-window Ic-win-wine)
	(delete-other-windows)
	(erase-buffer)
	(insert (concat
	"マクロ キーバインド表 Ufm (C) 2001 Usuda Hiroshi (終了:q)\n"
	 "\n\tこのマクロ集は、 " Ufm-macro-file " にセーブされます。\n"

	"\n\n<<基本操作>>\n\n"
	(Ufm-keystr 'Ufm-macro-ret			Ufm-macro-map)
	(Ufm-keystr 'Ufm-macro-quit			Ufm-macro-map)
	(Ufm-keystr 'Ufm-macro-add			Ufm-macro-map)
	(Ufm-keystr 'Ic-menu-delete			Ufm-macro-map)
	"\n\n<<マクロの登録関連>>\n\n"
	(Ufm-keystr 'Ufm-macro-ent			Ufm-macro-map)
	(Ufm-keystr 'Ufm-macro-macro-del	Ufm-macro-map)
	(Ufm-keystr 'Ufm-macro-title		Ufm-macro-map)
	(Ufm-keystr 'Ufm-macro-title-del	Ufm-macro-map)
	(Ufm-keystr 'Ufm-macro-moji			Ufm-macro-map)
	(Ufm-keystr 'Ufm-macro-moji-del		Ufm-macro-map)
	"\n\n<<高度な機能>>\n\n"
	(Ufm-keystr 'Ufm-script-ent			Ufm-macro-map)
	(Ufm-keystr 'Ufm-script-del			Ufm-macro-map)
	(Ufm-keystr 'Ufm-macro-sexp			Ufm-macro-map)
	(Ufm-keystr 'Ufm-macro-dsexp		Ufm-macro-map)
	"\n\n<<セーブ>>\n\n"
	(Ufm-keystr 'Ufm-macro-save			Ufm-macro-map)
	(Ufm-keystr 'Ufm-macro-load			Ufm-macro-map)
	(Ufm-keystr 'Ic-menu-push			Ufm-macro-map)
	(Ufm-keystr 'Ic-menu-pop		    Ufm-macro-map)
	"\n\n<<ノード>>\n\n"
	(Ufm-keystr 'Ufm-macro-node			Ufm-macro-map)
	(Ufm-keystr 'Ufm-macro-node-del		Ufm-macro-map)
	(Ufm-keystr 'Ic-next-node			Ufm-macro-map)
	(Ufm-keystr 'Ic-prev-node			Ufm-macro-map)
	"\n\n<<便利な機能>>\n\n"
	(Ufm-keystr 'Ufm-disp-win			Ufm-macro-map)
	(Ufm-keystr 'Ic-menu-short			Ufm-macro-map)
	(Ufm-keystr 'Ic-menu-keybind		Ufm-macro-map)
	(Ufm-keystr 'Ufm-save-win			Ufm-macro-map)
	"\n\n<<その他>>\n\n"
	(Ufm-keystr 'Ufm-macro-help			Ufm-macro-map)
	(Ufm-keystr 'Ic-toggle-tree			Ufm-macro-map)
	"\n≪ノウハウ≫\n\n"
	"	(１)キーバインドを変更するには以下のように ~/.emacs の最後に書きます\n"
	"		(define-key Ufm-macro-map [(meta h)]	'Ufm-macro-)"
	"\n\n--------------------------------------------------------------------------------\n●マクロの書き方\n"
	(documentation 'Ufm-macro)
	))(goto-char 1)(Ufm-uView)
	)

;-------------------------------------------------------------------------------------------------
;;●マクロキーバインド
;
;初期段階で、は以下のようなＳ式が設定されている
;
;
;[表題文字列 Ic-idx 0]  list[0] ==  'Ufm-macro  の時にはその文字列がタイトルになる
;(if (eq 'Ufm-macro (car-safe (Ic-idx 1)))
;   (car (cdr (Ic-idx 1)))
;   )
;
;[表示文字列 Ic-idx 2]  list[1] == 文字列       の時にはその文字列が表示される
;   '(let (
;       (PERL (car-safe (car-safe (cdr-safe (Ic-idx 1)))))
;       (STR (car-safe (cdr-safe (Ic-idx 1))))
;       )
;       (if (stringp PERL)PERL(if (stringp STR)STR)))
;

(defvar Ufm-macro-option '(
    (title "F1 追加 F2 表題 F3 マクロ F4 解説 ? ヘルプ")
    (wink 3)(short-cut)(short-disp)
    (keymap Ufm-macro-map)
    (tree)
    (refresh (progn
		(use-local-map Ufm-macro-menu-map)
        ))
    ))
(defvar Ufm-macro-map (make-keymap))

;要素追加例
(define-key Ufm-macro-map [f1]								'Ufm-macro-add		)
(define-key Ufm-macro-map [menu-bar add]					'Ufm-macro-add		)
(define-key Ufm-macro-map [(meta f1)]						'Ic-menu-delete		)
(define-key Ufm-macro-map [(control f1)]					'Ic-menu-delete		)	; 削除
(define-key Ufm-macro-map [menu-bar del]					'Ic-menu-delete		)	; 削除
(define-key Ufm-macro-map "\C-x\C-d"						'Ic-menu-delete		)	; 削除
(define-key Ufm-macro-map [delete]							'Ic-menu-push		)	; ＰＵＳＨ
(define-key Ufm-macro-map [insert]							'Ic-menu-pop		)	; ＰＯＰ
;一般
(define-key Ufm-macro-map [f2]								'Ufm-macro-title	)	; 表題
(define-key Ufm-macro-map [menu-bar title]					'Ufm-macro-title	)	; 表題
(define-key Ufm-macro-map [(control f2)]					'Ufm-macro-title-del)	; 表題の削除
(define-key Ufm-macro-map [f3]								'Ufm-macro-ent		)	; マクロ登録
(define-key Ufm-macro-map [menu-bar macro]					'Ufm-macro-ent		)	; マクロ登録
(define-key Ufm-macro-map [(control f3)]					'Ufm-macro-macro-del)	; マクロ削除
(define-key Ufm-macro-map [(meta f3)]						'Ufm-macro-sexp		)	; Ｓ式直接入力
(define-key Ufm-macro-map [menu-bar high list]				'Ufm-macro-sexp		)	; Ｓ式直接入力
(define-key Ufm-macro-map [end]								'Ufm-macro-moji-del	)	; 解説文字の削除
(define-key Ufm-macro-map [home]							'Ufm-macro-moji		)	; 解説
(define-key Ufm-macro-map [f4]								'Ufm-macro-moji		)	; 解説
(define-key Ufm-macro-map [menu-bar exp]					'Ufm-macro-moji		)	; 解説
(define-key Ufm-macro-map [(meta f4)]						'Ufm-macro-dsexp	)	; 解説 Ｓ式
(define-key Ufm-macro-map [menu-bar high dlisp]				'Ufm-macro-dsexp	)	; 解説 Ｓ式
(define-key Ufm-macro-map [(control f4)]					'Ufm-macro-moji-del	)	; 解説文字の削除
(define-key Ufm-macro-map [menu-bar high del4]				'Ufm-macro-moji-del	)	; 解説文字の削除
(define-key Ufm-macro-map [(control f5)]					'Ufm-script-del		)	; スクリプトの削除
(define-key Ufm-macro-map [menu-bar high del5]				'Ufm-script-del		)	; スクリプトの削除
(define-key Ufm-macro-map [f5]								'Ufm-script-ent		)	; スクリプトの登録
(define-key Ufm-macro-map [menu-bar scr]					'Ufm-script-ent		)	; スクリプトの登録
(define-key Ufm-macro-map [(meta f5)]						'Ufm-script-ent-sub	)	; スクリプトの登録
;その他
(define-key Ufm-macro-map [f10]								'Ufm-macro-save		)
(define-key Ufm-macro-map "\C-x\C-s"						'Ufm-macro-save		)
(define-key Ufm-macro-map [menu-bar env save]				'Ufm-macro-save		)
(define-key Ufm-macro-map "\C-x\C-f"						'Ufm-macro-load		)
(define-key Ufm-macro-map [menu-bar env load]				'Ufm-macro-load		)
(define-key Ufm-macro-map [right]							'Ic-next-node		)
(define-key Ufm-macro-map [left]							'Ic-prev-node		)
(define-key Ufm-macro-map Ic-return-key						'Ufm-macro-ret		)
(define-key Ufm-macro-map [13]								'Ufm-macro-ret		)
(define-key Ufm-macro-map [backspace]						'Ic-prev-node		)
(define-key Ufm-macro-map "q"								'Ufm-macro-quit		)
(define-key Ufm-macro-map [menu-bar quit]					'Ufm-macro-quit		)
(define-key Ufm-macro-map [f6]								'Ufm-macro-node		)	; ノード登録
(define-key Ufm-macro-map [menu-bar node]					'Ufm-macro-node		)	; ノード登録
(define-key Ufm-macro-map [(meta f6)]						'Ic-toggle-tree		)
(define-key Ufm-macro-map [(control f6)]					'Ufm-macro-node-del	)	; ノード抹消
(define-key Ufm-macro-map [f7]								'Ic-menu-short		)	; ショートカット登録
(define-key Ufm-macro-map [menu-bar short]					'Ic-menu-short		)	; ショートカット登録
(define-key Ufm-macro-map [f8]								'Ic-menu-keybind	)	; Ufmコマンド登録
(define-key Ufm-macro-map [menu-bar high key]				'Ic-menu-keybind	)	; Ufmコマンド登録
(define-key Ufm-macro-map "?"								'Ufm-macro-help		)
(define-key Ufm-macro-map "\C-h"							'Ufm-macro-help		)
(define-key Ufm-macro-map [menu-bar help]					'Ufm-macro-help		)
(define-key Ufm-macro-map "y"								'Ufm-disp-win		)
(define-key Ufm-macro-map [menu-bar enc show]				'Ufm-disp-win		)
(define-key Ufm-macro-map "Y"								'Ufm-save-win		)	; セーブする
(define-key Ufm-macro-map [menu-bar enc rsave]				'Ufm-save-win		)	; セーブする

(defvar Ufm-macro-menu-map (U-no-menubar-keymap))
(define-key Ufm-macro-menu-map [menu-bar files]			'undefined)		;global-map の定義を上書きする
(define-key Ufm-macro-menu-map [menu-bar tools]			'undefined)
(define-key Ufm-macro-menu-map [menu-bar edit]			'undefined)
(define-key Ufm-macro-menu-map [menu-bar search]		'undefined)
(define-key Ufm-macro-menu-map [menu-bar help-menu]		'undefined)
(define-key Ufm-macro-menu-map [menu-bar options]		'undefined)
(define-key Ufm-macro-menu-map [menu-bar buffer]		'undefined)
(define-key Ufm-macro-menu-map [menu-bar mule]			'undefined)

(define-key Ufm-macro-menu-map [menu-bar quit		]		'("Quit"			. quit))
(define-key Ufm-macro-menu-map [menu-bar help		]		'("Help"			. help))
(define-key Ufm-macro-menu-map [menu-bar env		]		(cons "Env" (make-sparse-keymap "env")))
(define-key Ufm-macro-menu-map [menu-bar env rsave	]		'("Save Result"		. rsave))
(define-key Ufm-macro-menu-map [menu-bar env show	]		'("Show Result"		. show))
(define-key Ufm-macro-menu-map [menu-bar env save	]		'("Save"			. save))
(define-key Ufm-macro-menu-map [menu-bar env load	]		'("Load"			. load))
(define-key Ufm-macro-menu-map [menu-bar high		]		(cons "HighPower" (make-sparse-keymap "high")))
(define-key Ufm-macro-menu-map [menu-bar high del5	]		'("Delete Script"			. del5))
(define-key Ufm-macro-menu-map [menu-bar high del4	]		'("Delete Explain"			. del4))
(define-key Ufm-macro-menu-map [menu-bar high lisp	]		'("Lisp"			. lisp))
(define-key Ufm-macro-menu-map [menu-bar high dlisp	]		'("Explain-Lisp"		. dlisp))
(define-key Ufm-macro-menu-map [menu-bar high key	]		'("Macro-Keybind"		. key))
(define-key Ufm-macro-menu-map [menu-bar short		]		'("ShortCut"		. short))
(define-key Ufm-macro-menu-map [menu-bar node		]		'("Node"			. node))
(define-key Ufm-macro-menu-map [menu-bar scr		]		'("Script"			. scr))
(define-key Ufm-macro-menu-map [menu-bar exp		]		'("Explain"			. exp))
(define-key Ufm-macro-menu-map [menu-bar macro		]		'("Macro"			. macro))
(define-key Ufm-macro-menu-map [menu-bar title		]		'("Title"			. title))
(define-key Ufm-macro-menu-map [menu-bar del		]		'("Del"				. del))
(define-key Ufm-macro-menu-map [menu-bar add		]		'("Add"				. add))

;-------------------------------------------------------------------------------------------------
;●マクロの実行
(defun Ufm-macro-ret()
	"マクロ実行"
	(if (Ic-idx 1)
		;マクロの実行
		(progn (condition-case nil (eval (Ic-idx 1))(quit (ding)(message "やっぱやぁ〜めた")(setq Ufm-macflg t)))
			(if Ufm-macflg (setq Ufm-macflg nil)(Ufm-macro-quit));メニューを出る
			)
		;マクロが設定されていなければ次のノードへ
		(if (Ic-idx 10)(Ic-prev-node)(Ic-next-node))
	))

;●マクロメニューを出る時には必ずこれを実行しましょう。'Ic-prev-node を別にキーバインドしていて実行されると困ったことになるけれど・・・いかん！
(defun Ufm-macro-quit ()
	"メニューを終了"
	(Ic-prev-node nil t)
	(setq Ufm-IDX nil)	;ここが重要
	(setq Ufm-mark-list nil) ;マークは消さないと不都合あり。Ufm-refresh が Ic-mark-list を認識すればいいのだけれど。ただし、ファイル構成が変わっているかも。
	(if (and (window-live-p Ic-win-wine)(get-buffer Ic-name-wine))(progn
		(select-window Ic-win-wine)
		(switch-to-buffer Ic-name-wine)
		(erase-buffer)
		))
	(setq Ufm-save-cur Ufm-IDX)
	(Ufm-refresh)
	(setq Ic-refresh Ufm-standard-pm)
	)

(defvar Ufm-standard-pm " *Ufm-macro-process-buff* ") ;マクロの標準出力先バッファ名

;;●メニュー定義
(defun Ufm-macro-add()
	"項目を追加"
	(Ic-idx nil nil nil 'ins (eval Ufm-macro-deflist))
	)

(defun Ufm-macro-dsexp ()	; 解説Ｓ式
	"項目の解説Ｓ式の登録"
	(message "マクロ解説(ＬＩＳＰ式)")
	(switch-to-buffer Ic-name-wine)
	(Ic-table-s 2)
	)

(defun Ufm-macro-save()
	"Ufm のマクロをセーブ"
	(Ic-table-save Ufm-macro-file Ufm-macro-table 3)	; セーブ
	)

(defun Ufm-macro-load()
	"Ufm のマクロをロード"
	(load-file Ufm-macro-file)
	)


;●Ufm-macro の登録
(defun Ufm-macro-ent ()
	"マクロの登録"
	(save-window-excursion
    (select-window Ic-win-wine)
    (erase-buffer)
    (insert (documentation 'Ufm-macro-parse))
    (goto-char 0)
    (delete-other-windows)
    (let ((PROMPT)(STR)(LIST (Ic-idx 1)))
        (if (eq 'Ufm-macro (nth 0 LIST))(setq PROMPT (nth 1 LIST)))                                 ;すでに登録済の時
        (setq STR (read-from-minibuffer "マクロ登録 : " (if PROMPT PROMPT '("echo %TAG". 1))))      ;マクロの入力
        (if (equal "" STR)nil
            (if (eq 'Ufm-macro (nth 0 LIST))(U-modq LIST 1 STR)(Ic-idx 1 nil nil t (list 'Ufm-macro STR)))  ;未入力の時
        ))
    ))

(defun Ufm-macro-macro-del ()
	"マクロの削除"
    (message "マクロを削除しました")
    (Ic-idx 1 nil nil t nil)
    )


;●スクリプトの登録
(defun Ufm-script-ent ()
	"スクリプトの登録(ディフォルトは Perl)"
	(if (Ic-idx 1)()(Ic-idx 1 nil nil t (list 'Ufm-macro "perl -e %ARG %TAG")))
	(Ufm-script-ent-sub 0)
	)


;●解説文字の登録
(defun Ufm-macro-moji ()
	"マクロ解説文字列の登録"
    (message "マクロ解説文字列")
    (let ((STR (Ic-table-str)))
    (Ic-idx 2 nil nil t (if (equal STR "")(nth 2 (eval Ufm-macro-deflist)) STR))
    ))

(defun Ufm-macro-moji-del ()
	"マクロ解説文字列の削除"
    (message "解説文字を削除しました")  ;Ufm-macro ならばマクロ文字列を表示させる
    (Ic-idx 2 nil nil  t (nth 1 (nth 3 Ufm-macro-deflist)))
    )

;●タイトルの設定
(defun Ufm-macro-title ()
	"項目のタイトルの設定"
    (Ic-idx 0 nil nil t
        (let ((STR (read-from-minibuffer "表題 : " (if (stringp (Ic-idx 0))(Ic-idx 0)))))
            (if (equal "" STR) (nth 0 (eval Ufm-macro-deflist)) STR))
        ))
(defun Ufm-macro-title-del ()
	"項目のタイトルの削除"
    (message "タイトルを削除しました")  ;Ufm-macro ならばマクロ文字列を表示させる
    (Ic-idx 0 nil nil t  (nth 0 (eval Ufm-macro-deflist)))
    )


;●Ｓ式の登録
(defun Ufm-macro-sexp ()
	"Ｓ式関数マクロの登録"
	(save-window-excursion
    (select-window Ic-win-wine)
    (erase-buffer)
    (insert (documentation 'Ufm-macro))
    (goto-char 0)
    (delete-other-windows)
    (let ((S    (read-from-minibuffer "マクロ登録(ＬＩＳＰ式) : "
                (if (Ic-idx 1) (prin1-to-string(Ic-idx 1)) '("(Ufm-macro \"%TAG\")" . 13))
                nil t)))
        (if S (Ic-idx 1 nil nil t S))
    )))

;●ノードの設定
(defun Ufm-macro-node ()
	"下位ノードの作成"
    (Ic-idx 3 nil nil t (list (list "")))
    (Ic-idx 4 nil nil t 'Ufm-macro-option)
    )

(defun Ufm-macro-node-del ()
	"下位ノードの削除"
    (message "ノードを抹消しました")
    (Ic-idx 3 nil nil t nil)
    (Ic-idx 4 nil nil t nil)
    )

;●直接編集
(defun Ufm-macro-tyoku ()
	"マクロセーブファイルの直接編集"
	(find-file Ufm-macro-file)(setq Ic-keep-buffer t)(Ic-quit)
	)

;;●スクリプト引数
;
;   (Ic-idx 1)
;
;       に
;
;TAR:   (Ufm-macro "echo %TAG" (quote ("script1" "script2")))
;                                     ↑OLD
;
;
;   の形式で格納する。
;
;
;
;

(defun Ufm-script-ent-sub (&optional Y)
    ;Yは引数の
    (if Y ()(setq Y (string-to-number (Ufm-get-number "%ARG<n> Script Number [n]: " 0 0 100))))
    ;文字列のゲット
    (let* (TAR (STR  (Ic-table-str (nth Y (nth 1 (nth 2 (Ic-idx 1)))))))
        (if (Ic-idx 1)nil (Ic-idx 1 nil nil t (list 'Ufm-macro "perl -e %ARG %TAG")))
        (setq TAR (Ic-idx 1))
        (if (equal STR "")(setq STR nil))
        (if (or                         ;(Ufm-macro 云々 非func)の場合に
            (not (consp TAR))
            (functionp (nth 2 TAR))
            (not (eq 'Ufm-macro (car TAR)))
            )nil
        (if (eq 'quote (car-safe (nth 2 TAR))) nil (U-mod TAR 2 (list 'quote (list nil))))
        (U-modq (nth 1 (nth 2 TAR)) Y STR)
        )
    ))

(defun Ufm-script-del ()
	"スクリプトの削除"
    (if (and 
        (not(functionp (nth 2 (Ic-idx 1))))
        (eq 'Ufm-macro (nth 0 (Ic-idx 1)))
        (y-or-n-p "スクリプトを全て消去しちゃうよ？")
        )
        (U-del (Ic-idx 1) 2)
    ))

;;●Ufm でマクロをそのまま登録してしまう
(defun Ic-menu-keybind()
	"マクロをそのままキーバインド"
    (message "このコマンドをキーボードに割り当てます。キーを押してください")
    (let ((K (vector (read-event))))
    (define-key Ufm-map K (list 'lambda nil (Ic-idx 1)))
    (message(concat (prin1-to-string K) "にコマンドを割り当てました。"))
    ))



;------------------------------------------------------------------------------------------
;●新マクロ関数(超弩級スパゲッティー関数をちょっと改善)
;
;	マクロは次のような３段階をふんで処理される。
;
;		<第１段階>					<第２段階>					<第３段階>
;		Ufm-macro
;		文字列 → Ufm-macro-parse	→ Ufm-macro-do
;		メニュ → Ufm-macro-argm	→ Ufm-macro-do
;											→ Ufm-macro-co → Ufm-macro-last → 呼び出し
;
;		第１段階：マクロ文字列や引数メニューの定義リストの段階(他の形式を考えてもいいけど)
;
;			例
;			"echo --on [%TAG] %input<Prompt : ><initSTR>"
;			("echo" ("表題１"("説明文章")("する" "--on")("しない" "--off")) (tag "[" "]")
;
;		第２段階：入力などを受け付ける段階
;
;			("echo" (tag "pre" "suf" nil 0) (input "Prompt : " "initSTR" ...))
;
;		第３段階：タグやヒストリ等を実際のものに置き換えて、最終的なコマンド形態に変換できる段階。
;
;			("echo" ("-file1-" "-file2-" "-file3-") t (conc "'" "'" "file1" " " "file2"))
;
;		最終段階：コマンドラインそのもの
;
;			("echo" "file1" "--on")
;
;
(defun Ufm-macro (STR &optional FUNCTION &rest ARGS)
	(catch 'ARGM (let ((CMP (if (stringp STR)(Ufm-macro-parse STR)(Ufm-macro-argm STR))))
		(apply 'Ufm-macro-do CMP FUNCTION ARGS)
	)))

(defvar Ufm-macro-his-1 nil)    ;ファイル名入力のための汎用ヒストリ
(defvar Ufm-macro-his-2 nil)    ;汎用入力のための汎用ヒストリ

;------------------------------------------------------------------------------------------
;●引数メニュー テーブル作成機能付 (神楽坂タゴール 神楽坂寿司幸 神楽坂天孝)
;
; Ufm-macro-argm-value に追加して行く。
; メニューから入力するものインデックスを追加して、
; 後でテーブル参照しながら最後の値を作成する。
;
;(Ic-idx 5) は、次のようなリストである。
;
; (
; 0							何番目を選択中か
; ((0 0 10)(0 11 20))		１番目を選択した時のface idx
; ((0 0 12)(0 13 30))		２番目を選択した時のface idx
; ((0 0 11)(0 12 29))		３番目を選択した時のface idx
; ("題名"　("説明文章") ("要素名"　(input "" "")) ("要素名" (input "a" "")))
; )
;
;	(Ufm-macro-make5 a) には、項目引数にとってこのリストを作る。
;	faceを指定した場合には、(Ufm-macro-mk5col) を使う
;

(defun Ufm-macro-argm(LIST)
	(let (Ufm-macro-argm-value Ufm-macro-argm-table(I 0)(L (length LIST)))(while (< I L)(let ((a (nth I LIST)))
		; a には ("ファイル名グロブ" "説明文章"("ＯＮ" "--glob=ON")("ＯＦＦ" "--glob=OFF"))
		(cond
		;文字列か非選択項目の場合には
		((or (stringp a)(symbolp a)(symbolp (car-safe a)))
			(setq Ufm-macro-argm-value (append Ufm-macro-argm-value (list (if (consp a)
			(cond
			((eq (car a) 'file)  a)
			((eq (car a) 'tag)   a)
			((eq (car a) 'tags)  a)
			((eq (car a) 'ptag)  (list 'tag   (nth 1 a)(nth 2 a)(nth 3 a)t))
			((eq (car a) 'ptags) (list 'tags  (nth 1 a)(nth 2 a)(nth 3 a)t))
			((eq (car a) 'stag)  a)
			((eq (car a) 'stags) a)
			)
			a))))		; no 等を書く為に (list a) にしない。すれば、file 等が単独で書けるけど。
			)
		;その他のリスト形式ならばメニューに追加[input ifile 等]
		((consp a)(let (tmp)
		(setq Ufm-macro-argm-value (append Ufm-macro-argm-value (list (length Ufm-macro-argm-table))))
		(setq Ufm-macro-argm-table (append Ufm-macro-argm-table (list (list
		;[0]表示文字
		(Ufm-macro-make1 a)
		;[1]リターン[2]説明文章[3]次のノード[4]
		nil (car (nth 1 a)) nil nil 
		;[5] ユーザ領域
		(setq tmp (Ufm-macro-make5 a))
		;[6] 色
		(Ufm-macro-mk5col (nth 0 (cdr tmp)) '(R-Blue R-Red))		; カーソル位置の時には 表題は青で、入力領域は赤
		;[7] 色
		(Ufm-macro-mk5col (nth 0 (cdr tmp)) '(R-Yellow R-Red))	; カーソル位置の時には 表題は黄で、入力領域は赤
		))))))
		)(setq I (1+ I))))
	(if Ufm-macro-argm-table (let ((Ufm-IDX Ic-IDX))(Ic 'Ufm-macro-argm-table 'Ufm-macro-argm-option)))
	))
;------------------------------------------------------------------------------------------
;キーバインド
(defvar Ufm-macro-argm-map (make-keymap))
(define-key Ufm-macro-argm-map "q"			'Ufm-macro-argm-quit	)
(define-key Ufm-macro-argm-map [end]		'Ufm-macro-argm-return	)
(define-key Ufm-macro-argm-map "\\"			'Ufm-macro-argm-look	)		; セレクションにいれる(ディフォルトにしてもいいかな)
(define-key Ufm-macro-argm-map [return]		'Ufm-macro-argm-ret		)
(define-key Ufm-macro-argm-map [13]			'Ufm-macro-argm-ret		)
(define-key Ufm-macro-argm-map [left]		'Ufm-macro-argm-left	)
(define-key Ufm-macro-argm-map [right]		'Ufm-macro-argm-right	)

(defvar Ufm-macro-argm-option '(
	(title "引数メニュー   end:実行 \:引数閲覧")
	(keymap Ufm-macro-argm-map)
	(after-exec (Ufm-macro-argm-look t))
	))


;------------------------------------------------------------------------------------------
;table[5] のユーザ領域を作成する
;
; a			: ("ファイル名グロブ" "説明文章"("ＯＮ" "--glob=ON")("ＯＦＦ" "--glob=OFF"))
; NUM		: 選択中の項目
;symbolp の nil なら nil を返す版
(defun U-symbol-not-nilp(a)
	(if a (symbolp a))
	)
(defun Ufm-macro-make5(a &optional NUM)
	(let ((TT ;は (((0 4 18)) ((0 19 32))) など
		(let ((tmp (U-string-column (car a))))(mapcar (lambda(b)
			; b には ("ここから" input "Download URL : " "http://www." "" "" nil nil Ufm-macro-argm-wget)
			(cond 
			; input 等が有る場合
			((Ufm-macro-symp (car-safe (nth 1 b)))
				(list (list 0 
					(+ 1 tmp)
					(+ 1 (setq tmp (+ tmp (U-string-column (car b)))))
				)(list 0
					(+ 1 tmp)
					(+ 1 (setq tmp (+ tmp 1 (if (< 0 (length (nth 2 (nth 1 b)))) 
							(U-string-column (nth 2 (nth 1 b))) 1))))
				)))
			;単なる文字列
			(t (list (list 0 
				(+ 1 tmp)										; 表題＋１
				(setq tmp (+ tmp 1 (U-string-column (car b)) 0))
				)))
			))
		(nthcdr 2 a)))))
			(append (list (if NUM NUM 0)) TT (list a))
	))

;色情報 Ic-idx 7,8 を作成する
;A : ((0 1 2)(0 3 4)) 等
;B : (C-Red C-Blue) 等
(defun Ufm-macro-mk5col(A B)
	(let ((AL (length A))(i 0)ST)(while (< i AL)(setq ST (append ST (list (append (nth i A)(list (nth i B))))))(setq i (1+ i)))ST)
	)

;入力を受け付けるもの
(defun Ufm-macro-symp (B)(or
	(eq 'input B)
	(eq 'ifile B)
	(eq 'ifile+ B)
	(eq 'ifile- B)
	(eq 'inputs B)
	(eq 'i B)
	(eq 'idir B)
	(eq 'if B)
	(eq 'if+ B)
	(eq 'if- B)
	(eq 'is B)
	))

;table[1]の表題文字列を作成する
(defun Ufm-macro-make1(a)
	(concat (car a) " "(mapconcat (lambda (b)	;b := ("ファイル名 : " input "init")
		(concat (car b)(let ((B1 (nth 1 b)))(if (Ufm-macro-symp (car-safe B1))
			(if (< 0 (length (nth 2 (nth 1 b))))(nth 2 (nth 1 b))"*") "")))
		)
	(nthcdr 2 a) " ")
	))

;[returnの後]入力があった時のリフレッシュ関数
(defun Ufm-macro-argm-refresh (&optional IDX table KK)
	;KK は何番目の選択項目かを選んでいる
	;LIST には 項目	("表題"	"説明文字列" ("ファイル名 : " input "init")("あ" input "い"))
	(let* (
			(LIST (nth (1- (length (Ic-idx 5 IDX table))) (Ic-idx 5 IDX table)))
			(i5 (Ufm-macro-make5 LIST KK))
			)
	;表題
	(Ic-idx 0 IDX table t (Ufm-macro-make1 LIST))
	;ユーザ領域
	(Ic-idx 5 IDX table t i5)
	;色
	(Ic-idx 6 IDX table t (Ufm-macro-mk5col (nth KK (cdr i5)) '(R-Blue   R-Red)))
	(Ic-idx 7 IDX table t (Ufm-macro-mk5col (nth KK (cdr i5)) '(R-Yellow R-Red)))
	))

;------------------------------------------------------------------------------------------
;[right]右
(defun Ufm-macro-argm-right ()
	(let* ((i5(Ic-idx 5)) (i (car i5)) A)
	(if (> i (- (length i5) 4))nil 
		(setcar i5 (setq i (1+ i)))				; 番号を入れる
		(setq A (nth i (cdr i5)))
		(Ic-idx 6 nil nil t (Ufm-macro-mk5col A '(R-Blue   R-Red))) 
		(Ic-idx 7 nil nil t (Ufm-macro-mk5col A '(R-Yellow R-Red)))
	)))

;[left]左
(defun Ufm-macro-argm-left ()
	(let* ((i5(Ic-idx 5)) (i (car i5)) A)
	(if (eq 0 i)nil
		(setcar i5 (setq i (1- i)))				; 番号を入れる
		(setq A (nth i (cdr i5)))
		(Ic-idx 6 nil nil t (Ufm-macro-mk5col A '(R-Blue   R-Red))) 
		(Ic-idx 7 nil nil t (Ufm-macro-mk5col A '(R-Yellow R-Red)))
	)))

;[return]入力可能項目への入力
(defun Ufm-macro-argm-ret ()
	(let* (
		(F (Ic-idx 5))
		(W (nth (1- (length F)) F))				;table[5] の最後にオリジナルが隠してある
		(U (nth 1 (nth (+ 2 (car F)) W)))		;(input "prompt:" "init" "prefix." ".suffix")
		(SYM (car-safe U))						;input
		)
	(cond
		;[input]
		((or(eq 'input SYM)(eq 'i SYM)(eq 'is SYM)(eq 'inputs SYM)) ; tinput 系は、逐次実行なので Ufm-macro-conc にまかせる
		(let ((S (read-from-minibuffer (nth 1 U) (nth 2 U) nil nil (nth 5 U))))		; nth 5 は履歴だぞ
			(setcar (nthcdr 2 U) S)
			(Ufm-macro-argm-refresh nil nil (car F))
		))
		;[ifile]
		((or (eq 'ifile SYM)(eq 'if SYM))
		(let ((S (read-file-name (nth 1 U) (nth 2 U) nil nil (nth 8 U))))
			(setcar (nthcdr 2 U) S)
			(Ufm-macro-argm-refresh nil nil (car F))
		))
		;[ifile+]
		((or (eq 'ifile+ SYM)(eq 'if+ SYM))
		(let ((S (Ufm-get-filename (nth 1 U) (nth 2 U) '+)))
			(setcar (nthcdr 2 U) S)
			(Ufm-macro-argm-refresh nil nil (car F))
		))
		;[ifile-]
		((or (eq 'ifile- SYM)(eq 'if- SYM))
		(let ((S (Ufm-get-filename (nth 1 U) (nth 2 U) '-)))
			(setcar (nthcdr 2 U) S)
			(Ufm-macro-argm-refresh nil nil (car F))
		))
		;[idir]
		((or (eq 'idir SYM)(eq 'id SYM))
		(let ((S (Ufm-get-dirname (nth 1 U) (nth 2 U) t)))
			(setcar (nthcdr 2 U) S)
			(Ufm-macro-argm-refresh nil nil (car F))
		))
		;その他はquit
		(t
			(Ufm-macro-argm-return))
		)
	))

;----------------------------------------------------------------------------------------------------
;[q] 結果引数リストを返す
;
;マクロリストから、単なる文字列等の非入力項目はここにコピーされる。入
;力を促すものは添え字が挿入され、引数メニューにメニュー形式で表示され
;た後、最後に引数として代入されます。
;
(defun Ufm-macro-argm-quit ()
	(message "やっぱやーめた 「実行するなら [end] を押しな」")
	(throw 'ARGM t)
	)
(defun Ufm-macro-argm-return ()
	(Ic-quit (Ufm-macro-argm-look))
	)

(defun Ufm-macro-argm-look (&optional T)
	; Ufm-macro-argm-value は、("echo" 0 1 2 3 4 no 5 6 disp) みたいなかんじ
	(let ((L (length Ufm-macro-argm-value))(I 0)S str)
		(while (< I L)(let (
			(now (nth I Ufm-macro-argm-value))
			)
			(cond 
				((numberp now)	(setq S (append S (Ufm-macro-argm-get now))))
				(t				(setq S (append S (list now))))	; 直接挿入
				)
			(setq I (1+ I))
			))
		(setq str (mapconcat (lambda(a)(cond
			;文字列はそのまま
			((stringp a)a)
			;リストは、(file)などと思うので展開
			((listp   a)(let (
						(a1 (car a))
						(PATH(Ufm-name 'dir))
						(FILE(Ufm-name))
						MTAG STACK COM HISTORY)		;どー的スコープばりばりで美しくないけどいいのだ
					(if (or (eq a1 'tag)
							(eq a1 'stag)
							(eq a1 'conc)
							(and (eq a1 'input)(nth 7 a))
							)"<TAG>"
					(Ufm-macro-conc a)
					(if (eq 1 (length STACK))(car STACK)(mapconcat (lambda(a)a)STACK" ")))
					))
			)) S  " "))
		(condition-case nil (message str)(error))		; セレクションの中に、％が含まれると困る
		(if T nil (x-set-selection nil str))
	S))


;項目の現在の値を取得する(リスト形式で返される)
(defun Ufm-macro-argm-get (&optional I)
	(let* (
		(F (Ic-idx 5 I))
		(W (nth (1- (length F)) F))
		(LIST (nth 1 (nth (+ 2 (car F)) W)))	;(input )
		(L0   (car-safe LIST))						;input
		)
	(cond
		;i,if 等の入力コマンド
		((Ufm-macro-symp L0)
			(if (< 0 (length (nth 2 LIST)))
				(append (nth 5 LIST)
						(list (concat (nth 3 LIST) (nth 2 LIST) (nth 4 LIST)))
						(nth 6 LIST)
				)))
		;inputs は外部に任せる
		((or (eq L0 'is)(eq L0 'inputs))
			(list (list 'input (nth 1 LIST)(nth 2 LIST)(nth 3 LIST)(nth 4 LIST) nil t nil (nth 5 LIST) t))
			)
		;tinput pfile 等は内部形式に変換する
		((or (eq L0 'ti)(eq L0 'tinput))
			(list (list 'input (nth 1 LIST)(nth 2 LIST)(nth 3 LIST)(nth 4 LIST) nil nil t (nth 5 LIST)))
			)
		((or (eq L0 'tis)(eq L0 'tinputs))
			(list (list 'input (nth 1 LIST)(nth 2 LIST)(nth 3 LIST)(nth 4 LIST) nil t t (nth 5 LIST)))
			)

		;tag 等
		((or (eq L0 'pf)(eq L0 'pfile))
			(list (list 'file (nth 1 LIST)(nth 2 LIST)(nth 3 LIST)t))
			)
		((or (eq L0 'tag)(eq L0 'ptag))
			(list (list 'tag (nth 1 LIST)(nth 2 LIST)(nth 3 LIST)t))
			)
		((or (eq L0 'tags)(eq L0 'ptags))
			(list (list 'tags (nth 1 LIST)(nth 2 LIST)(nth 3 LIST)t))
			)
		((eq L0 'stag)
			(list (list 'stag (nth 1 LIST)(nth 2 LIST)(nth 3 LIST)))
			)
		((eq L0 'stags)
			(list (list 'stags (nth 1 LIST)(nth 2 LIST)(nth 3 LIST)))
			)

		; 普通の文字列の場合 ("str" "abc")
		((consp LIST)		(if (stringp (car LIST))LIST(list LIST)))	;("選択" ("あ" "い"))
		((stringp LIST)		(list LIST))	;("選択" "あ")

		; file
		((Ufm-macro-symp L0) (list L0))	;("指定" f)

		; nil の場合は(nil)じゃなくてnilを返す
		((null	L0) nil)

		; no disp の場合は(no)等を返す
		(t (list LIST))

	)))

;------------------------------------------------------------------------------------------
;●マクロ文字列パーサ
;
;	従来の文字列マクロをマクロコンパイルドリストに変換する。
;	"wget %INPUT{Prompt}{init}"
;
;	SPACE が指定されると、空白文字もスタックに積む(バッククオートの処理に必要)
;
;	STACK に蓄えつつ実行。NPS は、空白を削除したときに nil に設定され
;	るフラグ。ディフォルトは nil で、空白意外を読み込むと 'a になる。
;	空白意外が２回続くと、t になり、STACK の値は前の値と連結される。
;
;

(defconst Ufm-m0 "\\([^ \t<;'`\"|&>%]+\\)?")	;%TAGの前後 +1
(defconst Ufm-m1 "\\({\\([^}]+\\)}\\)?")		;%TAGの引数 +2
(defun Ufm-macro-parse (STR &optional SPACE)
"
例：  echo %TAGS > %IFILE{File name : } %VIEW %n

●ファイル記述子

    %f 又は %FILE       カーソル位置のファイル名
    %pf     %PFILE      カーソル位置の絶対パス名
    %t      %TAG        タグファイル名           一つずつ代入(mark数だけ繰り返す)
    %pt     %PTAG       タグ絶対パス名           一つずつ代入(mark数だけ繰り返す)
    %st     %STAG       スーパータグ絶対パス名   一つずつ代入(super-mark数だけ繰り返す)
    %ts     %TAGS       タグファイル名           空白で区切って一括代入
    %pts    %PTAGS      タグ絶対パス名           空白で区切って一括代入
    %sts    %STAGS      スーパータグ絶対パス名   空白で区切って一括代入
    %d      %DIR        現在のディレクトリ名     %dd パス無し

    例：%FILE{2}        ==> 拡張子を２つ消去する

●入力記述子

    %if     %IFILE      ファイル名の入力
    %if+    %IFILE+     ファイル名の入力(存在するファイル名)
    %if-    %IFILE-     ファイル名の入力(存在しないファイル名)
    %id     %IDIR       ファイル名の入力(存在するディレクトリ名)
            %SEL        セレクション

    %i      %INPUT      汎用入力
    %is     %INPUTS     汎用入力２   空白は引数の区切りと見なして引数自体に含めない
    %ti     %TINPUT     汎用入力     (繰り返しごとに新しい入力を促す)
    %tis    %TINPUTS    汎用入力２   (繰り返しごとに新しい入力を促す)

    例 : %IFILE{プロンプト}{初期値}{履歴変数名}     ==> {引数} は省略可能
    例 : %INPUTR ==> 最後に R をつけると 入力 $SHELL は /bin/sh などに変換される。

●制御記述子

    %e      %EXE        標準入力を与えるモードに移行する
    %c      %COM        シェルを使わない(リダイレクトや環境変数の記号は意味を無くす)
    %v      %VIEW       実行後、出力内容をみる
    %n      %NO         実行後、マクロメニューを出ない

    %SAVE{filename}     filename で表わされるファイルに結果を保存する
    %TSAVE{exp}         タグファイルのそれぞれの結果をタグファイル名に
                        拡張子 exp を追加した形で保存する。

●その他

    %ARG                スクリプト引数 (スクリプトの設定は f5 で行う)
    %ARGT               %ARG と違いスクリプトが /tmp にコピーされそのファイル名が埋め込まれる
    %LIST{(exec)}       リストを実行して結果を埋め込む  例 : %LIST{(directory-files \"/\")}
                        引数が数値の場合は、メニューを組み込む
"
	;------------------------------
	(let (STACK NPS)
        ;標準入力を与えるか
        (if (string-match (concat "%\\(EXE\\|e\\)" Ufm-m1 Ufm-m1) STR)(progn
			(setq STACK (append STACK
				(list (list 'exe  (if (match-string 3 STR)(car (read-from-string (match-string 3 STR))))
							(if (match-string 5 STR)(car (read-from-string (match-string 5 STR))))))))
;            (setq STR (replace-match "" t nil STR)) ここでは消さない
            ))
        ;シェルを使うか
        (if (string-match "%\\(COM\\|c\\)" STR)(progn
			(setq STACK (append STACK(list 'com)))
;            (setq STR (replace-match "" t nil STR)) ここでは消さない
            ))

        ;パースループ
        (while (not(equal STR ""))(cond

            ;先頭の空白を取り除く
            ((string-match "^\\([ \t]+\\)" STR)
				(setq NPS nil)
				(if SPACE (setq STACK (append STACK (list (match-string 0 STR)))))
				)

			;前のと連結しちゃう。NPS の設定
            ((progn
				(setq NPS (cond ((eq 'a NPS) t) ((eq t NPS) t) (t 'a)))
				nil))

			;特殊記述子自体
			((string-match (concat "^" Ufm-m0 "%{\\(\\(\\\\}\\|[^}]\\)*\\)}" Ufm-m0) STR)	;%{}中で認められるのは、}じゃない か \}　の羅列
				(let ((I 0)(DATA (match-data))(Y (match-string  2 STR))(B (match-string 1 STR))(C (match-string 4 STR)))
					(while (setq I (string-match "\\\\}" Y I))
						(setq I (+ 1 I))(setq Y (replace-match "}" nil t Y)))	;置換しちゃう \} を } に
					(setq STACK (append STACK (list (concat B Y C))))
				    (set-match-data DATA)
					))

            ;スクリプト引数 (テンポラリファイルに出力)
            ((string-match (concat "^" Ufm-m0 "%ARGT\\({\\([0-9]+\\)}\\)?" Ufm-m0) STR)
				(setq STACK (append STACK (list (list 'argt (if (match-string 3 STR)(string-to-number (match-string 3 STR))0) (match-string 1 STR) (match-string 4 STR))))))

            ;スクリプト引数 (setq STR "%ARG%1%")
            ((string-match (concat "^" Ufm-m0 "%ARG\\({\\([0-9]+\\)}\\)?" Ufm-m0)STR)
				(setq STACK (append STACK (list (list 'arg  (if (match-string 3 STR)(string-to-number (match-string 3 STR))0) (match-string 1 STR) (match-string 4 STR))))))

            ;汎用入力 [1]%[2]INPUT[4][5]%[7]%%[9]%%[11]%[12]
            ((string-match (concat "^" Ufm-m0 "%\\(T\\|t\\)?\\(INPUT\\|i\\)\\(S\\|s\\)?\\(R\\|r\\)?" Ufm-m1 Ufm-m1 Ufm-m1 Ufm-m0) STR)
                (let* (
                    (DATA   (match-data))
                    (MODE_T   (match-string 2 STR))	;T	タグファイルを一括してコマンドラインに展開する
                    (MODE_S  (match-string 4 STR))	;S	入力文字をスペースで区切って別々にコマンドラインに展開する
                    (MODE_R  (match-string 5 STR))	;R	入力結果をクオートしない
                    (PROMPT (match-string 7 STR))
                    (INIT   (match-string 9 STR))
                    (HIST   (if (match-string 11 STR)
                                (let ((SYMBOL (car (read-from-string (match-string 11 STR)))))
                                (if (boundp SYMBOL)()(set SYMBOL nil))SYMBOL)))
                    (TOP    (match-string 1 STR))
                    (APPEND (match-string 12 STR))
                    )
				;(input "プロンプト" "初期値" "pre" "suf" 'not-quote 'space 'tags '履歴変数)
                (setq STACK (append STACK (list (list 'input (if PROMPT PROMPT "なにかね？ : ") INIT TOP APPEND MODE_R MODE_S MODE_T (if HIST HIST 'Ufm-macro-his-1)))))
                (set-match-data DATA)   ;内部で string-match を使っているときには最後にこれを実行すること
                ))

            ;ファイル名の入力
            ((string-match (concat "^" Ufm-m0 "%\\(IFILE\\|if\\)\\([+-]\\)?" Ufm-m1 Ufm-m1 Ufm-m0) STR)
                (let* (
                        (DATA   (match-data))
                        (OROR   (cond ((equal (match-string 3 STR) "+") '+)((equal (match-string 3 STR) "-") '-)(t nil)))
                        (PROMPT (match-string 5 STR))
                        (INIT   (match-string 7 STR))
                        (TOP    (match-string 1 STR))
                        (APPEND (match-string 8 STR))
                    )
				;(ifile	"プロンプト" "初期値" "pre" "suf" '[+|-] '履歴変数)
                (setq STACK (append STACK (list (list 'ifile PROMPT INIT TOP APPEND OROR))))
                (set-match-data DATA)
                ))

            ;存在するディレクトリ名の入力
            ((string-match (concat "^" Ufm-m0 "%\\(IDIR\\|id\\)" Ufm-m1 Ufm-m1 Ufm-m0) STR)
                (let* (
                        (DATA   (match-data))
                        (PROMPT (match-string 4 STR))
                        (INIT   (match-string 6 STR))
                        (TOP    (match-string 1 STR))
                        (APPEND (match-string 7 STR))
                    )
				;(idir "プロンプト" "初期値" "pre" "suf" '履歴変数)
                (setq STACK (append STACK (list (list 'idir PROMPT INIT TOP APPEND))))
                (set-match-data DATA)
                ))

            ;リスト実行
            ((string-match (concat "^" Ufm-m0 "%LIST" Ufm-m1 Ufm-m0) STR)
                (let* (
					(RET (car (condition-case nil (read-from-string (match-string 3 STR))(error))));筋の場合には、引数メニュー
                    (DATA   (match-data))
					)
                (setq STACK (append STACK (if (numberp RET)(Ufm-macro-argm (car (read-from-string (nth RET FUNCTION))))(list (list 'list RET)))))
				(set-match-data DATA)
                ))

            ;特殊動作記述子
            ((string-match "^%\\(NO\\|n\\)"                   STR)
                (setq STACK (append STACK (list 'no))))
            ((string-match "^%\\(v\\|VIEW\\)"                 STR)
                (setq STACK (append STACK (list 'view))))
            ((string-match "^%\\(db\\|DEBUG\\)"              STR)
                (setq STACK (append STACK (list 'debug))))
            ((string-match "^%\\(z\\|DISP\\)"                 STR)
                (setq STACK (append STACK (list (list 'sentinel Ufm-sentinel)))))	;通常はバッファに終了表示をしない歩哨が立つ
            ((string-match "^%\\(WAIT\\|w\\)%\\([^%]+\\)%"    STR)
                (setq STACK (append STACK (list (list 'wait (string-to-number (match-string 2 STR)))))))
			;(save "file" 'save 'tag 'leave) 
            ((string-match (concat "^%\\(T?\\)\\(SAVE\\|BUFF\\)" Ufm-m1 Ufm-m1)  STR)
                (setq STACK (append STACK (list (list 'save 
					(match-string 4 STR)															;ふぁいるめい
					(equal "SAVE" (match-string 2 STR))
					(equal "T" (match-string 1 STR))
					nil)
				))))

            ;セレクション
            ((string-match (concat "^" Ufm-m0 "%SEL" Ufm-m0) STR)
                (setq STACK (append STACK (list (list 'sel ;   (sel	"pre" "suf")	; セレクション
					(match-string 1 STR)
					(match-string 2 STR)
                )))))

            ;ファイル名
            ((string-match (concat "^" Ufm-m0 "%\\(P\\|p\\)?\\(FILE\\|f\\)" Ufm-m1 Ufm-m0) STR)
                (setq STACK (append STACK (list (list 'file ;   (file	"pre" "suf" 2 'dir)	; カーソル位置のファイル名
					(match-string 1 STR)
					(match-string 6 STR)
					(condition-case nil (string-to-number (match-string 5 STR))(error 0))
					(if (or (equal "P" (match-string 2 STR))(equal "p" (match-string 2 STR))) t)
                ))))
				)

			;ディレクトリ名		;	(dir	"pre" "suf" 2 'dir)	; 現在のディレクトリ名
            ((string-match (concat "^" Ufm-m0 Ufm-m1  "%\\(DIR\\|d\\)\\(d\\)?" Ufm-m1 Ufm-m0) STR)
                (setq STACK (append STACK (list (list
					'dir (match-string 1 STR) (match-string 8 STR)
					(if (match-string 7 STR)(string-to-number (match-string 7 STR)))
					(if (match-string 5 STR)nil t)))))
                )

            ;タグファイル
            ((string-match (concat "^" Ufm-m0 "\\(%\\(P?\\)TAG\\(S?\\)\\|%\\(\\(p?\\)t\\(s?\\)\\)\\)\\({\\([0-9]+\\)}\\)?" Ufm-m0) STR)
                (setq STACK (append STACK (list (list
					(if (equal "S" (match-string 4 STR)) 'tags 'tag);S
					(match-string 1 STR);TOP
					(match-string 10 STR);APPEND
					(if (match-string 9 STR)(string-to-number (match-string 9 STR)));拡張子
					(if (equal "P" (match-string 3 STR))t);P
					))))
				)
			;スーパータグ
			;	(stag	"pre" "suf" 2	)	; スーパータグ絶対パス名	一つずつ代入(super-mark数だけ繰り返す)
			;	(stags	"pre" "suf" 2	)	; スーパータグ絶対パス名	コマンドラインに一括挿入
            ((string-match (concat "^" Ufm-m0 "\\(%STAG\\(S?\\)\\|%\\(st\\(s?\\)\\)\\)" Ufm-m1 Ufm-m0) STR)
                (setq STACK (append STACK (list (list 
					(if (equal "S" (match-string 2 STR)) 'stags 'stag)
					(match-string 1 STR)
					(match-string 7 STR)
					(if (match-string 6 STR)(string-to-number (match-string 6 STR)))
				)))))

			;入力履歴
            ((string-match (concat "^" Ufm-m0 "%\\([0-9]+\\)" Ufm-m0)	STR)
                (setq STACK (append STACK (list (list (string-to-number (match-string 2 STR))(match-string 1 STR)(match-string 3 STR))))))

            ; & 単独
            ((string-match "^&" STR)
                (setq STACK (append STACK (list "&")))
                )

			;シングルクオート
            ((string-match "^[^\\\\]?'\\(.+\\)[^\\\\]?'" STR)
				(let ((DATA (match-data)))
                (setq STACK (append STACK (list (append (list 'conc "'" "'") (mapcar(lambda (a)a)(Ufm-macro-parse(match-string 1 STR) t))))))
                (set-match-data DATA)
                ))

			;ダブルクオート
            ((string-match "^[^\\\\]?\"\\(.+\\)[^\\\\]?\"" STR)
				(let ((DATA (match-data)))
                (setq STACK (append STACK (list (append (list 'conc "\"" "\"")(mapcar(lambda (a)a)(Ufm-macro-parse(match-string 1 STR) t))))))
                (set-match-data DATA)
                ))

			;バッククオート
            ((string-match "^[^\\\\]?`\\(.+\\)[^\\\\]?`" STR)
				(let ((DATA (match-data)))
                (setq STACK (append STACK (list (append (list 'conc "`" "`") (mapcar(lambda (a)a)(Ufm-macro-parse(match-string 1 STR) t))))))
                (set-match-data DATA)
                ))

            ;%COM %EXE
            ((string-match "^%\\(COM\\|c\\|EXE\\|e\\)" STR))

            ;普通の文字列(シェル展開させる)
            ((string-match "^[^ \t]+" STR)
                (setq STACK (append STACK (list (match-string 0 STR))))
                )
            )

		;前のと合体しちゃう
		(if (eq t NPS)(setcdr (nthcdr (- (length STACK) 3) STACK) (list (list 'conc "" "" (nth (- (length STACK) 2) STACK)(nth (- (length STACK) 1) STACK)))))

		;マッチした文字列を削除する
		(setq STR (replace-match "" t nil STR))

	)STACK))


;------------------------------------------------------------------------------------------
;●リストＬからシンボルＳかシンボルSを先頭にするリストを検索して返す
(defun U-list-find1(L S)
	(if (member S L)S
		(catch 'F (mapcar (lambda(a)(if (eq S (car-safe a))(throw 'F a))) L)nil)
	))

;------------------------------------------------------------------------------------------
;●存在[する|しない]ファイル名をゲットする
;	PROMPT	催促
;	INIT	ディフォルトのファイル名
;	OR		+ なら存在するファイル名しか受け付けない　− なら存在しないファイル名しか受け付けない
(defun Ufm-get-filename(&optional PROMPT INIT OR)
	(let (RET)(catch 'BREAK (while t (let (EXIP FILEP)
		(setq RET (read-file-name (if PROMPT PROMPT "File name : ") nil nil nil (if INIT INIT Ufm-dir)))
		(setq EXIP  (file-exists-p RET))
		(setq FILEP (eq nil (nth 0 (file-attributes (file-truename RET)))))
			(cond
			((eq OR '+)(if (and EXIP FILEP)
				(throw 'BREAK RET)
				(message "存在するファイル名を指定してね")(setq INIT RET)(sit-for 1)))
			((eq OR '-)(if EXIP
				(progn (message "存在しないファイル名を指定してね")(setq INIT RET)(sit-for 1))
					(throw 'BREAK RET)))
			(t		(throw 'BREAK RET))
			)
	)))))
;(Ufm-get-filename "Prompt : " "init")

;------------------------------------------------------------------------------------------
;●存在するディレクトリ名の入力
;	PROMPT	催促
;	INIT	ディフォルトのファイル名
(defun Ufm-get-dirname(&optional PROMPT INIT MAKE)
	(let (RET)(catch 'BREAK (while t (let(ATT)
		(setq RET (expand-file-name (read-file-name (if PROMPT PROMPT "File name : ") nil nil nil INIT)));(if INIT INIT Ufm-dir))))
		(setq ATT (file-attributes (file-truename RET)))
		(cond
			((eq ATT nil)			(if (and MAKE (make-directory-recursive RET))(throw 'BREAK RET)(message "ディレクトリの作成に失敗しました。")(sit-for 1))
									(message "そんなディレクトリはないですよ")(setq INIT RET)(sit-for 1))
			((eq (nth 0 ATT) nil)	(message "同名のファイルがあります。ディレクトリを入力してね")(setq INIT RET)(sit-for 1))
			(t	(throw 'BREAK RET))
		))))))
;(Ufm-get-dirname "Prompt : " "init")


;------------------------------------------------------------------------------------------
;●マクロ実行コマンド
;
;	マクロコンパイルドリストを受け取って実行する。
;
;	例：(Ufm-macrod-do ("wget" ptags file (tags 2) ("a" "b" "c")))
;	
;<マクロコンパイルドリストの書式>
;
;	(
;	"wget"					; 文字列は、そのままシェルに渡されて解析される
;特殊系
;	(fifo "a" "b" "c")		; タグと同じく逐次実行
;	(conc (f) "")			; リストは結果を連結する
;	(quote "str")			; シェルに渡されるときのみ、クオートする
;	(1 "pre" "suf")			; 入力系の過去の履歴(1 oriented)
;置換系
;   (file	"pre" "suf" 2 'dir)	; カーソル位置のファイル名
;	(dir	"pre" "suf" 2 'dir)	; 現在のディレクトリ名
;	(sel	"pre" "suf")		; セレクション
;	(tag	"pre" "suf" 2 'dir)	; タグファイル名			一つずつ代入(mark数だけ繰り返す)
;	(stag	"pre" "suf" 2	  )	; スーパータグ絶対パス名	一つずつ代入(super-mark数だけ繰り返す)
;	(tags	"pre" "suf" 2 'dir)	; タグファイル名			コマンドラインに一括挿入
;	(stags	"pre" "suf" 2     )	; スーパータグ絶対パス名	コマンドラインに一括挿入
;入力系
;	(ifile		"プロンプト" "初期値" "pre" "suf" '[+|-]			'履歴変数)	; ファイル名の入力
;	(idir		"プロンプト" "初期値" "pre" "suf"					'履歴変数)	; ファイル名の入力( 存在するディレクトリ名 )
;	(input		"プロンプト" "初期値" "pre" "suf" 'not-quote 'space 'tags '履歴変数)	; 汎用入力
;制御系
;	com					; シェルを使わない(リダイレクトや環境変数の記号は意味を無くす)
;	(exe map hist)		; 標準入力を与えるモードに移行する
;	view				; 実行後、出力内容をみる
;	no					; 実行後、マクロメニューを出ない
;	disp				; 終了表示を通常バッファに出すようにする
;	debug				; 実行ごとに呼び出し引数を表示してしまうぞ
;	(save "file" 'save 'tag 'leave)
;						; "file" で表わされるバッファに結果を保存する.
;						; 'save file で表わされるファイルに結果を保存する.
;						; 'tag を指定するとタグごとに別々のバッファに入れる。
;						; 'leave は終了後バッファ削除
;	(wait n)			; 実行後の待ち時間
;特殊置換系
;   (arg 1)				; スクリプト引数 (スクリプトの設定は f5 で行う)
;   (argt 1)			; ARG と違いスクリプトが /tmp にコピーされそのファイル名が埋め込まれる
;   (list ()()())		; リストを実行して結果を埋め込む (例 : LIST(directory-files \"/\"))
;	(nc (list))			; 引数メニュー起動
;特殊置換系
;	(after ()()())		; コマンド実行前に実行される式
;	(before ()()())		; コマンド実行後に実行される式
;	(sentinel ()())		; コマンド終了時に実行される式
;
;実行について
;
;	基本的にシェルに渡してバックグラウンドで実行する。
;	出力はディフォルトバッファに出力され、Ufm　が終了してもプロセスはKILLされない。
;	各文字列はそのままの状態でコマンドラインに展開され、シェルによる解析が行われる。
;	例えば、"$(SHELL)"は"/bin/sh"に変換される。
;	(r ...) 形式を使うと適切にクォートされた状態でシェルに渡される。
;	また、file input の入力結果はディフォルトで適切にクォートされた状態でシェルに渡される。
;	クォートしたくない場合には、入力系のオプションを用いる。
;
;	出力を特定のバッファに入れるには、(save "file") オプションを使用する。
;	プロセス終了後ファイルにセーブするには、(save "file" t) とする。
;	タグファイルごとに違う[ファイル|バッファ]に保存したいときには、(save "exp" [t|nil] t)とする
;	
;	シェルによる解析をしないようにするには　com を指定して全体をシェルに渡さない。
;		（quote は意味を無くす）
;
;	標準入力を与えたい場合には、(exe map hist)を指定する。com 指定も可能。
;
;	終了後、出力結果を View関数で見る事も出来る。(view)
;
;マクロコンパイルドリストの生成
;
;	従来形式の文字列からUfm-macro-parse関数によって生成するか、
;	メニューの生成が出来るUfm-macro-argm関数によって生成する。
;	直接Ufm-macro-doを実行してもいいですけれど。
;
;

(defun Ufm-macro-do (LIST &optional FUNCTION &rest FUNCARG)
	; FUNCTION = t ならばコマンドラインを返す(FUMCTION はスクリプト引数にも使われる)
    (if (eq t FUNCTION)(setq FUNCTION (lambda (v)v)))						
	; 解析開始
    (let (
            (PATH		(Ufm-name 'dir))					; 絶対パス名
            (FILE		(Ufm-name))							; ファイル名

            (COM		(U-list-find1 LIST 'com))	;  シェルを使わない
            (EXE		nil )	; Ufm-exec で実行するかどうか
			(EXE-MAP	nil	)	; Ufm-exec のキーマップ
			(EXE-HIST	nil	)	; Ufm-exec の履歴

            (ARGFILES	nil )   ; スクリプトファイルのセーブした先("/tmp/file1" "/tmp/file2" ...)
            (BUFF       Ufm-standard-pm)   ; 出力結果の出力先のバッファ名 (ディフォルトは Ic-name-wine)
            (SAVE       nil )   ; 出力結果のセーブ先ファイル名
            (TSAVE      nil )   ; 出力結果のセーブ先(拡張子指定) これを指定したときのみタグファイルごとにファイルにセーブできる。
            (LEAVE      nil )   ; 出力結果のバッファを残すかどうか

            (VIEW       nil )   ; 最後にビューするかどうか
            (WAIT       0   )   ; コマンド実行後に待つかどうか
            (SENTINEL   'Ufm-sentinel2)	; sentinel関数の変更
            (DEBUG      nil )	; 引数を実行するときに表示する

			; STACKには("wget" "-opt" t (input "prompt:" "init") 1 2 3 "moji" ...) の形式で展開される。
			; 数字は後方参照、t はタグファイルを示している。
			; 一方、MTAG には逐次実行する時の、文字列のリストが格納されている(("1" "2" "3")("a" "b" "c")(...))
			; 一方、後方参照の為に入力系で入力された文字列のリストが格納されている("1" "2" "3")
            (STACK		nil )   ; コマンドラインそのもの
            (HISTORY	nil )   ; 入力の後方参照挿入リスト
            (MTAG       nil )   ; 連続実行の時の挿入リスト ((1 2 3)(p.1 p.2 p.3)(1.a 2.a 3.a)(s1 s2 s3 s4)...)
            (PROCESS    nil )   ; プロセス
            (RETURN     nil )   ; この関数の返値（FUNCTIONが指定された時にセットされる）
        )
;------▼ 走査(LIST → (Ufm-macro-conc) → STACK)
	(setq STACK (Ufm-macro-co LIST))
;------▼ 実行
	(unwind-protect (condition-case Ufm-macro-error (let* (
		(L ;L は MTAG の中で最も長いリストの長さか１を保持
			(let ((MAX 0)) (mapcar (lambda(a)(if (< MAX (length a))(setq MAX (length a)))) MTAG)(if (eq MAX 0)1 MAX)))
		(I 0); I はタグ逐次実行の添字
		)
        (while(< I L)
		;実行
		(if DEBUG (Ufm-macro-debug (Ufm-macro-last STACK I)))
		(if (functionp FUNCTION)
			;☆関数呼び出し
			(setq RETURN (apply FUNCTION (Ufm-macro-last STACK I) FUNCARG))

			;☆シェル呼び出し
			(set-buffer (get-buffer-create BUFF))(setq default-directory Ufm-dir)(erase-buffer)	;バッファの初期化
			(if EXE
				;☆標準入力あり
				(Ufm-exec (Ufm-macro-last STACK I) EXE-MAP EXE-HIST BUFF 'Ufm-sentinel2 nil nil COM t)
				;☆標準入力なし
				(setq PROCESS (apply (if COM 'start-process 'start-process-shell-command) "*Ufm-process*" BUFF (Ufm-macro-last STACK I)))
				(set-process-sentinel PROCESS SENTINEL)		;歩哨の設定
				(if MTAG (Ufm-wait-shell-command PROCESS))	;連続実行は終了を待つ
				)
			;拡張子指定の実行結果の保存(EXP:セーブ先)
			(if TSAVE (let ((EXP (concat (Ufm-name 'dir (nth I Ufm-mark-list)) (if (stringp TSAVE)TSAVE(number-to-string (nth I Ufm-mark-list))))))
				(if PROCESS (progn
					(if MTAG nil (Ufm-wait-shell-command PROCESS))		  ;セーブするときには終了を待つ
					(accept-process-output PROCESS 0)
					(set-buffer (process-buffer PROCESS))
					)(set-buffer BUFF))
				(Ufm-write-file (current-buffer) EXP LEAVE)
				(erase-buffer)
			)))(setq I (1+ I)))

;------▼ 終了処理
        (if VIEW (progn
            (select-window (get-buffer-window Ic-name-wine))
            (delete-other-windows)
            (set-window-start (get-buffer-window Ic-name-wine) 1)
            (Ufm-uView)
            ))
        (if SAVE (progn
            (if PROCESS (progn
                (Ufm-wait-shell-command PROCESS)
                (accept-process-output PROCESS 0)
                (set-buffer (process-buffer PROCESS))
                )(set-buffer (if BUFF BUFF Ic-name-wine)))
            (write-file SAVE)
            (if LEAVE ()(kill-buffer SAVE))
            ))
        (sit-for WAIT)
		(if FUNCTION nil (setq Ic-refresh BUFF))		; 一時的に wine に BUFF を表示する
;		(setq Ic-noaf t)			; 一時的に wine への書き込みを禁止する
        RETURN)
;------▼ エラー発生
    (error (ding)(message (concat "エラー発生" (prin1-to-string Ufm-macro-error)))(sit-for 3)nil))
    ;最後に必ずスクリプト引数のテンポラリファイルを削除する
    (if ARGFILES (mapcar (lambda (s)
        (message "実行の終了を待ちます")
        (Ufm-wait-shell-command PROCESS)    ;終了を待つ
        (message (concat "deleting script file [" s "] .. "))
        (delete-file s)
        )ARGFILES))
	)))

;----------------------------------------------------------------------------------------------------
;ラストパーサ第３段階にする(実行の直前の最後の変換)
;
;	STACK			("a" ("A" "B" "C") "b" t)					マクロコンパイルドリストのタグ展開前の状態。
;	HISTORY			("a" ("A" "B" "C") ("A" "B" "C"))			この変数自体は、ここでは使用されない。[0-9] の Ufm-macro-conc で処理されて、STACK にリストとして埋め込まれる。
;	MTAG			(("[A]" "[B]" "[C]")("-A-" "-B-" "-C-")		t は、(nth I (nth M MTAG)) に変換される(t 個数は M にカウントされる)
;							(((a b c)(d e f)(g h i)) ...)		文字列がリストである可能性もある。これは tinputs で活用される。
;
;	STACK の I 番目の状態を文字列のリストとして取出す。
;
(defun Ufm-macro-last(STACK I)
	(let (TMP a (M 0)(N 0)(L (length STACK)))(while (< N L)
		(setq a (nth N STACK))
		(setq TMP (append TMP (cond				;conc で始まるリストは再帰した結果を連結して囲む
			((eq 'conc (car-safe a))(list (apply 'concat (append (list (nth 1 a))(Ufm-macro-last (nthcdr 3 a) I)(list (nth 2 a))))))
			((consp a)(list (nth I a)))			;リストはI番目をそこに埋め込む
			((stringp a)(list a))				;文字列は単にそこに埋め込む
			((eq t a)(let ((G (nth I (nth M MTAG))))(setq M (1+ M))(if (stringp G)(list G)G)))			;tはタグリストの中から文字列を探して埋め込む(タグが文字列リストの場合は展開する)
			)))
		(setq N (1+ N))
	)TMP))
;----------------------------------------------------------------------------------------------------
;マクロコンパイルドリストを第２段階にする
(defun Ufm-macro-co(LIST)
	(let (STACK(I 0)(L (length LIST)))(while (< I L) (Ufm-macro-conc (nth I LIST))(setq I (1+ I)))STACK)
	)

;この関数は、マクロコンパイルドリストを走査するが、再帰の為に関数にしたのであって、
;VIEW SAVE 等の変数の束縛された環境を必要としている。単独で起動するべきではない
(defun Ufm-macro-conc(T)
	(cond
	((stringp	T)	(setq STACK (append STACK (list T))))		; 文字列だけクオートしないのだ。（あと入力系のR指定ね）
	((eq 'com	T)	(setq COM t))								; シェルを使わない(リダイレクトや環境変数の記号は意味を無くす)
	((eq 'view	T)	(setq VIEW t))								; 実行後、出力内容をみる
	((eq 'no	T)	(setq Ufm-macflg t))						; 実行後、マクロメニューを出ない
	((eq 'disp	T)	(setq DISP t))								; 終了表示を通常バッファに出すようにする
	((eq 'debug	T)	(setq DEBUG t))								; 実行ごとに呼び出し引数を表示してしまうぞ
;	((eq 'fifo  (car T))	(setq MTAG (append MTAG (list (cdr T)))))			; 逐次実行(必要なし？)
	((symbolp T)(message (concat "不純なシンボルが入ってるぜ！！ "(prin1-to-string T))))

;	(conc "pre" "suf" CompiledList...) クオートなどの再帰連結文字列処理(COM=t に束縛してクォートしないので注意)
	((eq 'conc  (car T))	(let ((COM t))(setq STACK (append STACK (list (append (list (nth 0 T)(nth 1 T)(nth 2 T))(Ufm-macro-co (nthcdr 3 T))))))))
;	([0-9] "pre" "suf")
	((numberp (car T)); 入力後方参照
		(if (consp (nth (nth 0 T) HISTORY))
			(setq STACK (append STACK (list (mapcar (lambda (a)(concat (nth 1 T)a(nth 2 T)))(nth (nth 0 T)HISTORY)))))		; タグによる入力履歴の時には、リストである.
			(setq STACK (append STACK (list (concat (nth 1 T)(nth (nth 0 T) HISTORY)(nth 2 T)))))							; その他は単に代入
		))
;   (sel	"pre" "suf")	; セレクション
	((eq 'sel	(car T))(condition-case nil (setq STACK (append STACK (list
		(Ufm-quote-all (concat 
			(nth 1 T)
			(x-selection)
			(nth 2 T))COM))))(error)))
;   (file	"pre" "suf" 2 'dir)	; カーソル位置のファイル名
	((eq 'file	(car T))	(setq STACK (append STACK (list
		(Ufm-quote-all (concat (nth 1 T)(Ufm-sans-tmp (if (nth 4 T)PATH FILE) (nth 3 T))(nth 2 T))COM)))))
;	(dir	"pre" "suf" 2)	; 現在のディレクトリ名
	((eq 'dir	(car T))	(setq STACK (append STACK (list (let ((A (Ufm-sans-tmp Ufm-dir  (nth 3 T)))) (if (nth 4 T)nil(setq A (cdr (file-namae (substring A 0 (1- (length A)))))))
		(Ufm-quote-all (concat (nth 1 T)A(nth 2 T))COM))))))
;	(tag	"pre" "suf" 2 'dir)	; タグファイル名		一つずつ代入(mark 数だけ繰り返す)
	((eq 'tag	(car T))	(setq STACK (append STACK (list t)))
		(setq MTAG (append MTAG (list  (mapcar (lambda (i)
		(Ufm-quote-all (concat (nth 1 T)(Ufm-sans-tmp (Ufm-name (if (nth 4 T) 'dir) i)(nth 3 T))(nth 2 T))COM))(if Ufm-mark-list Ufm-mark-list (list Ufm-IDX)))))))
;	(stag		"pre" "suf" 2)	; スーパータグ絶対パス名	一つずつ代入(super-mark 数だけ繰り返す)
	((eq 'stag	(car T))	(setq STACK (append STACK (list t)))
		(setq MTAG (append MTAG (list (mapcar (lambda(a)
			(Ufm-quote-all (concat (nth 1 T)(Ufm-sans-tmp a (nth 3 T))(nth 2 T))COM)) Ufm-super-mark)))))
;	(tags		"pre" "suf" 2 'dir)	; タグファイル名		コマンドラインに一括挿入
	((eq 'tags	(car T))	(setq STACK (append STACK (mapcar (lambda (i)
		(Ufm-quote-all (concat (nth 1 T)(Ufm-sans-tmp (Ufm-name (if (nth 4 T)'dir)  i)(nth 3 T))(nth 2 T))COM))(if Ufm-mark-list Ufm-mark-list (list Ufm-IDX))))))
;	(stags	"pre" "suf" 2)	; スーパータグ絶対パス名	コマンドラインに一括挿入
	((eq 'stags	(car T))	(setq STACK (append STACK (mapcar (lambda(a)
			(Ufm-quote-all (concat (nth 1 T)(Ufm-sans-tmp a (nth 3 T))(nth 2 T))COM)) Ufm-super-mark))))
;	(ifile		"プロンプト" "初期値" "pre" "suf" '[+|-] '履歴変数でも未使用)	; ファイル名の入力
	((eq 'ifile	(car T))	(let ((R
			(concat (nth 3 T)(Ufm-get-filename (nth 1 T)(nth 2 T) (nth 5 T))(nth 4 T))))
			(setq STACK (append STACK (list (Ufm-quote-all R))))
			(setq HISTORY (append HISTORY (list R)))
			))
;	(idir		"プロンプト" "初期値" "pre" "suf" '履歴変数)	; 存在するディレクトリ名の入力
	((eq 'idir	(car T))	(let ((R
			(concat (nth 3 T)(Ufm-get-dirname (nth 1 T)(nth 2 T) t)(nth 4 T))))
			(setq STACK (append STACK (list (Ufm-quote-all R))))
			(setq HISTORY (append HISTORY (list R)))
			))
;	(input	"プロンプト" "初期値" "pre" "suf" 'not-quote 'space 'tag '履歴変数 'nedit)	; 汎用入力
	((eq 'input	(car T))	(let (tmp hist (H 0)(len (if (and (nth 7 T)Ufm-mark-list)(length Ufm-mark-list) 1)))
		(while (< H len)(let* (
				(TAR (Ufm-name 'dir (nth H Ufm-mark-list)))
				(R	(if (nth 9 T)(nth 2 T)	;nedit が指定されていたら編集しない。メニューマクロの為
					(read-from-minibuffer (concat 
						(if (eq len 1)nil(concat (cdr (file-namae TAR)) ":: "))		; マークが１つ以上なら、ファイル名を表示する
						(if (nth 1 T)(nth 1 T)(concat TAR "：どうする？")))
						(nth 2 T)nil nil(if (nth 8 T)(nth 8 T)'Ufm-macro-his-1))))
				)
		(setq R (if (nth 6 T)(split-string R)(list R)))					;R には ("A B C") か ("A" "B" "C") が入る
		(setq hist (append hist R))										;hist には前後の文字列は加えない状態でためて行く(クォートもしない)
		(setq R (mapcar (lambda (a)(concat (nth 3 T)a(nth 4 T))) R))
		(if (or COM (nth 5 T))nil(setq R (Ufm-quote-all R)))
		(if (nth 7 T)(setq tmp (append tmp (list R)))
					(setq tmp (append tmp R)))
		(setq H (1+ H))
		))
		(setq HISTORY	(append HISTORY	(list hist)))
		(if (nth 7 T)(progn	;スペースで区切るとき
			(setq MTAG		(append MTAG	(list tmp)))		;TINPUTS の時がダメ
			(setq STACK		(append STACK	(list t)))
			)
			(setq STACK		(append STACK	tmp))
			)
		))
;	(save "file" 'save 'tag 'leave)			; 'tag = t "file" = nil の場合には、拡張子はタグファイルの番号となる。
	((eq 'save	(car T))
		; tag と save が指定されたら出力先ファイルの存在を調べる
		(cond ((and (nth 3 T)(nth 2 T))(mapcar (lambda (a)(if (and
			(file-exists-p(concat (Ufm-name 'dir a)(if (nth 1 T)(nth 1 T)(number-to-string a))))
			(not (y-or-n-p "出力先ファイルが存在します。上書きしますか"))
			)(throw 'error t)))
			Ufm-mark-list)(setq TSAVE (nth 1 T)))
		; 単に save が指定されたら
		((nth 2 T)(if (and (file-exists-p (concat Ufm-dir (nth 1 T)))(not (y-or-n-p "出力先ファイルが存在します。上書きしますか")))
			(throw 'error t))(setq SAVE (concat Ufm-dir (nth 1 T))))
			)
		(setq LEAVE (nth 4 T))
		)
;(exe map hist)
	((eq 'exe	(car T))(setq EXE t EXE-MAP (nth 1 T) EXE-HIST (nth 2 T)))	; 標準入力を与えるモードに移行する
;(wait [0-9]+)
	((eq 'wait	(car T))(setq WAIT (nth 1 T)))		; 実行後の待ち時間
;(argt [0-9]+  "pre" "suf")
	((eq 'argt	(car T)); ARG と違いスクリプトが /tmp にコピーされそのファイル名が埋め込まれる
		(let ((R (nth (if (nth 1 T)(nth 1 T)0) FUNCTION)))
			(let ((TMP-FILE (make-temp-name "/tmp/Ufm-perl-")))
				(find-file TMP-FILE)(insert R)(save-buffer)(kill-buffer (current-buffer))
				(setq ARGFILES (append ARGFILES (list TMP-FILE)))
				(setq STACK    (append STACK    (list (concat (nth 2 T) TMP-FILE (nth 3 T)))))
		)))
;(arg [0-9]+ "pre" "suf")
	((eq 'arg	(car T)); スクリプト引数 (スクリプトの設定は f5 で行う)
		(let ((R (nth (if (nth 1 T)(nth 1 T)0) FUNCTION)))
			(if (stringp R)(setq STACK (append STACK (list (Ufm-quote-all (concat (nth 2 T)R(nth 3 T)) COM)))))
			))
;(sentinel 'func)
	((eq 'sentinel	(car T))(setq SENTINEL (nth 1 T)))		; コマンド終了時に実行される関数
;(list ()) 実行結果は文字列か文字列のリストじゃないといけない。
	((eq 'list	(car T))(setq STACK (append STACK (let ((R (Ufm-quote-all(eval (nth 1 T))COM)))(if (stringp R)(list R)R)))))
;(nc (macro-menu-list))
	((eq 'nc	(car T))(Ufm-macro-argm (cdr T)))
	))

;----------------------------------------------------------------------------------------------------
;●任意文字列をクォートして、そのままの文字列をシェルに渡す
;
;	(Ufm-quote-all  "as''sdfkj';")
;	start-process-shell-command に
;	そのまんまの文字列を渡すときに使う
;
;	COM はUfm-macro用の機能で、これが指定される（シェルを使わない）と
;	文字列はそのまんま返される。
;
;	STR は文字列のリストでも良い
;

;(defun Ufm-quote-all (STR &optional COM)
;    (if COM STR (let ((I 0))
;		(while (setq I (string-match "'" STR I))
;			(setq I (+ 5 I))(setq STR (replace-match "'\"'\"'" t nil STR)))
;		)
;    (concat "'" STR "'")
;    ))

(defun Ufm-quote-all (STR &optional COM)
    (if COM STR (cond ((stringp STR)(let ((I 0))
		(while (setq I (string-match "'" STR I))
			(setq I (+ 5 I))(setq STR (replace-match "'\"'\"'" t nil STR)))
	    (concat "'" STR "'")
		))	;りかーしぶ
		((consp STR)(cons (Ufm-quote-all (car STR))(Ufm-quote-all (cdr STR))))
		(t nil)
    )))
;(Ufm-quote-all '("a" "b" "c" ("A" "B" "C") "D"))


;●マクロのデバッグメッセージを出力する
(defun Ufm-macro-debug (STACK)
    (mapcar (function (lambda (A)
        (insert (concat "[" A "]\n"))))STACK)
    )

;●ファイルの拡張子をN個削除する
(defun Ufm-sans-tmp (FILE N)
	(let ((STR FILE))
	(if N (while (< 0 N)(setq N (1- N))(setq STR (file-name-sans-extension STR))))
	STR))

;●シェルの出力を待つ
(defun Ufm-wait-shell-command (PROCESS &optional TIME)
    (condition-case nil (while (not (eq 'exit (process-status PROCESS)))
		(accept-process-output PROCESS (if TIME TIME 0))(sit-for 0))(error)(quit))
    )

;●バッファの中身を別のファイルにセーブします。
;ウインドウなどには変更を加えません。
;LEAVE が t のときにはバッファは削除されないが、通常は削除される

(defun Ufm-write-file(BUFF FILE LEAVE)
    (save-window-excursion
        (set-buffer BUFF)
        (let ((BUFF(get-buffer-create (generate-new-buffer-name "tmp")))(STR (buffer-string)))
            (set-buffer BUFF)
            (insert STR)
            (set-visited-file-name FILE)
            (save-buffer)
            (if LEAVE ()(kill-buffer BUFF))
            ))) 
;-------------------------------------------------------------------------------------------------
;;●プロセス歩哨

;バッファに表示しないタイプ(標準)
(defun Ufm-sentinel2 (process str)
    (if (equal str "finished\n")(progn
		(Ufm-res process)
		(message (concat (prin1-to-string process) " finished."))))
    (if (get-buffer-window (process-buffer process))(set-window-start (get-buffer-window (process-buffer process)) 1))
	)
;Ufm-exec 専用
(defun Ufm-sentinel3 (process str)
    (if (equal str "finished\n")(progn
		(message (concat (prin1-to-string process) " 終了しました。リターンキー押してね"))))
    (if (get-buffer-window (process-buffer process))(set-window-start (get-buffer-window (process-buffer process)) 1))
	)
        
;バッファに表示してしまうタイプ
(defun Ufm-sentinel (process str)
    (if (get-buffer-window Ic-name-wine)(progn
    (if (equal str "finished\n")
        ;
        (let ((STR (concat (prin1-to-string process) str))(OLD (current-buffer)))
        (put-text-property 0 (length STR) 'face 'C-Yellow STR)
        (ding)(Ufm-res process)
        (set-buffer (process-buffer process))
        (goto-char (process-mark process))
        (insert STR)(message "リターンキーを押してくだされ")
        (set-buffer OLD))
        ;
        (ding)(message (concat (prin1-to-string process) " finished."))
		)
	(set-window-start (get-buffer-window (process-buffer process)) 1)
    )))

;表示ウインドウの内容をファイルに出力する
(defun Ufm-disp-win ()
	"コマンドの出力結果を見る"
	(setq Ic-refresh Ufm-standard-pm)
	)

(defun Ufm-save-win ()
	"表示ウインドウの内容をファイルに出力する"
	(set-buffer (window-buffer Ic-win-wine))
	(write-file (let (A) (while (or (not A) (file-exists-p A))
		(setq A (read-file-name "表示窓をセーブします。新ファイル名 : " "~/"))
		)A))
	)

;-------------------------------------------------------------------------------------------------
;;●カーソル位置ファイル名
;
;   arg : nil ファイル名 dir 絶対パス 'link リンク先絶対パス名
;   idx : nil カーソル   0-9 明示
;
;	Ic のメニューを使うと、Ic-IDX が変わるので対処しないといけないのだ

(defun Ufm-name (&optional arg idx)
    (let*(
        (F (Ic-idx 5 (if idx idx (if Ufm-IDX Ufm-IDX)) 'Ufm-table))
        (R (if (eq arg 'dir)(concat Ufm-dir F)F))
        )
        R
    ))

;-------------------------------------------------------------------------------------------------
;;●ファイル名入力(未使用)
;
; PROMPT        : 文字列
; OR            : ファイルがなければ (nil:再入力)(t:そのまま)
; HIST-SYMBOL   : 履歴用シンボル
;
(defvar Ufm-file-hist nil)
(defvar Ufm-file-map (copy-keymap minibuffer-local-map))
(define-key Ufm-file-map [tab]  (lambda () (interactive)(complate-filenamae)))

(defun Ufm-file (&optional PROMPT OR HIST-SYMBOL)
    (let ((R (while (or (not (eq 'file (Ufm-fmode
                (read-from-minibuffer (if PROMPT PROMPT "File name : ") nil Ufm-file-map nil (if HIST HIST 'Ufm-file-hist))
            )))OR)
        (message "そんなファイルはない。")(sit-for 1))))
    R
    ))

;-------------------------------------------------------------------------------------------------
;;●ディレクトリ名の入力
;
; PROMPT    : 文字列
; A         : ないディレクトリの時に        (t:もう一度入力)(nil:確認とって作成)(2:確認取らず作成)
; B         : フロッピードライブ            (t:入力する)
; C         : [:]でディレクトリがあったら   (t:そのままリターンする nil:ショートカットかどうか確かめる)
; L         : ディレクトリ入力後、リストを eval してもし t ならば、もう一度入力させる。(未使用)
; S			: 同上の時のメッセージ(未使用)
;
; ディレクトリ名は、常に / で終わる絶対パスか、nil を返す
; ただし、フロッピーの時には、"a:" を返す。

(defvar Ufm-dir-hist nil)
(defvar Ufm-dir-map (copy-keymap minibuffer-local-completion-map))
(defvar Ufm-dirB nil)
(defvar Ufm-dirC nil)
(define-key Ufm-dir-map ":" (lambda () (interactive)(Ufm-dir-short D)))
(define-key Ufm-dir-map [escape] 'Ufm-dir-mini-get)
(define-key Ufm-dir-map [tab] (lambda () (interactive)(complate-filenamae)))

(defun Ufm-dir-mini-get ()
    (interactive)
    (let ((STR (save-window-excursion (Ufm-dir-get))))(if (stringp STR)(progn (erase-buffer)(insert STR))))
    )

(defun Ufm-dir (&optional PROMPT A B C D L S)
    (setq Ufm-dirB B)
    (setq Ufm-dirC C)
    (let(OK DIR)(while (not OK)
        (setq DIR (condition-case nil 
			(read-from-minibuffer (if PROMPT PROMPT "Dir name : ") Ufm-dir Ufm-dir-map nil 'Ufm-dir-hist)
			(quit "")(error "")))
        (cond 
        ((and B (equal DIR "a"))				(setq OK t))            ; フロッピーの可能性
        ((eq t (car (file-attributes DIR)))     (setq OK t))            ; ディレクトリが存在するか？
        ((eq A t)                       (message "そのようなディレクトリはない。もう一度入力してくれ")(sit-for 0.5))
        ((or (eq A 2)(y-or-n-p "ディレクトリつくる？"))
                                        (setq OK (make-directory-recursive DIR)))
        ))
	(if (setq OK (eval L)) (message (if S S "もう一度入力してください。")))
    (cond 
        ((equal DIR "")nil)
        ((equal DIR "a")"a:")
        (t  (let ((R (expand-file-name (if (eq 47 (elt DIR (1- (length DIR))))DIR(concat DIR "/")))))
            R
        )))
    ))

;-------------------------------------------------------------------------------------------------
;●数値を入力する関数(ただし、文字列で返される)
(defvar Ufm-numb-hist ())
(defvar Ufm-numb-map (make-keymap))
(define-key Ufm-numb-map [up]			'Ufm-numb-up)
(define-key Ufm-numb-map [down]			'Ufm-numb-down)
(define-key Ufm-numb-map Ic-return-key	'exit-minibuffer)
(define-key Ufm-numb-map [13]			'exit-minibuffer)
(define-key Ufm-numb-map "\C-n"			'next-matching-history-element)
(define-key Ufm-numb-map "\C-p"			'previous-matching-history-element)
(define-key Ufm-numb-map "\M-n"			'next-history-element)
(define-key Ufm-numb-map "\M-p"			'previous-history-element)
(define-key Ufm-numb-map " "			(lambda ()(interactive)(erase-buffer)(insert "0")))
(define-key Ufm-numb-map "\C-g"			(lambda ()(interactive)(erase-buffer)(exit-minibuffer)))

(defun Ufm-get-number(&optional PROMPT INIT MIN MAX)
	(read-from-minibuffer
		(if PROMPT PROMPT "数値 : ")
        (if INIT (number-to-string INIT) "0")
        Ufm-numb-map
		nil
		'Ufm-numb-hist
        )
	)

(defun Ufm-numb-up ()
    (interactive)
    (let* ((A (1+(string-to-number(buffer-string))))(N (if (< MAX A) (1- A) A)))
		(erase-buffer)
		(insert (number-to-string N))
		))

(defun Ufm-numb-down ()
    (interactive)
    (let* ((A (1-(string-to-number(buffer-string))))(N (if (> MIN A) (1+ A) A)))
		(erase-buffer)
		(insert (number-to-string N))
		))


;-------------------------------------------------------------------------------------------------
;●ミニバッファでショートカットを入力するための関数

(defun Ufm-dir-short (&optional F)
    (interactive)
    (let (
        (I (length Ufm-device))
        (SHORT (cdr (file-namae (buffer-string))))
        )
	(if (and Ufm-dirB (equal SHORT "a")(or Ufm-dirC (y-or-n-p "floppy-drive OK?")))(progn (erase-buffer)(insert SHORT)(exit-minibuffer)))
    (catch 'BREAK (while (> I 0)
        (if (equal (car (nth (1- I) Ufm-device)) SHORT)
            (let ((DIR (cdr (nth (1- I) Ufm-device))))
            (if (or Ufm-dirC (y-or-n-p (concat DIR " --> short cut dir. OK?")))
;---------------------------------------------------- for Emacs21
;				(progn (erase-buffer)(insert DIR)
;Emacs21では、ミニバッファで(erase-buffer)すると、プロンプトがプロパティread-onlyなのでエラーになる。困った事だ。
				(progn (goto-char (point-min))
					(while (get-text-property (point) 'read-only)
							(forward-char 1))(kill-line)(insert DIR)
;----------------------------------------------------
				(if F (sit-for 0)(exit-minibuffer))	;コピーなどの時にはバッファを出ないことにした
				(throw 'BREAK nil))))
            )
            (setq I (1- I)) ; not found
         )(insert ":"))
    ))

;●ショートカット登録
(defun Ufm-short(&optional DIR F)
    "カレントディレクトリにショートカット文字をつける"
    (let ((STR (read-from-minibuffer "ディレクトリショートカット名 ：")))
        (setq Ufm-device (U-del3 STR Ufm-device))
        (if F (setq Ufm-device (U-del4 DIR Ufm-device)))
        (setq Ufm-device (append Ufm-device (list (cons STR (if DIR DIR Ufm-dir)))))
    ))

;-------------------------------------------------------------------------------------------------
;;●ファイルのモード
;
;   ファイル名を展開してリンクをたどる
;       file    ファイル
;       dir     ディレクトリ
;		nil		無い
;
(defun Ufm-fmode (name)
	(setq name (file-attributes (file-truename (expand-file-name name))))
	(cond
		((eq name nil)			nil	)
		((eq (nth 0 name) t		)'dir)
		((eq (nth 0 name) nil	)'file)
	))

;-------------------------------------------------------------------------------------------------
;;●再帰的ディレクトリ作成(emacs20 は make-directoryで可能なので不要)
;
;	(t:成功 nil:失敗)
;
(defun make-directory-recursive (DIR)
	(setq DIR (expand-file-name DIR))
	(catch 'BREAK (let* (
		MODE
		(LIST(split-string DIR "/"))
		(STR	(if (U-win32p)(nth 0 LIST)))
		(I		(if (U-win32p)1 0))
		)(while (< I (length LIST))
		
		(setq MODE (Ufm-fmode (setq STR (concat STR "/" (nth I LIST)))))
		(cond	((eq nil MODE)(condition-case VAR (make-directory STR)
					(error
						(message (concat STR " --> ファイルがつくれんかった"))
						(ding)(sit-for 1)(throw 'BREAK nil)
						)))
				((eq 'file MODE)(message (concat STR " --> 同名のファイルがあるぞ"))(ding)(sit-for 1)(throw 'BREAK nil))
		)
		(setq I(1+ I))
		)t)))

;-------------------------------------------------------------------------------------------------
;;●ファイル名補完
;
;	ファイル名の補完を、通常バッファで行いたいときにはこの関数を 
;	global-set-key にて、キーバインドしてください。きっと便利なはずで
;	すよ。
;
;	ARG	補完するファイル名の明示指定
;	STR	補完するファイル名(空白、タブ、改行、ダブルクオートで区切られたもの)
;
;	FILE	(cdr file-namae
;	DIR		(car file-namae
;
;	COMP	補完結果
;
(defun complate-filenamae (&optional ARG)
	(interactive)
	(catch 'BREAK (let (A  B STR)
		(if ARG (setq STR ARG)
			(setq B (point))
			(if (minibuffer-window-active-p (selected-window))(goto-char 0)	;ミニバッファの場合は最初から
			(condition-case var (progn(search-backward-regexp "[\n\t \"]")(forward-char 1))(error (goto-char 1))))
			(setq A (point))
			(goto-char B)
			(setq STR (buffer-substring-no-properties A (point)))
			)
		(let* (
			(FILE	(cdr (file-namae STR)))
			(DIR	(car (file-namae STR)))
			(COMP	(file-name-completion FILE DIR))
			)
		(cond
			;完成してますよ
			((eq t COMP)(message "完璧です。リターンキーで確定します。")(throw 'BREAK t))
			;無いよ
			((eq nil COMP)(ding)(message (concat STR "そんなファイル名はないよ〜ん")))
			;一つだけじゃないようだよ
			((equal COMP FILE)(ding)(message (concat STR "その文字で始まるファイルは一つだけじゃなよ。もう一回 tab 押してリストから return で選択してね"))
				(let ((LAST last-input-event)(EVENT (read-event))FILE)
				(if (equal EVENT LAST)
					(let ((r (Ufm-completion DIR nil nil COMP))) (if (null r)()(delete-region A (point))(insert r)))
					(setq unread-command-events	(append (list EVENT) unread-command-events)))
					)
				)
			;あった
			((stringp COMP)
				(if ARG (concat DIR COMP)(delete-region A (point))(insert (concat DIR COMP)))
				)
			)
		))))

;;●補完用関数

(defun Ufm-completion (&optional dir return prompt file)
	(interactive)
	(setq enable-recursive-minibuffers t)
	(unwind-protect
	(Ufm dir return (if prompt prompt "RET=選択 SPC=ディレクトリ移動 :=shortcut BS=updir") 'Ufm-completion-option file)
	(setq enable-recursive-minibuffers nil))
	)
(defvar Ufm-completion-option '(
		(wink-less 35)
		(milk-cut t)
		(keymap Ufm-completion-map)
		))
(defvar Ufm-completion-map (make-keymap))
(define-key Ufm-completion-map Ic-return-key		'Ufm-quit								)
(define-key Ufm-completion-map [13]					'Ufm-quit								)
(define-key Ufm-completion-map [backspace]			'Ufm-up									)		; ディレクトリを上がる
(define-key Ufm-completion-map "."					'Ufm-refresh							)		; 検索し直し
(define-key Ufm-completion-map [f5]					'Ufm-dir-menu							)		; ディレクトリメニュー
(define-key Ufm-completion-map ":"					'Ufm-chgdir								)		; ディレクトリ変更
(define-key Ufm-completion-map " " (lambda ()(Ufm-return t))								)		; ディレクトリ移動

;-------------------------------------------------------------------------------------------------
;;●ソート

(defvar Ufm-sort 'Ufm-sort-str)

(defun Ufm-sort-str(A B)
	(if (equal (nth 5 B) "..") nil (or (equal (nth 5 A) "..")
	(string< (car A)(car B)))
	))

(defun Ufm-sort-time (A B)
	(if (equal (nth 5 B) "..") nil (or (equal (nth 5 A) "..")
	(and
	(>= (nth 0 (nth 5 (nth 1 A)))(nth 0  (nth 5 (nth 1 B))))
	(>= (nth 1 (nth 5 (nth 1 A)))(nth 1  (nth 5 (nth 1 B))))
	))))

(defun Ufm-sort-size(A B)
	(if (equal (nth 5 B) "..") nil (or (equal (nth 5 A) "..")
	(< (nth 7(nth 1 A))(nth 7(nth 1 B)))
	)))

(defun Ufm-sort-exp(A B)
	(if (equal (nth 5 B) "..") nil (or (equal (nth 5 A) "..")
	(let   ((AA(progn (string-match "\\([^.]*\\)$" (nth 5 A))(match-string 0 (nth 5 A))))
			(BB(progn (string-match "\\([^.]*\\)$" (nth 5 B))(match-string 0 (nth 5 B)))))
	(if (equal AA BB)(string< (nth 5 A) (nth 5 B))(string< AA BB))))
	))

(defun Ufm-sort-utime(A B)
	(if (equal (nth 5 B) "..") nil (or (equal (nth 5 A) "..")
	(and
	(>= (nth 0 (nth 4 (nth 1 A)))(nth 0  (nth 4 (nth 1 B))))
	(>= (nth 1 (nth 4 (nth 1 A)))(nth 1  (nth 4 (nth 1 B))))
	))))

(defun Ufm-sort-ctime(A B)
	(if (equal (nth 5 B) "..") nil (or (equal (nth 5 A) "..")
	(and
	(>= (nth 0 (nth 6 (nth 1 A)))(nth 0  (nth 6 (nth 1 B))))
	(>= (nth 1 (nth 6 (nth 1 A)))(nth 1  (nth 6 (nth 1 B))))
	))))

(defun Ufm-sort-size-big(A B)
	(if (equal (nth 5 B) "..") nil (or (equal (nth 5 A) "..")
	(> (nth 7(nth 1 A))(nth 7(nth 1 B)))
	)))

(defun Ufm-sort ()
	"ソート方法の変更"
	(setq Ufm-sort (or (Ic 'Ufm-sort-table 'Ufm-sort-option) nil))
	(Ufm-refresh)
	)

(defvar Ufm-sort-table '(
	("な〜んも考えない"						;-U
		(nil Ic-quit)
		nil nil nil nil nil nil 32	)
	("名前順"					;-l
		(nil Ic-quit 'Ufm-sort-str)
		nil nil nil nil nil nil	110	)
	("変更時間"					;-t
		(nil Ic-quit 'Ufm-sort-time)
		nil nil nil nil nil nil 116	)
	("サイズ"					;-S
		(nil Ic-quit 'Ufm-sort-size)
		nil nil nil nil nil nil 115	)
	("拡張子"					;-X
		(nil Ic-quit 'Ufm-sort-exp)
		nil nil nil nil nil nil 120	)
	("アクセス時間[utime]"		;-u
		(nil Ic-quit 'Ufm-sort-utime )
		nil nil nil nil nil nil 117)
	("ステータス変更時間[ctime]";-c
		(nil Ic-quit 'Ufm-sort-ctime )
		nil nil nil nil nil nil 99)
	("サイズ(大きい順)"
		(nil Ic-quit 'Ufm-sort-size-big )
		nil nil nil nil nil nil 83)
	))

(defvar Ufm-sort-option '((title "ソート方法")(short-cut)(short-disp)))


;-------------------------------------------------------------------------------------------------
;●隠しファイル
(defun Ufm-H-select()
	"表示ファイルの選択"
	(let ((ret (Ic 'Ufm-H-select-table 'Ufm-H-select-option)))(if ret (funcall ret)))
	)

(defun Ufm-H-tog	()
	"隠しファイル表示トグル"
	(setq Ufm-hide (if Ufm-hide nil t))
	(message (if Ufm-hide "隠しファイル見せません" "隠しファイル表示します"))
	(Ufm-refresh))

(defun Ufm-H-dot	()
	"ドットファイル表示トグル"
	(if (member "^\\." Ufm-notview)
		(progn	(message "ドットファイルを表示するよ")(setq Ufm-notview (U-del1 "^\\." Ufm-notview)))
				(message "ドットファイルは見せない")(setq Ufm-notview (append Ufm-notview (list "^\\."))))
	(Ufm-refresh))

(defun Ufm-H-regexp	()
	"隠しファイル拡張子の追加"
	(setq Ufm-notview (append Ufm-notview (list (concat (read-from-minibuffer "隠しファイル正規表現  : " "exp") "$"))))
	(Ufm-refresh))

;(defun Ufm-H-edit	()
;	"隠しファイル正規表現の編集"
;	(condition-case nil (setq Ufm-notview (read-from-minibuffer "隠しファイル正規表現リスト : " (prin1-to-string Ufm-notview)nil t))
;		(error (message "設定に失敗だぁ")))
;	(Ufm-refresh)
;	)
;(defun Ufm-H-init	()
;	"隠しファイル正規表現の初期化 "
;	(message (concat (documentation 'Ufm-H-init) (prin1-to-string Ufm-notview-def)))
;	(setq Ufm-notview Ufm-notview-def)
;	(Ufm-refresh)
;	)
;(defun Ufm-H-del ()
;	"隠しファイル正規表現の最後の一つを削除"
;	(U-del Ufm-notview -1)
;	(Ufm-refresh))



;-------------------------------------------------------------------------------------------------
;;●関数実行 F3

(defvar Ufm-H-select-option '((title "いろんな機能を試してみよう！")(short-cut)(short-disp)))
(defvar Ufm-H-select-s '(concat "\n\n キーバインド：" (U-map-to-keystr (Ic-idx 1) Ufm-map) "\n\n" (documentation (Ic-idx 1))))
(defvar Ufm-H-select-table (`(
	("バイナリ編集"	Ufm-bin-edit	(, Ufm-H-select-s))
	("ファイル名の記録" nil nil
		(("パス名を    セレクションに入れます"	Ufm-pathname-selection	(, Ufm-H-select-s))
		("ファイル名をセレクションに入れます"	Ufm-filename-selection	(, Ufm-H-select-s))
		("パス名を    バッファに挿入します"		Ufm-insert-pathname	(, Ufm-H-select-s))
		("ファイル名をバッファに挿入します"		Ufm-insert-filename	(, Ufm-H-select-s))
		("cd ディレクトリ名をセレクションに入れます"		Ufm-chdir-selection	(, Ufm-H-select-s)))
		Ufm-H-select-option)
	("隠しファイルの表示" nil nil
		(("ドットファイルの表示／非表示"		Ufm-H-dot	(, Ufm-H-select-s))
		("標準隠しファイルの表示／非表示"	Ufm-H-tog	(, Ufm-H-select-s))
		("標準隠しファイルの設定"			nil "\n\t正規表現でファイル名を指定してください" Ufm-hide-table Ufm-hide-option))
		Ufm-H-select-option)
		;("実行ファイルのみ表示する")
		;("ディレクトリのみ表示する")
		;("正規表現にマッチしたファイル名を表示する")
	("危険な置換関数群" nil nil
		(("危険！再帰 SED 直接コマンド実行"	Ufm-sed		(, Ufm-H-select-s))
		("危険！再帰 文字コード変換"		Ufm-kcc		(, Ufm-H-select-s))
		("危険！再帰 SED 置換コマンド実行"	Ufm-sed-do	(, Ufm-H-select-s)))
		Ufm-H-select-option)
	)))

;-------------------------------------------------------------------------------------------------
;;●環境設定 F12
;;基本メニュー
(defun Ufm-env ()	
	"環境設定メニュー起動"
	(let ((Ufm-IDX Ic-IDX))	;今の所待避の必要は無いけれどね。
		(Ic 'Ufm-env-table 'Ufm-env-option)
		)
	)
(defvar Ufm-env-table '(
	("ディレクトリリスト"			nil "\n\tディレクトリを記憶しています"					Ufm-dir-table Ufm-dir-option)
	("ディレクトリショートカット"	nil "\n\tディレクトリに簡単な名前をつけます"			Ufm-cut-table Ufm-cut-option)
	("拡張子実行コマンド"			nil "\n\t実行キーでの拡張子による動作を決めます"		Ufm-exp-table Ufm-exp-option)
	("編集コマンド"					nil "\n\t編集キー [e] での拡張子による動作を決めます"	Ufm-exp-table Ufm-edit-option)
	("解凍コマンド"					nil "\n\t解凍キー [u] での拡張子による動作を決めます"	Ufm-exp-table Ufm-unpack-option)
	("表示しないファイル名"			nil "\n\t正規表現でファイル名を指定してください"		Ufm-hide-table Ufm-hide-option)
	("フロッピー上書きモード"		nil "\n\tフロッピー上書きモード"						Ufm-a-over-table Ufm-a-over-option)
	("ファイル名履歴の編集"			nil "\n\tおまけ"										Ufm-fihis-table Ufm-fihis-option)
	("スーパータグの保存箱"			nil "\n\tTAB キーで登録したスーパータグをここに保存出来ます。"	Ufm-stag-table Ufm-stag-option)
	))

(defvar Ufm-env-option '(
	(title "環境設定 (戻：← 次：→ セーブ: C-x C-s)")
	(short-cut)(short-disp)
	(keymap Ufm-env-map)
	))

(defvar Ufm-env-map (make-keymap))
(define-key Ufm-env-map "\C-x\C-s"	'Ufm-env-save)
(define-key Ufm-env-map "\C-x\C-f"	'Ufm-env-load)
(define-key Ufm-env-map [f10]		'Ufm-env-save)
(define-key Ufm-env-map [left]		'Ic-quit)
(define-key Ufm-env-map [right]		'Ic-next-node)

;環境設定のセーブ
(defun Ufm-env-save ()
	"Ufm の環境をセーブします"
	(if (y-or-n-p "Ufm の現在の設定事項をセーブしますか？")
		(progn
		(U-save-symbol Ufm-env-file 'Ufm-device 'Ufm-exp 'Ufm-notview 'Ufm-hide 'Ufm-dir-list 'Ufm-super-mark 'Ufm-filength 'Ufm-stag-table)
		(message (concat Ufm-env-file " に書き込み完了です"))
	)))

;環境設定のロード
(defun Ufm-env-load ()
	(if (file-exists-p Ufm-env-file)(load-file Ufm-env-file))
	)

;-----
;●表示しないファイル名

(defvar Ufm-hide-table	nil)
(defvar Ufm-hide-option '(
	(title "拡張子実行コマンドの設定 D:削除 e:変更 i:挿入")
	(refresh	(progn (Ufm-hide-refresh)(Ic-refresh)))
	(after-exec	(progn (Ufm-hide-refresh)(Ic-refresh)))
	(keymap Ufm-hide-option-map)
	))
(defvar Ufm-hide-option-map (make-keymap))
(define-key Ufm-hide-option-map "D"			'Ufm-hide-del)
(define-key Ufm-hide-option-map "e"			'Ufm-hide-mod)
(define-key Ufm-hide-option-map "i"			'Ufm-hide-ins)
(define-key Ufm-hide-option-map "\C-x\C-s"	'Ufm-env-save)
(define-key Ufm-hide-option-map [f10]		'Ufm-env-save)
(define-key Ufm-hide-option-map "\C-x\C-f"	'Ufm-env-load)

(defun Ufm-hide-refresh ()
	(setq Ufm-hide-table(mapcar (function 
		(lambda (A) (list A)))Ufm-notview)))

(defun Ufm-hide-del()
	(U-del Ufm-notview Ic-IDX))

(defun Ufm-hide-mod()
	(U-mod Ufm-notview Ic-IDX
	(read-from-minibuffer "ファイル名正規表現 -> " (nth Ic-IDX Ufm-notview))))

(defun Ufm-hide-ins()
	(U-ins  Ufm-notview Ic-IDX
	(read-from-minibuffer "ファイル名正規表現 -> " '("\\.$" . 3))))

;-----
;;●ディレクトリメニュー
;
(defvar Ufm-dir-list nil)
(defvar Ufm-dir-list-stack nil)
(defvar Ufm-dir-table nil)
(defvar Ufm-dir-option	'(
	(title "ディレクトリジャンプ (RET:ジャンプ F5:登録 D:削除 [:ショートカット登録)")
	(refresh	(progn
;		(use-local-map Ufm-dir-list-menu-map)
		(Ufm-dir-refresh)
		(Ic-refresh)
		))
	(after-exec	(progn 
		(Ufm-dir-refresh)
		(Ic-refresh)
		))
	(keymap Ufm-dir-list-map)
	))

;(defvar Ufm-dir-list-menu-map (U-no-menubar-keymap))

(defvar Ufm-dir-list-map (make-keymap))
(define-key Ufm-dir-list-map Ic-return-key	'Ufm-dir-list-ret)
(define-key Ufm-dir-list-map [13]			'Ufm-dir-list-ret)
(define-key Ufm-dir-list-map "\\"		'Ufm-dir-list-ret)
(define-key Ufm-dir-list-map "\C-x\C-s" 'Ufm-env-save)
(define-key Ufm-dir-list-map [f10]		'Ufm-env-save)
(define-key Ufm-dir-list-map "\C-x\C-f"	'Ufm-env-load)
(define-key Ufm-dir-list-map [delete]	'Ufm-dir-list-push)
(define-key Ufm-dir-list-map [insert]	'Ufm-dir-list-pop)
(define-key Ufm-dir-list-map "D"		'Ufm-dir-list-del)
(define-key Ufm-dir-list-map ","		'Ufm-dir-add)
(define-key Ufm-dir-list-map [f5]		'Ufm-dir-add)
(define-key Ufm-dir-list-map "["		'Ufm-dir-list-short)

(defun Ufm-dir-menu ()
	"ディレクトリメニュー"
	(Ic 'Ufm-dir-table 'Ufm-dir-option)
	(Ufm-refresh)
	)
(defun Ufm-dir-get ()
	(let (Ufm-dir-get-flag)
	(Ic 'Ufm-dir-table 'Ufm-dir-option)
	))

(defun Ufm-dir-refresh ()
	(setq Ufm-dir-table (mapcar (lambda (A)(list 
		(concat "[" (car (rassoc A Ufm-device)) "]" A)
	))Ufm-dir-list)))

(defun Ufm-dir-list-ret()
	(if (boundp 'Ufm-dir-get-flag)
		(Ic-quit (nth Ic-IDX Ufm-dir-list))
		(setq Ufm-dir (nth Ic-IDX Ufm-dir-list))
		(Ufm-refresh)	;specify-node でもきちんと表示するように
		(Ic-quit)
		))

(defun Ufm-dir-list-pop()
	(U-ins  Ufm-dir-list Ic-IDX (car Ufm-dir-list-stack))
	(U-del Ufm-dir-list-stack 0))

(defun Ufm-dir-list-push()
	(U-ins  Ufm-dir-list-stack 0 (nth Ic-IDX Ufm-dir-list))
	(U-del Ufm-dir-list Ic-IDX))

(defun Ufm-dir-list-del()
	(if (boundp 'Ufm-dir-get-flag)()(U-del Ufm-dir-list Ic-IDX)))
	
(defun Ufm-dir-add ()
	"ディレクトリリストに追加"
	(if (boundp 'Ufm-dir-get-flag)()
	(setq Ufm-dir-list (append Ufm-dir-list (list Ufm-dir)))
	(message "カレントディレクトリを記憶したよ(F5 でリストが表示されます)")
	))

(defun Ufm-dir-list-short ()
	(if (boundp 'Ufm-dir-get-flag)()
		(Ufm-short(nth Ic-IDX Ufm-dir-list) t)))


;-----
;●ショートカット

(defvar Ufm-cut-table	nil)
(defvar Ufm-cut-option '(
	(title "ショートカットの設定 D:削除 e:変更 i:挿入 ret:移動")
	(refresh	(progn (Ufm-cut-refresh)(Ic-refresh)))
	(after-exec	(progn (Ufm-cut-refresh)(Ic-refresh)))
	(keymap Ufm-cut-option-map)
	))

(defvar Ufm-cut-option-map (make-keymap))
(define-key Ufm-cut-option-map [return] 'Ufm-cut-option-ret)
(define-key Ufm-cut-option-map "D" 'Ufm-cut-option-del)
(define-key Ufm-cut-option-map [(meta f1)] 'Ufm-cut-option-del)
(define-key Ufm-cut-option-map "e" 'Ufm-cut-option-mod)
(define-key Ufm-cut-option-map "i" 'Ufm-cut-option-ins)
(define-key Ufm-cut-option-map [f1] 'Ufm-cut-option-ins)
(define-key Ufm-cut-option-map "\C-x\C-s"	'Ufm-env-save)
(define-key Ufm-cut-option-map "\C-x\C-f"	'Ufm-env-load)
(define-key Ufm-cut-option-map [f10]		'Ufm-env-save)

(defun Ufm-cut-refresh ()
	(setq Ufm-cut-table(mapcar (function (lambda (A) (list (format "%10s  <=> %s" (car A) (cdr A)))))Ufm-device))
	)

(defun Ufm-cut-option-ret()
	(setq Ufm-dir (cdr (nth Ic-IDX Ufm-device)))
	(Ufm-refresh)
	(Ic-quit))

(defun Ufm-cut-option-del()
	(U-del Ufm-device Ic-IDX))

(defun Ufm-cut-option-mod()
	(U-mod Ufm-device Ic-IDX (cons 
		(read-from-minibuffer "Short cut -> " (car (nth Ic-IDX Ufm-device)))
		(read-file-name "Dir -> " (cdr (nth Ic-IDX Ufm-device)))
	)))

(defun Ufm-cut-option-ins()
	(U-ins  Ufm-device Ic-IDX (cons
		(read-from-minibuffer "Short cut -> ")
		(read-file-name "Dir -> "))))


;-----
;●実行コマンド

(defvar Ufm-exp-table	nil)
(defvar Ufm-exp-IDX		0)
(defvar Ufm-exp-option '(
	(title "拡張子実行コマンドの設定 D:削除 e:変更 i:挿入")
	(refresh (progn (setq Ufm-exp-IDX 1)(Ufm-exp-refresh Ufm-exp-IDX)(Ic-refresh)))
	(after-exec (progn (Ufm-exp-refresh Ufm-exp-IDX)(Ic-refresh)))
	(keymap Ufm-exp-option-map)
	))
(defvar Ufm-edit-option '(
	(title "編集コマンドの設定 D:削除 e:変更 i:挿入")
	(refresh (progn (setq Ufm-exp-IDX 2)(Ufm-exp-refresh Ufm-exp-IDX)(Ic-refresh)))
	(after-exec (progn (Ufm-exp-refresh Ufm-exp-IDX)(Ic-refresh)))
	(keymap Ufm-exp-option-map)
	))

(defvar Ufm-unpack-option '(
	(title "解凍コマンドの設定 D:削除 e:変更 i:挿入")
	(refresh (progn (setq Ufm-exp-IDX 3)(Ufm-exp-refresh Ufm-exp-IDX)(Ic-refresh)))
	(after-exec (progn (Ufm-exp-refresh Ufm-exp-IDX)(Ic-refresh)))
	(keymap Ufm-exp-option-map)
	))

(defvar Ufm-exp-option-map (make-keymap))
(define-key Ufm-exp-option-map [(meta f1)]	'Ufm-exp-del)
(define-key Ufm-exp-option-map "D"			'Ufm-exp-del)
(define-key Ufm-exp-option-map Ic-return-key 'Ufm-exp-mod)
(define-key Ufm-exp-option-map [13]			 'Ufm-exp-mod)
(define-key Ufm-exp-option-map "e"			'Ufm-exp-mod)
(define-key Ufm-exp-option-map "i"			'Ufm-exp-ins)
(define-key Ufm-exp-option-map [f1]			'Ufm-exp-ins)
(define-key Ufm-exp-option-map "\C-x\C-s"	'Ufm-env-save)
(define-key Ufm-exp-option-map [f10]		'Ufm-env-save)
(define-key Ufm-exp-option-map "\C-x\C-f"	'Ufm-env-load)

(defun Ufm-exp-del()
	(U-del Ufm-exp Ic-IDX))

(defun Ufm-exp-mod()
	(U-mod Ufm-exp Ic-IDX (Ufm-exp-get Ufm-exp-IDX)))

(defun Ufm-exp-ins()
	(U-ins  Ufm-exp Ic-IDX (Ufm-exp-get Ufm-exp-IDX)))


(defun Ufm-exp-refresh (I)		;汎用
	(setq Ufm-exp-table (mapcar (function (lambda (A)
		(list (format "%10s  <=> %s" (car A)
		(if (and (eq 'Ufm-macro (car (nth I A)))(stringp (nth 1 (nth I A))))
			(nth 1 (nth I A))
			(if (nth I A)(prin1-to-string(nth I A))"未登録"))))
		))Ufm-exp)))

(defun Ufm-exp-get(I)				;汎用
	(let (A B)
		(setq A (read-from-minibuffer "拡張子 -> " (car (nth Ic-IDX Ufm-exp))))
		(setq B (read-from-minibuffer "実行文 -> " 
			(let ((L (nth I (nth Ic-IDX Ufm-exp))))(if (and (eq 'Ufm-macro (car L))(stringp (nth 1 L)))
				(nth 1 L)(if L (prin1-to-string L)))
			)))
		(setq B (if(equal "" B)nil(if (eq 40 (elt B 0))(car (read-from-string B))(list 'Ufm-macro B))))
		(U-mod (U-mod (apply 'list (nth Ic-IDX Ufm-exp)) I B) 0 A)
		))

;-----
;●ファイル名履歴の編集
(defun Ufm-fihis-refresh ()
	(setq Ufm-fihis-table(mapcar (function (lambda (A) (list A)))file-name-history))
	)
(defvar Ufm-fihis-table	nil)
(defvar Ufm-fihis-option '(
	(title "拡張子実行コマンドの設定 D:削除 e:変更 i:挿入")
	(refresh	(progn (Ufm-fihis-refresh)(Ic-refresh)))
	(after-exec	(progn (Ufm-fihis-refresh)(Ic-refresh)))
	(keymap Ufm-fihis-option-map)
	))
(defvar Ufm-fihis-option-map (make-keymap))
(define-key Ufm-fihis-option-map Ic-return-key	(lambda()(Ufm-view (Ic-idx 0))))
(define-key Ufm-fihis-option-map [13]			(lambda()(Ufm-view (Ic-idx 0))))
(define-key Ufm-fihis-option-map "D" (lambda()(U-del file-name-history Ic-IDX)))
(define-key Ufm-fihis-option-map "e" (lambda()(U-mod file-name-history Ic-IDX (read-from-minibuffer "ファイル名正規表現 -> "))))
(define-key Ufm-fihis-option-map "i" (lambda()(U-ins file-name-history Ic-IDX (read-from-minibuffer "ファイル名正規表現 -> "))))
(define-key Ufm-fihis-option-map "\C-x\C-s"	'Ufm-env-save)
(define-key Ufm-fihis-option-map [f10]		'Ufm-env-save)
(define-key Ufm-fihis-option-map "\C-x\C-f"	'Ufm-env-load)

;--------------------------------------------------------------------------------
;;; ●zip file support extension

(defvar Ufm-zip-table	nil)
(defvar Ufm-zip-option '(
	(keymap Ufm-zip-map)
	(start (Ufm-zip-refresh))
	))
(defvar Ufm-zip-PATH nil)	; 圧縮ファイル名
(defvar Ufm-zip-tmpdir nil)

(defvar Ufm-zip-map (make-keymap))
(define-key Ufm-zip-map "q" 'Ufm-zip-quit)
(define-key Ufm-zip-map Ic-return-key	'Ufm-zip-return)
(define-key Ufm-zip-map [13]			'Ufm-zip-return)
(define-key Ufm-zip-map [left]			 nil)
(define-key Ufm-zip-map [right]			 nil)
(define-key Ufm-zip-map "u"				'Ufm-zip-unpack)
(define-key Ufm-zip-map "D"				'Ufm-zip-delete)

(defun Ufm-zip-mode (PATH)
	(setq Ufm-zip-tmpdir (make-temp-name "/tmp/Ufm-zip-"))
	(make-directory Ufm-zip-tmpdir)
	(setq Ufm-zip-PATH PATH)
	(Ufm-zip-refresh)
	(Ic-specify-node 'Ufm-zip-table 'Ufm-zip-option)
	)

(defun Ufm-zip-quit ()
	(message "Deleting TMP directory ...")
	(call-process 	"rm" nil Ic-name-wine nil "-r" "-f" Ufm-zip-tmpdir)
	(setq Ufm-zip-tmpdir nil)
	(Ic-prev-node)
	)

(defun Ufm-zip-refresh ()

	(setq Ufm-zip-table nil)
	(call-process "unzip" nil (get-buffer-create "*out put buffer*") t "-l" Ufm-zip-PATH)
	(switch-to-buffer "*out put buffer*")
	(goto-char 1)
	(search-forward "----")

	(let  ((N (U-point-to-line (point)))TOP LINE)
		(catch 'BREAK (while t
		(goto-line (1+ N))
		(setq TOP (point))(end-of-line)(setq LINE (buffer-substring TOP (point)))
		(if (string-match "^[- ]*$" LINE)(throw 'BREAK t))
		(setq Ufm-zip-table(append Ufm-zip-table (list(list LINE))))
		(setq N (1+ N)))))

	(kill-buffer "*out put buffer*")
	)

(defun Ufm-zip-return ()
	(let ((FILE (substring (Ic-idx 0) 28 nil)))
		(call-process "unzip" nil Ic-name-wine nil "-d" Ufm-zip-tmpdir Ufm-zip-PATH FILE)
		(select-window Ic-win-wine)
		(delete-other-windows)
		(erase-buffer)
		(insert-file (concat Ufm-zip-tmpdir "/" FILE))
		(Ufm-uView)
	))

(defun Ufm-zip-unpack ()
	(call-process 	"unzip" nil Ic-name-wine nil "-d" (Ufm-dir "解凍先ディレクトリ名 : ") Ufm-zip-PATH (substring (Ic-idx 0) 28 nil))
	)

(defun Ufm-zip-delete ()
	)

;--------------------------------------------------------------------------------
;;; ●lha file support extension

(defvar Ufm-lha-PATH nil)	; 圧縮ファイル名
(defvar Ufm-lha-tmpdir nil)

(defun Ufm-lha-mode (PATH)
	(setq Ufm-lha-tmpdir (make-temp-name "/tmp/Ufm-lha-"))
	(make-directory Ufm-lha-tmpdir)
	(setq Ufm-lha-PATH PATH)
	(Ufm-lha-refresh)
	(Ic-specify-node 'Ufm-lha-table 'Ufm-lha-option)
	)

(defvar Ufm-lha-table	nil)
(defvar Ufm-lha-option '(
	(title " PERMSSN    UID  GID      SIZE  RATIO     STAMP           NAME" t)
	(keymap Ufm-lha-map)
	))
(defvar Ufm-lha-map (make-keymap))

(define-key Ufm-lha-map "q" '(lambda ()
	(message "Deleting TMP directory ...")
	(call-process 	"rm" nil Ic-name-wine nil "-r" "-f" Ufm-lha-tmpdir)
	(setq Ufm-lha-tmpdir nil)
	(Ic-prev-node)))
	;リターン
(define-key Ufm-lha-map Ic-return-key	(lambda ()(Ufm-lha-return)))
(define-key Ufm-lha-map [13]			(lambda ()(Ufm-lha-return)))
(define-key Ufm-lha-map [left] '(lambda ()))
(define-key Ufm-lha-map [right] '(lambda ()))
	;ファイル操作
(define-key Ufm-lha-map "U" '(lambda ()(Ufm-lha-unpack t)(Ufm-lha-refresh)))
(define-key Ufm-lha-map "u" '(lambda ()(Ufm-lha-unpack)(Ufm-lha-refresh)))
(define-key Ufm-lha-map "D" '(lambda ()(Ufm-lha-delete)(Ufm-lha-refresh)))

(defun Ufm-lha-refresh ()
	(setq Ufm-lha-table nil)

	(call-process "lha" nil (get-buffer-create "*out put buffer*") t "l" Ufm-lha-PATH)
	(switch-to-buffer "*out put buffer*")
	(goto-line 2)

	(let  ((N 2)TOP LINE)
		(catch 'BREAK (while t
		(goto-line (1+ N))
		(setq TOP (point))(end-of-line)(setq LINE (buffer-substring TOP (point)))
		(if (string-match "^[- ]*$" LINE)(throw 'BREAK t))
		(setq Ufm-lha-table(append Ufm-lha-table (list(list LINE))))
		(setq N (1+ N)))))

	(kill-buffer "*out put buffer*")
	)

(defun Ufm-lha-return ()
	(let ((FILE (substring (Ic-idx 0) 51 nil)))
		(call-process "lha" nil Ic-name-wine nil "p" Ufm-lha-PATH FILE)
		(select-window Ic-win-wine)
		(delete-other-windows)
		(Ufm-uView)
	))
(defun Ufm-lha-unpack (&optional F)
	(call-process 	"lha" nil Ic-name-wine nil (if F "x" (concat "xw=" (Ufm-dir "解凍先ディレクトリ名 : "))) Ufm-lha-PATH (substring (Ic-idx 0) 51 nil))
	)
(defun Ufm-lha-delete ()
	(call-process 	"lha" nil Ic-name-wine nil "d" Ufm-lha-PATH (substring (Ic-idx 0) 51 nil))
	)

;--------------------------------------------------------------------------------
;;; ●grep support extension

(defvar Ufm-grep-process ())

(defun Ufm-grep-sentinel (process str)
	(message "結果の表示中 ...[結果が多いと時間かかるよ]")
	;(cond
	;((equal str "finished\n")
	;検索結果の表示
	(switch-to-buffer "*out put buffer*")
	(setq Ufm-grep-table nil)
	(let  ((N 1)TOP LINE)
		(goto-line 1)
		(while (char-after(1+(point)))
		(goto-line (1+ N))
		(setq TOP (point))(end-of-line)(setq LINE (buffer-substring TOP (point)))
		(if (string-match "grep:" LINE)()
			(setq Ufm-grep-table(append Ufm-grep-table (list(list LINE))))
			)
		(setq N (1+ N))))
	;
	;(Ic 'Ufm-grep-table 'Ufm-grep-option)
	(if (and(boundp 'Ufm-table)(not (boundp 'Ufm-uView)))
		(progn (Ic-specify-node 'Ufm-grep-table 'Ufm-grep-option)(Ic-refresh))
		(message (concat "Ufm を起動して、" (U-map-to-keystr 'Ufm-regrep-mode Ufm-map) " キーを押し、"))
		)

	;);失敗したとき
	;((equal str "exited abnormally with code [0-9]+\n")	(message "GREP が失敗しとるよ!"))
	;((equal str "[signal-name]\n")						(message "GREP が誰かに止められてるぞ!"))
	;((equal str "[signal-name](core dumped)\n")			(message "GREP がコアダンプしたぜ!"))
	;);最後の後始末
	(kill-buffer "*out put buffer*")
	(setq Ufm-grep-process nil)
	(message "")
	)


(defun Ufm-regrep-mode ()
	"grep 前回の検索結果の再表示"
	(setq Ufm-grep-old nil)
	(Ic-specify-node 'Ufm-grep-table 'Ufm-grep-option)
	)

(defvar	Ufm-grep-table nil)
(defvar	Ufm-grep-option '((notcls-win)
	(title "文字列検索  e:編集 ret:閲覧 q:終了 tab:スーパーマーク \:移動")
	(keymap Ufm-grep-map)
	(refresh (use-local-map Ufm-grep-menu-map))
	))
(defvar Ufm-grep-map (make-keymap))
(define-key Ufm-grep-map Ic-return-key		'Ufm-grep-ret)
(define-key Ufm-grep-map [13]				'Ufm-grep-ret)
(define-key Ufm-grep-map [f1]				'Ufm-grep-help)
(define-key Ufm-grep-map "?"				'Ufm-grep-help)
(define-key Ufm-grep-map "\\"				'Ufm-grep-go)
(define-key Ufm-grep-map "e"				'Ufm-grep-edit)
(define-key Ufm-grep-map "q"				'Ufm-fmenu-quit)
(define-key Ufm-grep-map Ufm-quit-key		'Ufm-fmenu-quit)
(define-key Ufm-grep-map [tab]				'Ufm-grep-super)
(define-key Ufm-grep-map [(meta tab)]		'Ufm-grep-super-all)
(define-key Ufm-grep-map [(control tab)]	'Ufm-super-cls)

(define-key Ufm-grep-map	[menu-bar ret]		'Ufm-grep-ret)
(define-key Ufm-grep-map	[menu-bar help]		'Ufm-grep-help)
(define-key Ufm-grep-map	[menu-bar go]		'Ufm-grep-go)
(define-key Ufm-grep-map	[menu-bar edit]		'Ufm-grep-edit)
(define-key Ufm-grep-map	[menu-bar quit]		'Ufm-fmenu-quit)
(define-key Ufm-grep-map	[menu-bar ssuper]	'Ufm-grep-super)
(define-key Ufm-grep-map	[menu-bar suall]	'Ufm-grep-super-all)
(define-key Ufm-grep-map	[menu-bar cls]		'Ufm-super-cls)

(defvar Ufm-grep-menu-map (U-no-menubar-keymap))
(define-key Ufm-grep-menu-map	[menu-bar quit]		'("Quit"				. quit))
(define-key Ufm-grep-menu-map	[menu-bar help]		'("Help"				. help))
(define-key Ufm-grep-menu-map	[menu-bar cls]		'("Clear-ALL-TAG"		. cls))
(define-key Ufm-grep-menu-map	[menu-bar suall]	'("TAG-ALL"				. suall))
(define-key Ufm-grep-menu-map	[menu-bar ssuper]	'("TAG"					. super))
(define-key Ufm-grep-menu-map	[menu-bar ret]		'("View"				. ret))
(define-key Ufm-grep-menu-map	[menu-bar go]		'("Go"					. go))
(define-key Ufm-grep-menu-map	[menu-bar edit]		'("Edit"				. edit))

(defun Ufm-grep-help ()
	"ヘルプ"
	(select-window Ic-win-wine)
	(delete-other-windows)
	(erase-buffer)
	(insert (concat
	"ｇｒｅｐモード キーバインド表 Ufm (C) 1998 Usuda Hiroshi (終了:q)\n\n"
	(Ufm-keystr 'Ufm-grep-ret			Ufm-grep-map)
	(Ufm-keystr 'Ufm-grep-help			Ufm-grep-map)
	(Ufm-keystr 'Ufm-grep-go			Ufm-grep-map)
	(Ufm-keystr 'Ufm-grep-edit			Ufm-grep-map)
	(Ufm-keystr 'Ufm-grep-super			Ufm-grep-map)
	(Ufm-keystr 'Ufm-grep-super-all		Ufm-grep-map)
	(Ufm-keystr 'Ufm-super-cls			Ufm-grep-map)
	"\n≪ノウハウ≫\n\n"
	"	●キーバインドを変更するには以下のように ~/.emacs の最後に書きます\n"
	"		(define-key Ufm-grep-map [(meta h)]	'Ufm-grep-go)"
	))(goto-char 1)(Ufm-uView)
	)

(defvar Ufm-grep-grep nil)		;正規表現
(defvar Ufm-grep-super nil)		;出力のファイル名に Ufm-dir を concat すべきかどうか

(defun Ufm-grep-mode (&optional POINT SUPER)
	"文字列検索(ディレクトリ位置で実行すると再帰的にサーチする・非同期)"
	(if Ufm-grep-process (message (concat "現在、「" Ufm-grep-grep"」を検索中です。"))(progn (setq Ufm-grep-old nil)(if POINT nil (setq POINT (Ufm-name 'dir)))(cond
	;タグファイルがなくて、スーパータグがあったとき(引数 SUPER が t じゃないとダメ)
	((and SUPER Ufm-super-mark (not Ufm-mark-list))
		(setq Ufm-grep-grep (read-from-minibuffer "スーパータグファイルの文字列検索 Regexp : "))
		(message (concat "スーパータグファイル検索中 ...." Ufm-grep-grep))
		(setq Ufm-grep-super t)
		(setq Ufm-grep-process (apply 'start-process "grep" (get-buffer-create "*out put buffer*")

			"grep" "-n" Ufm-grep-grep "This is Ufm Dummy file" Ufm-super-mark

			)))
	;タグファイルがなくて、ポイントファイルがディレクトリの時
	((and (null Ufm-mark-list)(eq 'dir (Ufm-fmode POINT)))
		(setq Ufm-grep-grep (read-from-minibuffer (concat POINT " 内の文字列検索 Regexp : ")))
		(message (concat POINT"内のディレクトリ 文字列検索中 .... Regexp :" Ufm-grep-grep))
		(setq Ufm-grep-super t)
		(setq Ufm-grep-process (start-process "find" (get-buffer-create "*out put buffer*")

			"find" POINT "-name"(read-from-minibuffer "ワイルドカード (ex *.??.text) : " "*")
				"-exec" "grep" "-n" Ufm-grep-grep "{}" "This is Ufm Dummy file" ";")))

	;タグファイルがあるか、ポイントファイルが通常ファイルの時
	((or Ufm-mark-list(not(eq 'dir (Ufm-fmode POINT))))
		(setq Ufm-grep-grep (read-from-minibuffer (concat (if Ufm-mark-list "タグファイル" (cdr (file-namae POINT))) " 中の文字列検索 Regexp : ")))
		(message (concat (if Ufm-mark-list "タグファイル" (cdr (file-namae POINT)))" 文字列検索中 .... Regexp :" Ufm-grep-grep))
		(setq Ufm-grep-super nil)
		(setq Ufm-grep-process (apply 'start-process "grep" (get-buffer-create "*out put buffer*")

			"grep" "-n" Ufm-grep-grep "This is Ufm Dummy file"
			(if Ufm-mark-list (mapcar (function (lambda (A) (Ufm-name nil A))) Ufm-mark-list)(setq Ufm-grep-super t)(list POINT))

			)))
	)
	(set-process-sentinel Ufm-grep-process 'Ufm-grep-sentinel)
	(message "バックグラウンドで文字列を検索中 ...")
	)))

(defvar Ufm-grep-file ())		;同じファイルを表示するときには、再読み込みしないようにする
(defvar Ufm-grep-old ())
(defun Ufm-grep-ret ()
	"ファイルの該当場所を表示"
	(setq Ic-refresh nil)
	(let ((DATA)(LINE(Ic-idx 0)))
		(if(string-match "^\\(.*\\):\\([0-9]+\\)" LINE)(progn
		(setq DATA (match-data))
		(Ic-write-wine
			(set-match-data DATA)
			(setq Ufm-grep-file (expand-file-name (concat (if Ufm-grep-super nil Ufm-dir) (match-string 1 LINE))))
			(condition-case nil (progn
				(if (equal Ufm-grep-file Ufm-grep-old) nil (erase-buffer)(insert-file Ufm-grep-file)(setq Ufm-grep-old Ufm-grep-file))
				(set-match-data DATA)
				(if (match-string 2 LINE)(goto-line (string-to-number (match-string 2 LINE))))
				(recenter 5)
				(search-forward-regexp Ufm-grep-grep)
				(put-text-property (- (point) (length Ufm-grep-grep))(point) 'face 'R-Blue)
				)(error (message "Hmm ...")))
			)))))

(defun Ufm-grep-go ()
	"該当ファイルの場所に移動"
	(let ((LINE(Ic-idx 0)))
		(if(string-match "^\\(.*\\):\\([0-9]+\\)" LINE)(progn
		    (setq Ufm-go-before Ufm-dir)
		    (setq Ufm-save-cur (cdr (file-namae (match-string 1 LINE))))
		    (setq Ufm-dir (car (file-namae (match-string 1 LINE))))
			)))
	(Ic-prev-node)
	(Ufm-refresh)
	)

(defun Ufm-grep-edit ()
	"該当ファイルを編集"
	(let ((DATA)(LINE(Ic-idx 0)))
		(if(string-match "^\\(.*\\):\\([0-9]+\\)" LINE)(progn
			(Ufm-edit-sub
				nil
				(string-to-number (match-string 2 LINE))
				(expand-file-name (concat (if Ufm-grep-super nil Ufm-dir) (match-string 1 LINE))))
		)))
	)

(defun Ufm-grep-super-all ()
	"全てのファイルをスーパーマークします。f4 キーで一覧表示出来ます。"
	(setq Ic-refresh nil)
	(message (documentation 'Ufm-grep-super-all))
	(setq Ufm-super-mark nil)
	(let ((LEN (length (eval Ic-Table)))(I 0))
		(while (< I LEN)(setq Ufm-super-mark (append Ufm-super-mark (list 
			(let ((LINE(Ic-idx 0 I)))(if(string-match "^\\(.*\\):\\([0-9]+\\)" LINE)(expand-file-name (concat (if Ufm-grep-super nil Ufm-dir) (match-string 1 LINE)))))
		)))(setq I (1+ I)))
	)
	(setq Ufm-super-mark(U-list-itii Ufm-super-mark))
	)

(defun Ufm-grep-super ()
	"カーソル位置の grep 結果をスーパーマークに追加します。f4 キーで一覧表示出来ます。"
	(setq Ic-refresh nil)
	(message (documentation 'Ufm-grep-super))
	(setq Ufm-super-mark (append Ufm-super-mark (list
		(let ((LINE(Ic-idx 0)))(if(string-match "^\\(.*\\):\\([0-9]+\\)" LINE)(expand-file-name (concat (if Ufm-grep-super nil Ufm-dir) (match-string 1 LINE)))))
		)))
	(setq Ufm-super-mark(U-list-itii Ufm-super-mark))
	)

;--------------------------------------------------------------------------------
;;; ●find & namazu support extension


(defvar	Ufm-find-table nil)
(defvar	Ufm-find-option '((notcls-win)
	(title "ファイル検索 (ret:閲覧 \:移動 SPC:閲覧 TAG:スーパーマーク)" t)
	(keymap Ufm-find-map)
	(refresh (use-local-map Ufm-find-menu-map))
	))

(defvar Ufm-find-map (make-keymap))

(define-key Ufm-find-map "q"				'Ufm-fmenu-quit)
(define-key Ufm-find-map Ufm-quit-key		'Ufm-fmenu-quit)
(define-key Ufm-find-map [tab]				'Ufm-find-super)
(define-key Ufm-find-map [f1]				'Ufm-find-help)
(define-key Ufm-find-map "?"				'Ufm-find-help)
(define-key Ufm-find-map [(meta tab)]		'Ufm-find-super-all)
(define-key Ufm-find-map [(control tab)]	'Ufm-super-cls)
(define-key Ufm-find-map "\\"				'Ufm-find-go)
(define-key Ufm-find-map Ic-return-key		'Ufm-find-ret)
(define-key Ufm-find-map [13]				'Ufm-find-ret)
(define-key Ufm-find-map " "				'Ufm-find-view)
(define-key Ufm-find-map "e"				'Ufm-find-edit)

(define-key Ufm-find-map	[menu-bar quit]			'Ufm-fmenu-quit)
(define-key Ufm-find-map	[menu-bar mark]			'Ufm-find-super)
(define-key Ufm-find-map	[menu-bar help]			'Ufm-find-help)
(define-key Ufm-find-map	[menu-bar markall]		'Ufm-find-super-all)
(define-key Ufm-find-map	[menu-bar markdel]		'Ufm-super-cls)
(define-key Ufm-find-map	[menu-bar go]			'Ufm-find-go)
(define-key Ufm-find-map	[menu-bar ret]			'Ufm-find-ret)
(define-key Ufm-find-map	[menu-bar view]			'Ufm-find-view)
(define-key Ufm-find-map	[menu-bar edit]			'Ufm-find-edit)

(defvar Ufm-find-menu-map (U-no-menubar-keymap))

(define-key Ufm-find-menu-map	[menu-bar quit]		'("Quit"						. quit))
(define-key Ufm-find-menu-map	[menu-bar help]		'("Help"						. mark))
(define-key Ufm-find-menu-map	[menu-bar markdel]	'("Clear-ALL-TAG"				. markdel))
(define-key Ufm-find-menu-map	[menu-bar markall]	'("TAG-ALL"						. markall))
(define-key Ufm-find-menu-map	[menu-bar mark]		'("TAG"							. mark))
(define-key Ufm-find-menu-map	[menu-bar view]		'("View"						. view))
(define-key Ufm-find-menu-map	[menu-bar go]		'("Go"							. go))
(define-key Ufm-find-menu-map	[menu-bar edit]		'("Edit"						. edit))


(defvar Ufm-find-process nil)
(defvar Ufm-find-find nil)

(defun Ufm-fmenu-quit ()
	(Ic-prev-node 0)
	)

(defun Ufm-find-view ()
	(Ufm-view (Ic-idx 0))
	)

(defun Ufm-find-edit ()
	(Ufm-edit-sub nil 0	(expand-file-name (Ic-idx 0)))
	)

(defun Ufm-find-help ()
	"ヘルプ"
	(select-window Ic-win-wine)
	(delete-other-windows)
	(erase-buffer)
	(insert (concat
	"ｆｉｎｄモード キーバインド表 Ufm (C) 1998 Usuda Hiroshi (終了:q)\n\n"
	(Ufm-keystr 'Ufm-find-ret			Ufm-find-map)
	(Ufm-keystr 'Ufm-find-go			Ufm-find-map)
	(Ufm-keystr 'Ufm-super-cls			Ufm-find-map)
	(Ufm-keystr 'Ufm-find-super-all		Ufm-find-map)
	(Ufm-keystr 'Ufm-find-super			Ufm-find-map)
	"\n≪ノウハウ≫\n\n"
	"	●キーバインドを変更するには以下のように ~/.emacs の最後に書きます\n"
	"		(define-key Ufm-find-map [(meta h)]	'Ufm-find-go)"
	))(goto-char 1)(Ufm-uView)
	)


(defun Ufm-find-mode (&optional DIR)
	"ディレクトリの検索"
	(if Ufm-find-process (message (concat "現在、「" Ufm-find-find"」を検索中です。"))(progn
	(setq Ufm-find-process (start-process "*Ufm*find*" (get-buffer-create "*out put buffer*")
		"find" (if DIR DIR (expand-file-name (read-file-name "検索するディレクトリ : " Ufm-dir)))
		"-name"	(setq Ufm-find-find (read-from-minibuffer "検索するワイルドカード(ex ???.*.el) : " "*.*")))
		)
	(set-process-sentinel Ufm-find-process 'Ufm-find-sentinel)
	(message "バックグラウンドでファイルを検索中 ...")
	)))

(defun Ufm-find-sentinel (process str)
	(message "結果の表示中 ...[結果が多いと時間かかるよ]")
	(switch-to-buffer "*out put buffer*")
	(setq Ufm-find-table nil)
	(let  ((N 1)TOP LINE)
		(goto-line 1)
		(while (char-after(1+(point)))
		(goto-line N)
		(setq TOP (point))(end-of-line)(setq LINE (buffer-substring TOP (point)))
		(setq Ufm-find-table(append Ufm-find-table (list(list LINE))))
		(setq N (1+ N)))
		)
	;(Ic 'Ufm-find-table 'Ufm-find-option)
	(if (and(boundp 'Ufm-table)(not (boundp 'Ufm-uView)))
		(progn (Ic-specify-node 'Ufm-find-table 'Ufm-find-option)(Ic-refresh))
		(message (concat "Ufm を起動して、" (U-map-to-keystr 'Ufm-refind-mode Ufm-map) " キーを押してね"))
		)
	;);失敗したとき
	;((equal str "exited abnormally with code [0-9]+\n")	(message "GREP が失敗しとるよ!"))
	;((equal str "[signal-name]\n")						(message "GREP が誰かに止められてるぞ!"))
	;((equal str "[signal-name](core dumped)\n")			(message "GREP がコアダンプしたぜ!"))
	;);最後の後始末
	(kill-buffer "*out put buffer*")
	(setq Ufm-find-process nil)
	(message "")
	)


(defun Ufm-refind-mode ()
	"find 前回の検索結果の再表示"
	(Ic-specify-node 'Ufm-find-table 'Ufm-find-option)
	)

(defun Ufm-find-go ()
	"該当ファイルの場所に移動"
	(let ((CELL (file-namae (Ic-idx 0))))
		(setq Ufm-dir (expand-file-name (car CELL)))
		(setq Ufm-save-cur (cdr CELL)))
	(Ic-prev-node 0)
	(Ufm-refresh)
	)

(defun Ufm-find-ret ()
	"該当ファイルを表示"
	(if (eq t (car (file-attributes (expand-file-name (Ic-idx 0))))) (Ufm-find-go)
	(Ic-write-wine
		(erase-buffer)
		(insert-file (expand-file-name (Ic-idx 0)))
	)))

(defun Ufm-find-super-all ()
	"全ての find 結果ファイルをスーパーマークします。f4 キーで一覧表示出来ます。"
	(message (documentation 'Ufm-find-super-all))
	(setq Ufm-super-mark nil)
	(let ((LEN (length (eval Ic-Table)))(I 0))
		(while (< I LEN)(setq Ufm-super-mark (append Ufm-super-mark (list (expand-file-name (Ic-idx 0 I)))))(setq I (1+ I)))
		)
	(setq Ufm-super-mark(U-list-itii Ufm-super-mark))
	)
(defun Ufm-find-super ()
	"カーソル位置の find 結果をスーパーマークに追加。f4 キーで一覧表示出来ます。"
	(message (documentation 'Ufm-find-super))
	(setq Ufm-super-mark (append Ufm-super-mark (list (expand-file-name (Ic-idx 0)))))
	(setq Ufm-super-mark(U-list-itii Ufm-super-mark))
	)

(defun Ufm-namazu()
	"ディレクトリを namazu で全文検索して Netscape に表示する。あらかじめ mknmz /dir/dir でインデックスを作らないといけません。"
	(let (
		(REG (read-from-minibuffer "なまず全文検索 ： "))
		)
	(start-process-shell-command
		"Ufm namazu search" "Ufm namazu search result" "namazu" "-n" "10000" "-h"  "-o" "/tmp/Ufm-namazu.result"
		(Ufm-quote-all REG)
		(if Ufm-namazu-dir Ufm-namazu-dir Ufm-dir)
		";" "netscape" "-remote" "OpenFile\\(/tmp/Ufm-namazu.result\\)"); ";" "rm" "-f" "/tmp/Ufm-namazu.result")
	))

;--------------------------------------------------------------------------------
(defun Ufm-www ()
	"もじらで閲覧"
    (Ufm-macro "netscape -remote OpenFile(%PFILE)")
    )
(defun Ufm-author()(message Ufm-startup))
(defun Ufm-f2-menu ()(Ufm-macro-menu Ufm-f2-file 'Ufm-f2-table))

;--------------------------------------------------------------------------------
;;; ●sed support extension 危険だーおっかねぇー 必ずバックアップしてから実行の事！！

(defvar Ufm-sed-original "Ufm@sed@tmpfile")
(defun Ufm-sed ()
	"ディレクトリを指定して、その下にある指定ファイルに対して、sedコマンド を実行します。"
	(Ufm-sed-do t)
	)
(defun Ufm-sed-do (&optional FLG)
	"	指定ファイルに対して 文字列の置換 を実行します。

	ディレクトリは再帰的に辿ります。
	完全に不可逆的に文字を置換してしまいます。
	必ずバックアップをとってから実行しましょう。

＜正規表現＞
	.       文字一つ
	*		直前の無限回数繰り返し
	?		一文字
	+		0か1文字
	[^ ]	文字列リスト
	^		行の最初
	$		行の終り

	\\       エスケープ文字
	\\(...\\) 後方参照用
	\\n      後方参照(\\1 は最初にマッチした)
	&       マッチした全ての文字列
	/       （は特にエスケープしないで良い）
"
	(interactive)
	(catch 'sed
	(if (progn (ding)(ding)(y-or-n-p "この文字列一括置換機能は非常に危険です。本当に実行しますか？(ファイルが丸々無くなるかも知れません)"))nil(throw 'sed t))
	(let (
			(A(read-from-minibuffer "置換前[正規表現] :"))
			(B(read-from-minibuffer "何に変えちゃおぉかな :"))
			W 
			SED
		)
		(setq A (U-string-replace "/" "\\\\/" A))
		(setq B (U-string-replace "/" "\\\\/" B))
		(setq A (U-string-replace ";" "\\;" A))
		(setq B (U-string-replace ";" "\\;" B))
		(if (and (equal "" A)(equal "" B))
			(progn (ding)(message "おいおいそりゃないだろぉ")(sit-for 3)
			(throw 'sed t)))
		(cond
		;マークファイルがあったら
		(Ufm-mark-list
			(mapcar (function (lambda (n) (let ((F(Ufm-name nil n)))(cond
			((eq 'dir (Ufm-fmode F))
				(Ufm-sed-dir F 
					(if W W (setq W (read-from-minibuffer "検索するファイル名(exp: A??.txt) : " "*.*")))
					A B
					(if FLG (if SED SED (setq W (read-from-minibuffer "SEDコマンド : " "d"))))
					))
			((eq 'file (Ufm-fmode F))
				(Ufm-sed-file
					F A B
					(if FLG (if SED SED (setq W (read-from-minibuffer "SEDコマンド : " "d"))))
					))
			))))
			Ufm-mark-list)
			)
		;マークファイルが無かったら
		(t (Ufm-sed-dir
			(read-file-name "検索するディレクトリ : " (if (boundp 'Ufm-dir)Ufm-dir))
			(read-from-minibuffer "検索するファイル名(exp: A??.txt) : " "*.*")
			A B (if FLG (if SED SED (setq W (read-from-minibuffer "SEDコマンド : " "d"))))))
		)))
	)

; DIR をWILDCARDで再帰サーチして、ファイルの中の A を B に変換する
(defun Ufm-sed-dir (DIR WILD a b &optional SED)
		(start-process "Ufm-sed" (get-buffer-create "*out put buffer*")
		"find" (expand-file-name DIR) "-name" WILD "-and" "-type" "f" "-exec" "sh" "-c"
		(concat "sed -e " (if SED SED (concat "s/" a "/" b "/g")) " {} > {}." Ufm-sed-original
		" ; if [ -s {} ]
then rm {}
mv {}." Ufm-sed-original " {}
fi")
		";"
	))

; FILE の中の A を B に変換する
(defun Ufm-sed-file (FILE a b SED)
	(let ((p (start-process-shell-command "Ufm+sed" (get-buffer-create "*out put buffer*")
		"sed" "-e" (if SED SED (concat "\"s/" a "/" b "/g\"")) FILE ">" (concat FILE Ufm-sed-original))))
		(while (not (eq 'exit (process-status p)))(accept-process-output p))
		(if(eq 0(nth 7 (file-attributes FILE)))(progn
			(message (concat FILE " は、その正規表現で置換すると真っ白になります。"))(ding)(sit-for 5))
			(delete-file FILE)(rename-file (concat FILE Ufm-sed-original) FILE)
			)
		))

;文字コードの変換
(defun Ufm-kcc (&optional FLG)
	"ディレクトリを指定して、その下にある全てのファイルに対してkccコマンドを実行します。"
	(interactive)
	(if (progn (ding)(ding)(y-or-n-p "この文字コード一括変換は危険です。本当に実行しますか？(ファイルが丸々無くなるかも知れません)"))(progn
	(start-process "Ufm kcc" (get-buffer-create "*out put buffer*")
		"find"
		(read-file-name "検索するディレクトリ : " (if (boundp 'Ufm-dir)Ufm-dir))
		"-name"	(read-from-minibuffer "検索するワイルドカード(ex ???.*.el) : " "*.*")
		"-exec" "sh" "-c" 
		(concat "kcc "(read-from-minibuffer "kcc command : " "-e")  " {} > {}." Ufm-sed-original " ; rm {} ; mv {}." Ufm-sed-original " {}")
		";"
	))))

;--------------------------------------------------------------------------------
;;; ●floppy support extension
;;
;;	■ キーバインド
;;
;;	q			おしまい
;;	.			再検索
;;	/			ファイル名の表示
;;	return		閲覧
;;	c			コピー(マークファイル対応)
;;	D			消去(マークファイル対応)
;;	r			名前変更
;;	m			移動
;;	k			ディレクトリ作成
;;	a			アトリビュート変更
;;	l			ボリュームラベル変更
;;	F			mformat による簡易フォーマット
;;	$			fdformat による物理フォーマット
;;	
;;	SPACE		マーク
;;	[f12]		ファイルコピーに関するもの

(defun Ufm-a-mode ()
	(interactive)
	(Ufm-a-refresh)
	(Ic 'Ufm-a-table 'Ufm-a-option)
	(Ufm-refresh)
	)

(defconst Ufm-a-dir		"/"	)		; ディレクトリ

(defvar Ufm-a-table	nil)
(defvar Ufm-a-option '((keymap Ufm-a-map)))

(defvar Ufm-a-map (make-keymap))
	;終了
(define-key Ufm-a-map "q"	(lambda ()(Ic-quit)))
(define-key Ufm-a-map "."	(lambda ()(Ufm-a-refresh)))
(define-key Ufm-a-map "/"	(lambda ()(message (concat "a:" Ufm-a-dir (Ic-idx 1)))))
	;リターン
(define-key Ufm-a-map Ic-return-key	(lambda ()(Ufm-a-return)))
(define-key Ufm-a-map [13]			(lambda ()(Ufm-a-return)))
(define-key Ufm-a-map [left]			(lambda ()(setq Ufm-a-dir "/")(Ufm-a-refresh)))
(define-key Ufm-a-map [right]		(lambda ()))
	;ファイル操作
(define-key Ufm-a-map "c" 'Ufm-a-copy			)
(define-key Ufm-a-map "D" 'Ufm-a-delete		)
(define-key Ufm-a-map "r" 'Ufm-a-rename		)
(define-key Ufm-a-map "m" 'Ufm-a-move			)
(define-key Ufm-a-map "k" 'Ufm-a-mkdir		)
(define-key Ufm-a-map "a" 'Ufm-a-attrib		)
(define-key Ufm-a-map "l" 'Ufm-a-label		)
(define-key Ufm-a-map "F" '(lambda ()
	(if (y-or-n-p "本当にフォーマットしていいんだな？(物理フォーマットは $ だよ) ")
		(call-process "mformat" nil Ic-name-wine nil "a:"))
		(Ufm-a-refresh)))
(define-key Ufm-a-map "$" '(lambda ()
	(if (y-or-n-p "物理フォーマットしてしまうぞ！")
		(progn (start-process "*Ufm-a-format*" Ic-name-wine "superformat" "/dev/fd0")(message "ことが終わるまで少し待ってろ")))
		(Ic-quit)))
(define-key Ufm-a-map " " 'Ufm-a-mark)
(define-key Ufm-a-map [f12] 'Ufm-a-over-mode)

;リフレッシュ
(defun Ufm-a-refresh ()
	(unwind-protect(progn
;set some variable
	(setq Ufm-a-table nil)
	(setq Ufm-a-mark-list nil)

;call mdir command
	(call-process "mdir" nil (get-buffer-create "*out put buffer*") t Ufm-a-dir)
	(switch-to-buffer "*out put buffer*")

	(goto-line 4)
	(if(eq 10 (char-after))	(goto-line 5))		; シリアルナンバーがあったり無かったりするのでね。

	(cond
	((eq (point) (point-max))(setq Ufm-a-table '(("フロッピーが入ってないよ。ｑ を押しなよ"))))
	((or	(equal "File \"*\" not found" (buffer-substring (point) (+ 18 (point))))
			(string-match "No files" (buffer-substring (point) (+ 18 (point)))))		(setq Ufm-a-table '(("ファイルがひとつもないよ。ｑ でおしまい"))))
	(t
;table set loop
	(let  ((N 0)(NN 0)TOP LINE)
		(while (not (eq 32 (char-after(point))))(catch 'NEXT
		(setq TOP (point))(end-of-line)(setq LINE (buffer-substring TOP (point))); 出力から行の取り出し -> LINE
;項目設定
;		(string-match Ufm-a-purse LINE)
		(setq Ufm-a-table(append Ufm-a-table (list(list
;0 表示文字列
		LINE
;1 リターン
		(progn
				(string-match "\\([^ ]*\\) +\\([^ ]*\\)" (substring LINE 0 13))
				(let ((FILE (U-nth-match  1 (match-data) LINE))(EXP (U-nth-match  2 (match-data) LINE)))
				(if (equal "" EXP)FILE(concat  FILE "." EXP)))
		)
;2 ｗｉｎｅ表示
		nil
;3 次のノード
		nil
		nil
;5 ユーザ領域
		(if (string-match " <DIR>" LINE) 'dir 'file)
;6 選択時の色
		(append (list(list 0 0 12 (cond
			((string-match "<DIR>" LINE)			'R-Blue		)			;ディレクトリ
			(t										'R-Yellow	)			;通常ファイル
		)))
		(list (list 0 41 'end(if (string-match "<DIR>" LINE)	'C-Blue 'C-Yellow)))
		)
;7 非選択時の色
		(append (list(list 0 0 12 (cond
			((string-match "<DIR>" LINE)			'C-Blue		)			;ディレクトリ
			(t										'C-Yellow	)			;通常ファイル
		)))
		)
;次の行の解析
	)))))
	(setq N (1+ N))(goto-line (+ 5 N))))
	(let((STR(buffer-substring (point)(point-max))))
		(string-match "\\([0-9]+\\) +file(s) +\\([0-9 ]+\\) bytes\n +\\([0-9 ]+\\) bytes" STR)
		(message (format "ファイル数 %s , 全ファイル %s Byte, 空き領域 %s Byte" (match-string 1 STR) (match-string 2 STR) (match-string 3 STR))))
	)))
;kill buffer
	(kill-buffer "*out put buffer*"))
	)
;リターン
(defun Ufm-a-return ()
	(let ((FILE (concat Ufm-a-dir (Ic-idx 1))))
		(if (string-match " <DIR>" (Ic-idx 0))
			(progn (setq Ic-IDX 1)(setq Ufm-a-dir (expand-file-name(concat FILE "/"))))
			(progn
				(delete-other-windows)
				(erase-buffer)
				(call-process "mtype" nil Ic-name-milk nil (concat "a:" FILE))
				(goto-line 1)
				(font-lock-mode)(Ufm-uView)(font-lock-mode)
			))
	)
	(Ufm-a-refresh)
	)

;コピー

(defun Ufm-a-copy ()
	(let (OO)(if (eq (Ic-idx 5) 'dir)(message "ディレクトリの一括コピーは今のところサポートしていないよ")
		(eval (`(start-process "mdir-read" Ic-name-wine "mread" Ufm-a-over-mode

		;ファイル名群 ("a:1" "a:2" "a:3" ...)
		(,@ (progn (if Ufm-a-mark-list ()(setq Ufm-a-mark-list (list Ic-IDX))(setq OO t))
			(mapcar (function (lambda (A) (concat "a:"(Ic-idx 1 A)))) Ufm-a-mark-list)
			))
		;コピー先
		(, (if OO

			;ファイル名指定
				(Ufm-get-filename "読み込み先 : "
					(let ((NAME (condition-case nil (substring (Ic-idx 0)  42 nil) (error nil))))
					(if NAME NAME ".")) '-)

			;ディレクトリ指定(TAGファイル一括の時)
			(let (R (O t))(while O
				(setq R (Ufm-dir "読み込み先 : "))
				(if (setq O (member t (mapcar (function (lambda (A) (file-exists-p (concat R (substring (Ic-idx 0 A)  42 nil))))) Ufm-a-mark-list)))
					(progn (message "読み込み先ディレクトリに同名のファイルがあるから、消してからにしようぜ")(sit-for 1)))
				)R)
			))
		)))
	)(if OO (setq Ufm-a-mark-list nil))))

;削除
(defun Ufm-a-delete ()
	(if Ufm-a-mark-list
	;ファイル沢山
	(let ((I 0)(LEN (length Ufm-a-mark-list)))(while (< I LEN)(let ((TMP (nth I Ufm-a-mark-list)))
		(message (concat "ファイル削除中 : " "a:" Ufm-a-dir(Ic-idx 1 TMP)))
		(if (eq 0 (call-process (if (eq (Ic-idx 5 TMP) 'dir) "mrd" "mdel") nil Ic-name-wine nil (concat "a:" Ufm-a-dir(Ic-idx 1 TMP))))
			()(message "削除に失敗しちまったよ"))
	(setq I (1+ I)))))
	;ファイル一つ
	(if(y-or-n-p (concat (condition-case nil (substring (Ic-idx 0)  42 nil)(error (Ic-idx 1)))" => ホントに消していいんだな？ "))
		(if (eq 0 (call-process 	(if (eq (Ic-idx 5) 'dir) "mrd" "mdel") nil Ic-name-wine nil (concat "a:" Ufm-a-dir (Ic-idx 1))))
			()(message "削除に失敗しました"))
	))(Ufm-a-refresh))

;名前・移動・ディレクトリ作成・属性
(defun Ufm-a-rename ()
	(call-process "mren" nil Ic-name-wine nil
		(concat "a:" Ufm-a-dir (Ic-idx 1))
		(read-from-minibuffer "変更する名前 : "))
	(Ufm-a-refresh))

(defun Ufm-a-move ()
		(call-process "mmove" nil Ic-name-wine nil
				(concat "a:" Ufm-a-dir (Ic-idx 1))
				(read-from-minibuffer "移動先 : ")
	)(Ufm-a-refresh))

(defun Ufm-a-mkdir ()
		(call-process "mmd" nil Ic-name-wine nil
				(read-from-minibuffer "ディレクトリの名前 : ")
	)(Ufm-a-refresh))

(defun Ufm-a-attrib ()
		(call-process "mattrib" nil Ic-name-wine nil
				(read-from-minibuffer "[-|+ a h r s] バックアップ、書き込み禁止、システム、隠しファイル ： ")
				(concat "a:" Ufm-a-dir (Ic-idx 1))
	)(Ufm-a-refresh))

(defun Ufm-a-label ()
	;(let ((PRO (start-process "Mdir label" Ic-name-wine "mlabel" "a:")))
		;(process-send-string PRO(read-from-minibuffer "フロッピーのラベル名 : "))
	);)

;マーク
(defvar Ufm-a-mark-list nil)

(defun Ufm-a-mark (&optional IDX FORCE)
	(if IDX ()(setq IDX Ic-IDX))
	(let ((N(U-htn Ufm-a-mark-list IDX)))(if (or (eq 'off FORCE)(and (null FORCE) N))
	;消す
	(progn	(if N (U-del Ufm-a-mark-list N))
			(Ic-idx 7 IDX nil t
				(let ((LINE (Ic-idx 0 IDX)))
		(append (list(list 0 0 12 (cond
			((string-match "<DIR>" LINE)			'C-Blue		)			;ディレクトリ
			(t										'C-Yellow	)			;通常ファイル
		)))
		(list (list 0 41 'end(if (string-match "<DIR>" LINE)	'C-Blue 'C-Yellow)))
		)
			))
			)
	;付ける
		(if N ()(setq Ufm-a-mark-list (append Ufm-a-mark-list (list IDX))))				; IDX -> Ufm-a-mark-llist
		(U-modq (Ic-idx 7) 0 (list 0 0 12 'R-Red))
	))(Ic-down))

;上書きモード
(defun Ufm-a-over-mode ()
	(Ic 'Ufm-a-over-table 'Ufm-a-over-option)
	)
;-----
;●フロッピー上書きモード
(defvar Ufm-a-over-mode "-a")
(defvar Ufm-a-over-option '(
	(title "同じファイルがあったらどうする？")
	(short-cut)(short-disp)
	(keymap Ufm-a-over-map)
	))

(defvar Ufm-a-over-map (make-keymap))
(define-key Ufm-a-over-map Ic-return-key	(lambda ()(setq Ufm-a-over-mode (Ic-idx 1))(Ic-quit)))
(define-key Ufm-a-over-map [13]				(lambda ()(setq Ufm-a-over-mode (Ic-idx 1))(Ic-quit)))
(define-key Ufm-a-over-map "\C-x\C-s" 'Ufm-env-save)
(define-key Ufm-a-over-map [f10] 'Ufm-env-save)

(defvar Ufm-a-over-table '(
	("上書き"			"-o"nil nil nil nil nil nil 111)
	("名前変更"			"-a"nil nil nil nil nil nil 97)
	("コピーしない"		"-s"nil nil nil nil nil nil 115)
	))

;	("UNIX 名で 上書き"						"-O"nil nil nil nil nil nil 79)
;	("UNIX 名で 名前変更"					"-A"nil nil nil nil nil nil 65)
;	("UNIX 名で ぶつかったら上書きしない"	"-S"nil nil nil nil nil nil 83)
;	("Renames primary name"				"-r"nil nil nil nil nil nil 114)
;	("Renames secondary name"			"-R"nil nil nil nil nil nil 82)
;	("Ask user what to do with primary name."		"-m"nil nil nil nil nil nil 109)
;	("Ask user what to do with secondary name."		"-M"nil nil nil nil nil nil 77)

;--------------------------------------------------------------------------------
;;; ● tar & gz file support extension
;;	
;;	<キーバインド>
;;	q			おしまい
;;	u			解凍
;;	D			削除
;;	return		閲覧
;
;;TAR ファイルの閲覧
;
;	/tmp/Ufm-tar-???? と云う、一時ディレクトリを、作成
;	tvfz でファイル名をリストアップ
;	リターンキーが押されたら、一時ディレクトリに解凍
;	最後にテンポラリファイルを消去

(defvar Ufm-tar-num 51)
(defvar Ufm-tar-reg "^\\([-rwxSs]+\\)[ \t]+\\([^ \t]+\\)[ \t]+\\([0-9]+\\)[ \t]+\\([^ \t]+\\)[ \t]+\\([^ \t]+\\)[ \t]+\\(.+\\)")


;tar の出力形式を見定めないとなあ
;
;(setq STR "-rw-r--r-- hiro/hiro         19185 1990-02-03 14:09:27 icon.txt")
;(match-string 1 STR)	;ファイル属性
;(match-string 2 STR)	;オーナー
;(match-string 3 STR)	;サイズ
;(match-string 4 STR)	;作成日
;(match-string 5 STR)	;作成時
;(match-string 6 STR)	;ファイル名


;-rw-r--r-- hiro/root     50823 1997-05-20 07:11:13 .Ufm-f2.macro

(defun Ufm-tar-mode (PATH)
	(interactive (list (read-file-name "アーカイブファイル名 : ")))
	(let(
		(Ufm-tar-table	nil)		; テーブル
		(Ufm-tar-tmpdir nil)		; 解凍テンポラリファイル名
		(Ufm-tar-PATH nil)			; 圧縮ファイル名
		(Ufm-tar-mode nil)			; 圧縮されているか
		)
	(setq Ufm-tar-tmpdir (concat (make-temp-name "/tmp/Ufm-tar-") "/"))		;一時解凍ファイルの格納ディレクトリを作る
	(make-directory Ufm-tar-tmpdir)
	(Ufm-tar-refresh (expand-file-name PATH))								;リフレッシュしてから
	(Ic 'Ufm-tar-table 'Ufm-tar-option)									;Ic ループに突入
	))

;;●GZ ファイルの閲覧
(defun Ufm-do-gz (PATH)
	(let* (
		Ufm-dir;
		(DIR (concat (make-temp-name "/tmp/Ufm-gz-")"/"))
		(FILE (concat DIR (cdr (file-namae PATH))))
		)
	(unwind-protect (progn						;一時ディレクトリに解凍する
		(make-directory DIR)
		(setq default-directory DIR)
		(let ((PROC (start-process-shell-command DIR nil "gzip" "-d" PATH "-c" ">" (file-name-sans-extension FILE))))
		(while (not (eq 'exit (process-status PROC)))
			(accept-process-output PROC)
			))
		(setq Ufm-dir DIR)						;その位置で、拡張子に応じた動作をさせる
		(setq Ufm-save-cur (file-name-sans-extension (cdr (file-namae FILE))));
		(Ufm-refresh)
		(Ufm-do-exp (file-name-sans-extension FILE))
	)
	(condition-case nil (delete-file (file-name-sans-extension FILE))(error))
	(condition-case nil (delete-directory DIR)(error))
	))
	(setq Ufm-save-cur (cdr (file-namae PATH)))
	(Ufm-refresh)								;Ufm-macro を使うために強引にリフレッシュさせてる
	)

;
;●TAR ファイル閲覧キーバインド
(defvar Ufm-tar-table	nil)
(defvar Ufm-tar-option	'((keymap Ufm-tar-map)))
(defvar Ufm-tar-map (make-keymap))

	;終了
(define-key Ufm-tar-map "q"					'Ufm-tar-quit)
(define-key Ufm-tar-map [backspace]			'Ufm-tar-quit)
	;リターン
(define-key Ufm-tar-map Ic-return-key		'Ufm-tar-return)
(define-key Ufm-tar-map [13]				'Ufm-tar-return)
(define-key Ufm-tar-map [left]				(lambda()))
(define-key Ufm-tar-map [right]				(lambda()))
	;ファイル操作
(define-key Ufm-tar-map "u"					'Ufm-tar-unpack)
(define-key Ufm-tar-map "D"					'Ufm-tar-delete)
;
;●リフレッシュ
(defun Ufm-tar-refresh (PATH)
	(unwind-protect (progn
;set some variable
	(setq Ufm-tar-table nil)
	(setq Ufm-tar-mode	(cond
		((string-match "tar$"	PATH) nil)
		((string-match "gz$"	PATH) "z")
		((string-match "taz$"	PATH) "z")
		((string-match "Z$"		PATH) "Z")
		((string-match "bz$"	PATH) "I")
		((string-match "bz2$"	PATH) "I")
		))
	(setq Ufm-tar-PATH PATH)

;call TAR command
	(call-process "tar" nil (get-buffer-create "*out put buffer*") t (concat "tvf" Ufm-tar-mode) PATH)
	(switch-to-buffer "*out put buffer*")(goto-line 1)

;table set loop
	(let  ((N 0)(NN 0)TOP LINE)
		(while (char-after(1+(point)))(catch 'NEXT
		(goto-line (1+ N))
		(setq TOP (point))(end-of-line)(setq LINE (buffer-substring TOP (point))); 出力から行の取り出し -> LINE

		(cond ((string-match "^/bin/tar:" LINE) (setq N (1+ N))(throw 'NEXT t)))

;	(string-match Ufm-tar-purse LINE)
;	(setq LINE "drwxr-xr-x root/root         0 Jan 18 18:19 1995 fortran/")
;	(if (eq ?/ (elt LINE (1- (length LINE))))	;最後の文字が / ならばでぃれくとりじゃ
;		
;		)
		(setq Ufm-tar-table(append Ufm-tar-table (list(list
		LINE										;0 表示文字列		drwxr-xr-x root/root         0 Jan 18 18:19 1995 fortran/
		nil											;1 リターン
		nil											;2 ｗｉｎｅ表示
		(if (string-match "^d" LINE) (list nil))	;3 次のノード table
		(if (string-match "^d" LINE) Ufm-tar-option);4 次のノード option
		LINE										;5 ユーザ領域;		(if	(string-match "^d" LINE) 'dir 'file)	;5 ユーザ領域
		(append (list(list 0 Ufm-tar-num 'end (cond	;6 選択時の色
				((string-match "^d" LINE)			'R-Blue		)			;ディレクトリ
				(t									'R-Yellow	)			;通常ファイル
				)))
			)
		(append (list(list 0 Ufm-tar-num 'end (cond	;7 非選択時の色
				((string-match "^d" LINE)			'C-Blue		)			;ディレクトリ
				(t									'C-Yellow	)			;通常ファイル
				))))
		))))
	(setq N (1+ N))))))
;kill buffer
	(kill-buffer "*out put buffer*")
	))

;●閲覧
(defun Ufm-tar-return ()
	(let* (
		(FILE		(let ((S (Ic-idx 0)))(string-match Ufm-tar-reg S)(match-string 6 S)))
					;(substring (Ic-idx 0) Ufm-tar-num nil))
		(TMPFILE	(concat Ufm-tar-tmpdir FILE))
		)
	(if (file-exists-p TMPFILE)()
		(let ((OLD default-directory))
		(setq default-directory Ufm-tar-tmpdir)
		(call-process "tar" nil Ic-name-wine nil (concat "xvf" Ufm-tar-mode) Ufm-tar-PATH FILE); "-C" Ufm-tar-tmpdir))
		(setq default-directory OLD)
		))
	(Ufm-do-exp TMPFILE)
	))
;●解凍
(defun Ufm-tar-unpack ()
	(let (
;		(FILE	(substring (Ic-idx 0) Ufm-tar-num nil))
		(FILE		(let ((S (Ic-idx 0)))(string-match Ufm-tar-reg S)(match-string 6 S)))
		(DIR	(Ufm-dir "展開先ファイル名"))
		(OLD	default-directory)
		)
		(setq default-directory DIR)
		(call-process "tar" nil Ic-name-wine nil (concat "xvf" Ufm-tar-mode) Ufm-tar-PATH FILE); "-C" Ufm-tar-tmpdir))
		(setq default-directory OLD)
	))
;●削除
(defun Ufm-tar-delete ()
	(let (
;		(FILE (substring (Ic-idx 0) Ufm-tar-num nil))
		(FILE		(let ((S (Ic-idx 0)))(string-match Ufm-tar-reg S)(match-string 6 S)))
		)
	(if Ufm-tar-mode (message "圧縮ファイルの途中削除は出来ないよ")
	(call-process 	"tar" nil Ic-name-wine nil "--delete" "-f" Ufm-tar-PATH FILE)
	(Ufm-tar-refresh Ufm-tar-PATH)
	(message (concat FILE "--> 削除したよ"))
	)))
;●おしまい
(defun Ufm-tar-quit ()
	(message "Deleting TMP directory ...")
	(call-process 	"rm" nil Ic-name-wine nil "-r" "-f" Ufm-tar-tmpdir)
	(setq Ufm-tar-tmpdir nil)
	(Ic-quit)
	)

;--------------------------------------------------------------------------------
;;; ●process support extension

(defun Ufm-ps-mode ()
	"プロセスをみちゃうっ！"
	(Ufm-ps-refresh)
	(Ic-specify-node 'Ufm-ps-table 'Ufm-ps-option)
	(save-excursion (select-window (get-buffer-window Ic-name-wine))
	(erase-buffer)
	(insert "
	●使い方

	q		終わり
	x		色々表示
	.		再検索
	D		TERM
	K		KILL
	Q		QUIT
	I		INT
	s		シグナル送る

	●木構造表示しちゃったりして

	")
	(condition-case nil (set-process-sentinel (start-process "?pstree?" Ic-name-wine "pstree") 'Ufm-ps-sent)(error (insert "pstree command not found!!")))
	))

(defun Ufm-ps-sent(A B)
	(select-window Ic-win-wine)
	(goto-char 1)
	(select-window Ic-win-milk)
	)

(defvar  Ufm-ps-exe nil)
(defvar  Ufm-ps-table nil)
(defvar Ufm-ps-option '(
	(notcls-win)
	(title "  PID TTY      時間     コマンドライン" t)
    (refresh (progn
		(use-local-map Ufm-ps-menu-map)
        ))
	(keymap Ufm-ps-map)
	))
(defvar Ufm-ps-map (make-keymap))
(define-key Ufm-ps-map [left]				(lambda()))
(define-key Ufm-ps-map [right]				(lambda()))
(define-key Ufm-ps-map "q"					'Ufm-ps-quit)
(define-key Ufm-ps-map [menu-bar quit]		'Ufm-ps-quit)
(define-key Ufm-ps-map "x"					'Ufm-ps-expand)
(define-key Ufm-ps-map [menu-bar exp]		'Ufm-ps-expand)
(define-key Ufm-ps-map "."					'Ufm-ps-refresh)
(define-key Ufm-ps-map [menu-bar refresh]	'Ufm-ps-refresh)
(define-key Ufm-ps-map "K"					'Ufm-ps-kill)
(define-key Ufm-ps-map [menu-bar kill]		'Ufm-ps-kill)
(define-key Ufm-ps-map "D"					'Ufm-ps-delete)
(define-key Ufm-ps-map [menu-bar term]		'Ufm-ps-delete)
(define-key Ufm-ps-map "Q" (lambda ()(Ufm-ps-delete "-QUIT")))
(define-key Ufm-ps-map "I" (lambda ()(Ufm-ps-delete "-INT")))
(define-key Ufm-ps-map "s" (lambda ()(Ufm-ps-send)))

(defvar Ufm-ps-menu-map (make-keymap))
(define-key Ufm-ps-menu-map [menu-bar files]		'undefined)		;global-map の定義を上書きする
(define-key Ufm-ps-menu-map [menu-bar tools]		'undefined)
(define-key Ufm-ps-menu-map [menu-bar edit]			'undefined)
(define-key Ufm-ps-menu-map [menu-bar search]		'undefined)
(define-key Ufm-ps-menu-map [menu-bar help-menu]	'undefined)
(define-key Ufm-ps-menu-map [menu-bar options]		'undefined)
(define-key Ufm-ps-menu-map [menu-bar buffer]		'undefined)
(define-key Ufm-ps-menu-map [menu-bar mule]			'undefined)
(define-key Ufm-ps-menu-map [menu-bar quit]			'("Quit" . quit))
(define-key Ufm-ps-menu-map [menu-bar refresh]		'("refresh" . refresh))
(define-key Ufm-ps-menu-map [menu-bar exp]			'("eXpand" . exp))
(define-key Ufm-ps-menu-map [menu-bar term]			'("Term" . term))
(define-key Ufm-ps-menu-map [menu-bar kill]			'("Kill" . kill))


(defun Ufm-ps-expand ()
	(setq Ic-IDX 0)
	(setq Ufm-ps-exe (if Ufm-ps-exe nil (if (eq 'w32 window-system) nil "x")))
	(Ufm-ps-refresh)
	)

(defun Ufm-ps-quit ()
	(setq Ufm-ps-tmpdir nil)
	(Ic-prev-node)
	)

(defun Ufm-ps-kill ()
	(Ufm-ps-delete "-KILL")
	)

(defvar Ufm-ps-buf "*Ufm ps buf*")
(defun Ufm-ps-refresh ()
	(call-process "ps" nil (get-buffer-create Ufm-ps-buf) t (concat "-a" Ufm-ps-exe))
	(switch-to-buffer Ufm-ps-buf)
	(setq Ufm-ps-table nil)
	(let  ((N 1)TOP LINE)
		(goto-line 2)
		(while (char-after(1+(point)))
		(goto-line (1+ N))
		(setq TOP (point))(end-of-line)(setq LINE (buffer-substring TOP (point)))
		(setq Ufm-ps-table(append Ufm-ps-table (list(list LINE))))
		(setq N (1+ N))))
	(kill-buffer Ufm-ps-buf)
	)
(defun Ufm-ps-delete (&optional SEND)
	(call-process 	"kill" nil Ic-name-wine nil (if SEND SEND "-TERM")(number-to-string (string-to-number (nth 0 (split-string (Ic-idx 0))))))
	(Ufm-ps-refresh)
	)
(defun Ufm-ps-send ()
	(call-process 	"kill" nil Ic-name-wine nil
			(read-from-minibuffer "SEND SIGNAL : " "-QUIT" nil nil 'Ufm-ps-hist)
			(number-to-string (string-to-number (nth 2 (split-string (Ic-idx 0)))))
			)
	(Ufm-ps-refresh)
	)

(defvar Ufm-ps-hist '(
	"--1"		;(super-user broadcast to all processes, or user broadcast to user's processes)
	"-0"		;(sh(1) only, signals all members of process group)
	"-INT"		;(interrupt)
	"-QUIT"		;(quit)
	"-ABRT"		;(abort)
	"-KILL"		;(non-catchable, non-ignorable kill)
	"-ALRM"		;(alarm clock)
	"-TERM"		;(software termination signal)
	))

;-------------------------------------------------------------------------------------------------
;;●マウスの動作
(defun Ufm-mouse-1()
    (if (eq Ic-win-wine (posn-window (event-start last-input-event)))
		(Ic-mouse-1)
		(Ic-mouse-2)
		)
	)
(defun Ufm-mouse-2()
	(Ic-mouse-2)
	(Ufm-info)
	)
;(defvar Ufm-mouse-3 (make-sparse-keymap))
;(define-key Ufm-mouse-3 [print] '("" . Ufm-print))
(defun Ufm-mouse-3()
	)

;(defun Ufm-mouse-w32()
;	(w32-get-mouse-wheel-scroll-lines (nth 4 (nth 0 (event-start last-input-event))))
;	)


;-------------------------------------------------------------------------------------------------
;;●ヘルプ


(defun Ufm-helpkey()
	"押されたキーのヘルプを表示します"
	(message "簡単ヘルプ(なにかキーを押してください)")
	(let* ((KEY (read-event))(FUNC (lookup-key Ufm-map (vector KEY))))
		(message (concat (U-event-string KEY)" "(if (functionp FUNC)(documentation FUNC)"に対する関数は設定されていないよーだな")))
	))

(defmacro Ufm-keystr (FUNC &optional MAP STR)(`
	(format "%10s : %s\n" (U-map-to-keystr (, FUNC) (, (if MAP MAP 'Ufm-map)))(if (, STR) (, STR) (documentation (, FUNC))))
	))

(defun Ufm-help ()
	"ヘルプ(じゃあこのヘルプはどうやってみつけるんだよ)"
	(select-window Ic-win-wine)
	(delete-other-windows)
	(erase-buffer)
	(insert (concat
	"Ufm ファイルマネージャ (C) 1998 Usuda Hiroshi (終了:q)\n\n"
	(Ufm-keystr 'Ufm-helpkey)
	"\n≪ファイル一般的機能≫\n\n"
	(Ufm-keystr 'Ufm-copy)
	(Ufm-keystr 'Ufm-move)
	(Ufm-keystr 'Ufm-leave)
	(Ufm-keystr 'Ufm-delete)
	(Ufm-keystr 'Ufm-attribute)
	(Ufm-keystr 'Ufm-rename)
	(Ufm-keystr 'Ufm-rename2)
	(Ufm-keystr 'Ufm-slink)
	(Ufm-keystr 'Ufm-hlink)
	(Ufm-keystr 'Ufm-edit)
	(Ufm-keystr 'Ufm-bin-edit)
	(Ufm-keystr 'Ufm-view)
	(Ufm-keystr 'Ufm-pack)
	(Ufm-keystr 'Ufm-pack-gz)
	(Ufm-keystr 'Ufm-unpack)
	(Ufm-keystr 'Ufm-exec)
	"\n≪ディレクトリ関連≫\n\n"
	(Ufm-keystr 'Ufm-up)
	(Ufm-keystr 'Ufm-go-before)
	(Ufm-keystr 'Ufm-chgdir)
	(Ufm-keystr 'Ufm-re-refresh)
	(Ufm-keystr 'Ufm-sort)
	(Ufm-keystr 'Ufm-short)
	(Ufm-keystr 'Ufm-dir-add)
	(Ufm-keystr 'Ufm-dir-menu)
	"\n≪変な機能≫\n\n"
	"        f2 : 基本マクロメニュー起動\n"
	(Ufm-keystr 'Ufm-env)
;	(Ufm-keystr 'Ufm-sed)
;	(Ufm-keystr 'Ufm-sed-do)
	(Ufm-keystr 'Ufm-find-mode)
	(Ufm-keystr 'Ufm-refind-mode)
	(Ufm-keystr 'Ufm-namazu)
	(Ufm-keystr 'Ufm-grep-mode)
	(Ufm-keystr 'Ufm-regrep-mode)
	(Ufm-keystr 'Ufm-toggle-view)
	(Ufm-keystr 'Ufm-help)
	(Ufm-keystr 'Ufm-jump)
	(Ufm-keystr 'Ufm-go-link)
	(Ufm-keystr 'Ufm-load)
	(Ufm-keystr 'Ufm-ps-mode)
	(Ufm-keystr 'Ufm-www)
	(Ufm-keystr 'Ufm-insert-file)
	"\n≪タグ関連≫\n\n"
	(Ufm-keystr 'Ufm-mark)
	(Ufm-keystr 'Ufm-mark-all)
	(Ufm-keystr 'Ufm-mark-toggle)
	(Ufm-keystr 'Ufm-mark-regexp)
	(Ufm-keystr 'Ufm-mark-regexp2)
	(Ufm-keystr 'Ufm-super-mark)
	(Ufm-keystr 'Ufm-super-cls)
	(Ufm-keystr 'Ufm-super-menu)
	"\n≪隠しファイル関連≫\n\n"
	(Ufm-keystr 'Ufm-H-dot)
	(Ufm-keystr 'Ufm-H-tog)
	(Ufm-keystr 'Ufm-H-regexp)
;	(Ufm-keystr 'Ufm-H-init)
;	(Ufm-keystr 'Ufm-H-edit)
;	(Ufm-keystr 'Ufm-H-del)
	"\n≪情報≫\n\n"
	(Ufm-keystr 'Ufm-info)
	(Ufm-keystr 'Ufm-info3)
	(Ufm-keystr 'Ufm-od)
	"\n≪その他≫\n\n"
	(Ufm-keystr 'Ufm-insert-filename)
	(Ufm-keystr 'Ufm-insert-pathname)
	(Ufm-keystr 'Ufm-chdir-selection)
	(Ufm-keystr 'Ufm-filename-selection)
	(Ufm-keystr 'Ufm-pathname-selection)
	"\n≪その他のその他≫\n\n"
	(Ufm-keystr 'Ufm-inc-filength)
	(Ufm-keystr 'Ufm-dec-filength)
	(Ufm-keystr 'Ufm-env-save)
	"\n≪ノウハウ≫\n\n"
	"	● ファイル名の入力でTABキーを２回押すと、メニューでディレクトリを選択できます\n"
	"	● 更に [ESC] キーで [,] で登録しておいたディレクトリから選ぶこともできます。\n"
	"	● ディレクトリ指定のショートカット [:] はミニバッファを消去しないでもそのまま入力できます\n"
	"	● キーバインドを変更するには以下のように ~/.emacs の最後に書きます\n"
	"		(define-key Ufm-map [(meta h)]	'Ufm-up)"
	))(goto-char 1)(Ufm-uView)
	)

;;;; Ic-Ufm.el ends here
